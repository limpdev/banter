This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where empty lines have been removed.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*.go, **/*.html, **/*.css, **/*.yml
- Files matching these patterns are excluded: node_modules, **/node_modules, **/.venv/**, **/venv/**, **/yarn.lock, **/*.md, .secrets
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files
- Long base64 data strings (e.g., data:image/png;base64,...) have been truncated to reduce token count
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
.github/ISSUE_TEMPLATE/
.github/workflows/
docs/
docs/images/
docs/images/themes/
internal/
internal/glance/
internal/glance/static/
internal/glance/static/css/
internal/glance/static/fonts/
internal/glance/static/js/
internal/glance/templates/
pkg/
pkg/sysinfo/
static/
static/favicon/
.github/FUNDING.yml
.github/ISSUE_TEMPLATE/bug_report.yml
.github/ISSUE_TEMPLATE/config.yml
.github/ISSUE_TEMPLATE/feature_request.yml
docs/glance.yml
internal/glance/auth_test.go
internal/glance/auth.go
internal/glance/cli.go
internal/glance/config-fields.go
internal/glance/config.go
internal/glance/diagnose.go
internal/glance/embed.go
internal/glance/glance.go
internal/glance/hub.go
internal/glance/main.go
internal/glance/static/css/forum-posts.css
internal/glance/static/css/login.css
internal/glance/static/css/main.css
internal/glance/static/css/mobile.css
internal/glance/static/css/popover.css
internal/glance/static/css/site.css
internal/glance/static/css/utils.css
internal/glance/static/css/widget-bookmarks.css
internal/glance/static/css/widget-calendar.css
internal/glance/static/css/widget-clock.css
internal/glance/static/css/widget-dns-stats.css
internal/glance/static/css/widget-docker-containers.css
internal/glance/static/css/widget-group.css
internal/glance/static/css/widget-markets.css
internal/glance/static/css/widget-monitor.css
internal/glance/static/css/widget-reddit.css
internal/glance/static/css/widget-releases.css
internal/glance/static/css/widget-rss.css
internal/glance/static/css/widget-search.css
internal/glance/static/css/widget-server-stats.css
internal/glance/static/css/widget-todo.css
internal/glance/static/css/widget-twitch.css
internal/glance/static/css/widget-videos.css
internal/glance/static/css/widget-weather.css
internal/glance/static/css/widgets.css
internal/glance/templates.go
internal/glance/templates/bookmarks.html
internal/glance/templates/calendar.html
internal/glance/templates/change-detection.html
internal/glance/templates/clock.html
internal/glance/templates/custom-api.html
internal/glance/templates/dns-stats.html
internal/glance/templates/docker-containers.html
internal/glance/templates/document.html
internal/glance/templates/extension.html
internal/glance/templates/footer.html
internal/glance/templates/forum-posts.html
internal/glance/templates/group.html
internal/glance/templates/iframe.html
internal/glance/templates/login.html
internal/glance/templates/markets.html
internal/glance/templates/monitor-compact.html
internal/glance/templates/monitor.html
internal/glance/templates/old-calendar.html
internal/glance/templates/page-content.html
internal/glance/templates/page.html
internal/glance/templates/reddit-horizontal-cards.html
internal/glance/templates/reddit-vertical-cards.html
internal/glance/templates/releases.html
internal/glance/templates/repository.html
internal/glance/templates/rss-detailed-list.html
internal/glance/templates/rss-horizontal-cards-2.html
internal/glance/templates/rss-horizontal-cards.html
internal/glance/templates/rss-list.html
internal/glance/templates/search.html
internal/glance/templates/server-stats.html
internal/glance/templates/split-column.html
internal/glance/templates/theme-preset-preview.html
internal/glance/templates/todo.html
internal/glance/templates/twitch-channels.html
internal/glance/templates/twitch-games-list.html
internal/glance/templates/v0.7-update-notice-page.html
internal/glance/templates/video-card-contents.html
internal/glance/templates/videos-grid.html
internal/glance/templates/videos-vertical-list.html
internal/glance/templates/videos.html
internal/glance/templates/weather.html
internal/glance/templates/widget-base.html
internal/glance/theme.go
internal/glance/utils.go
internal/glance/widget-bookmarks.go
internal/glance/widget-calendar.go
internal/glance/widget-changedetection.go
internal/glance/widget-clock.go
internal/glance/widget-container.go
internal/glance/widget-custom-api.go
internal/glance/widget-dns-stats.go
internal/glance/widget-docker-containers.go
internal/glance/widget-extension.go
internal/glance/widget-group.go
internal/glance/widget-hacker-news.go
internal/glance/widget-html.go
internal/glance/widget-iframe.go
internal/glance/widget-lobsters.go
internal/glance/widget-markets.go
internal/glance/widget-monitor.go
internal/glance/widget-old-calendar.go
internal/glance/widget-reddit.go
internal/glance/widget-releases.go
internal/glance/widget-repository.go
internal/glance/widget-rss.go
internal/glance/widget-search.go
internal/glance/widget-server-stats.go
internal/glance/widget-shared.go
internal/glance/widget-split-column.go
internal/glance/widget-todo.go
internal/glance/widget-twitch-channels.go
internal/glance/widget-twitch-top-games.go
internal/glance/widget-utils.go
internal/glance/widget-videos.go
internal/glance/widget-weather.go
internal/glance/widget.go
main.go
pkg/sysinfo/sysinfo.go
taskfile.yml
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="internal/glance/templates/change-detection.html">
{{ template "widget-base.html" . }}
{{ define "widget-content" }}
<ul class="list list-gap-14 collapsible-container" data-collapse-after="{{ .CollapseAfter }}">
    {{ range .ChangeDetections }}
    <li>
        <a class="size-h4 block text-truncate color-highlight" href="{{ .URL }}" target="_blank" rel="noreferrer">{{ .Title }}</a>
        <ul class="list-horizontal-text">
            <li {{ dynamicRelativeTimeAttrs .LastChanged }}></li>
            <li class="shrink min-width-0"><a class="visited-indicator" href="{{ .DiffURL }}" target="_blank" rel="noreferrer">diff:{{ .PreviousHash }}</a></li>
        </ul>
    </li>
    {{ else }}
    <li>No watches configured</li>
    {{ end}}
</ul>
{{ end }}
</file>

<file path="internal/glance/templates/clock.html">
{{ template "widget-base.html" . }}
{{ define "widget-content" }}
<div class="clock" data-hour-format="{{ .HourFormat }}">
    <div class="flex justify-between items-center" data-local-time>
        <div>
            <div class="color-highlight size-h1" data-date></div>
            <div data-year></div>
        </div>
        <div class="text-right">
            <div class="clock-time size-h1" data-time></div>
            <div data-weekday></div>
        </div>
    </div>
    {{ if gt (len .Timezones) 0 }}
    <hr class="margin-block-10">
    <ul class="list list-gap-4">
        {{ range .Timezones }}
        <li class="flex items-center gap-15" data-time-in-zone="{{ .Timezone }}">
            <div class="grow min-width-0">
                <div class="text-truncate">{{ if ne .Label "" }}{{ .Label }}{{ else }}{{ .Timezone }}{{ end }}</div>
            </div>
            <div class="color-subdue" data-time-diff></div>
            <div class="size-h4 clock-time shrink-0 text-right" data-time></div>
        </li>
        {{ end }}
    </ul>
    {{ end }}
</div>
{{ end }}
</file>

<file path="internal/glance/templates/custom-api.html">
{{ template "widget-base.html" . }}
{{ define "widget-content-classes" }}{{ if .Frameless }}widget-content-frameless{{ end }}{{ end }}
{{ define "widget-content" }}
{{ .CompiledHTML }}
{{ end }}
</file>

<file path="internal/glance/templates/extension.html">
{{ template "widget-base.html" . }}
{{ define "widget-content-classes" }}{{ if .Extension.Frameless }}widget-content-frameless{{ end }}{{ end }}
{{ define "widget-content" }}
{{ .Extension.Content }}
{{ end }}
</file>

<file path="internal/glance/templates/iframe.html">
{{ template "widget-base.html" . }}
{{ define "widget-content-classes" }}widget-content-frameless{{ end }}
{{ define "widget-content" }}
<iframe src="{{ .Source }}" width="100%" height="{{ .Height }}px" frameborder="0"></iframe>
{{ end }}
</file>

<file path="internal/glance/templates/monitor-compact.html">
{{ template "widget-base.html" . }}
{{ define "widget-content" }}
{{ if not (and .ShowFailingOnly (not .HasFailing)) }}
<ul class="dynamic-columns list-gap-8">
    {{ range .Sites }}
    {{ if and $.ShowFailingOnly (eq .StatusStyle "ok" ) }}{{ continue }}{{ end }}
    <div class="flex items-center gap-12">
        {{ template "site" . }}
    </div>
    {{ end }}
</ul>
{{ else }}
<div class="flex items-center justify-center gap-10 padding-block-5">
    <p>All sites are online</p>
    <svg class="shrink-0" style="width: 1.7rem;" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="var(--color-positive)">
        <path fill-rule="evenodd" d="M2.25 12c0-5.385 4.365-9.75 9.75-9.75s9.75 4.365 9.75 9.75-4.365 9.75-9.75 9.75S2.25 17.385 2.25 12Zm13.36-1.814a.75.75 0 1 0-1.22-.872l-3.236 4.53L9.53 12.22a.75.75 0 0 0-1.06 1.06l2.25 2.25a.75.75 0 0 0 1.14-.094l3.75-5.25Z" clip-rule="evenodd" />
    </svg>
</div>
{{ end }}
{{ end }}
{{ define "site" }}
<a class="size-title-dynamic color-highlight text-truncate block grow" href="{{ .URL | safeURL }}" {{ if not .SameTab }}target="_blank"{{ end }} rel="noreferrer">{{ .Title }}</a>
{{ if not .Status.TimedOut }}<div>{{ .Status.ResponseTime.Milliseconds | formatNumber }}ms</div>{{ end }}
{{ if eq .StatusStyle "ok" }}
<div class="monitor-site-status-icon-compact" title="{{ .Status.Code }}">
    <svg fill="var(--color-positive)" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20">
        <path fill-rule="evenodd" d="M10 18a8 8 0 1 0 0-16 8 8 0 0 0 0 16Zm3.857-9.809a.75.75 0 0 0-1.214-.882l-3.483 4.79-1.88-1.88a.75.75 0 1 0-1.06 1.061l2.5 2.5a.75.75 0 0 0 1.137-.089l4-5.5Z" clip-rule="evenodd" />
    </svg>
</div>
{{ else }}
<div class="monitor-site-status-icon-compact" title="{{ if .Status.Error }}{{ .Status.Error }}{{ else }}{{ .Status.Code }}{{ end }}">
    <svg fill="var(--color-negative)" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20">
        <path fill-rule="evenodd" d="M8.485 2.495c.673-1.167 2.357-1.167 3.03 0l6.28 10.875c.673 1.167-.17 2.625-1.516 2.625H3.72c-1.347 0-2.189-1.458-1.515-2.625L8.485 2.495ZM10 5a.75.75 0 0 1 .75.75v3.5a.75.75 0 0 1-1.5 0v-3.5A.75.75 0 0 1 10 5Zm0 9a1 1 0 1 0 0-2 1 1 0 0 0 0 2Z" clip-rule="evenodd" />
    </svg>
</div>
{{ end }}
{{ end }}
</file>

<file path="internal/glance/templates/releases.html">
{{ template "widget-base.html" . }}
{{ define "widget-content" }}
<ul class="list list-gap-10 collapsible-container" data-collapse-after="{{ .CollapseAfter }}">
    {{ range .Releases }}
    <li>
        <div class="flex items-center gap-10">
            <a class="size-h4 block text-truncate color-primary-if-not-visited" href="{{ .NotesUrl }}" target="_blank" rel="noreferrer">{{ .Name }}</a>
            {{ if $.ShowSourceIcon }}
            <img class="flat-icon release-source-icon" src="{{ .SourceIconURL }}" alt="" loading="lazy">
            {{ end }}
        </div>
        <ul class="list-horizontal-text">
            <li {{ dynamicRelativeTimeAttrs .TimeReleased }}></li>
            <li>{{ .Version }}</li>
            {{ if gt .Downvotes 3 }}
            <li>{{ .Downvotes | formatNumber }} ⚠</li>
            {{ end }}
        </ul>
    </li>
    {{ end }}
</ul>
{{ end }}
</file>

<file path="internal/glance/templates/rss-detailed-list.html">
{{ template "widget-base.html" . }}
{{ define "widget-content" }}
<ul class="list list-gap-24 collapsible-container" data-collapse-after="{{ .CollapseAfter }}">
    {{ range .Items }}
    <li class="flex gap-15 items-start row-reverse-on-mobile thumbnail-parent">
        <div class="thumbnail-container rss-detailed-thumbnail">
            {{ if ne "" .ImageURL }}
            <img class="thumbnail" loading="lazy" src="{{ .ImageURL }}" alt="">
            {{ else }}
            <svg class="scale-half hide-on-mobile" stroke="var(--color-text-subdue)" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5">
                <path stroke-linecap="round" stroke-linejoin="round" d="m2.25 15.75 5.159-5.159a2.25 2.25 0 0 1 3.182 0l5.159 5.159m-1.5-1.5 1.409-1.409a2.25 2.25 0 0 1 3.182 0l2.909 2.909m-18 3.75h16.5a1.5 1.5 0 0 0 1.5-1.5V6a1.5 1.5 0 0 0-1.5-1.5H3.75A1.5 1.5 0 0 0 2.25 6v12a1.5 1.5 0 0 0 1.5 1.5Zm10.5-11.25h.008v.008h-.008V8.25Zm.375 0a.375.375 0 1 1-.75 0 .375.375 0 0 1 .75 0Z" />
            </svg>
            {{ end }}
        </div>
        <div class="grow min-width-0">
            <a class="size-h3 color-primary-if-not-visited" href="{{ .Link }}" target="_blank" rel="noreferrer">{{ .Title }}</a>
            <ul class="list-horizontal-text flex-nowrap">
                <li {{ dynamicRelativeTimeAttrs .PublishedAt }}></li>
                <li class="min-width-0">
                    <a class="block text-truncate" href="{{ .ChannelURL }}" target="_blank" rel="noreferrer">{{ .ChannelName }}</a>
                </li>
            </ul>
            {{ if ne "" .Description }}
            <p class="rss-detailed-description text-truncate-2-lines margin-top-10">{{ .Description }}</p>
            {{ end }}
            {{ if gt (len .Categories) 0 }}
            <ul class="attachments margin-top-10">
            {{ range .Categories }}
                <li>{{ . }}</li>
            {{ end }}
            </ul>
            {{ end }}
        </div>
    </li>
    {{ else }}
    <li>{{ .NoItemsMessage }}</li>
    {{ end }}
</ul>
{{ end }}
</file>

<file path="internal/glance/templates/rss-horizontal-cards-2.html">
{{ template "widget-base.html" . }}
{{ define "widget-content-classes" }}widget-content-frameless{{ end }}
{{ define "widget-content" }}
{{ if gt (len .Items) 0 }}
<div class="carousel-container">
    <div class="cards-horizontal carousel-items-container"{{ if ne 0.0 .CardHeight }} style="--rss-card-height: {{ .CardHeight }}rem;"{{ end }}>
        {{ range .Items }}
        <div class="card rss-card-2 widget-content-frame thumbnail-parent">
            {{ if ne "" .ImageURL }}
            <img class="rss-card-2-image thumbnail" loading="lazy" src="{{ .ImageURL }}" alt="">
            {{ else }}
            <svg class="rss-card-2-image" style="transform: scale(0.35) translateY(-25%)" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="var(--color-text-subdue)">
                <path stroke-linecap="round" stroke-linejoin="round" d="m2.25 15.75 5.159-5.159a2.25 2.25 0 0 1 3.182 0l5.159 5.159m-1.5-1.5 1.409-1.409a2.25 2.25 0 0 1 3.182 0l2.909 2.909m-18 3.75h16.5a1.5 1.5 0 0 0 1.5-1.5V6a1.5 1.5 0 0 0-1.5-1.5H3.75A1.5 1.5 0 0 0 2.25 6v12a1.5 1.5 0 0 0 1.5 1.5Zm10.5-11.25h.008v.008h-.008V8.25Zm.375 0a.375.375 0 1 1-.75 0 .375.375 0 0 1 .75 0Z" />
            </svg>
            {{ end }}
            <div class="rss-card-2-content padding-inline-widget">
                <a href="{{ .Link }}" class="block text-truncate color-primary-if-not-visited" target="_blank" rel="noreferrer">{{ .Title }}</a>
                <ul class="list-horizontal-text flex-nowrap margin-top-5">
                    <li class="shrink-0" {{ dynamicRelativeTimeAttrs .PublishedAt }}></li>
                    <li class="min-width-0 text-truncate">{{ .ChannelName }}</li>
                </ul>
            </div>
        </div>
        {{ end }}
    </div>
</div>
{{ else }}
<div class="widget-content-frame padding-widget">{{ .NoItemsMessage }}</div>
{{ end }}
{{ end }}
</file>

<file path="internal/glance/templates/rss-horizontal-cards.html">
{{ template "widget-base.html" . }}
{{ define "widget-content-classes" }}widget-content-frameless{{ end }}
{{ define "widget-content" }}
{{ if gt (len .Items) 0 }}
<div class="carousel-container">
    <div class="cards-horizontal carousel-items-container"{{ if ne 0.0 .ThumbnailHeight }} style="--rss-thumbnail-height: {{ .ThumbnailHeight }}rem;"{{ end }}>
        {{ range .Items }}
        <div class="card widget-content-frame thumbnail-parent">
            {{ if ne "" .ImageURL }}
            <img class="rss-card-image thumbnail" loading="lazy" src="{{ .ImageURL }}" alt="">
            {{ else }}
            <svg class="rss-card-image" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="var(--color-text-subdue)">
                <path stroke-linecap="round" stroke-linejoin="round" d="m2.25 15.75 5.159-5.159a2.25 2.25 0 0 1 3.182 0l5.159 5.159m-1.5-1.5 1.409-1.409a2.25 2.25 0 0 1 3.182 0l2.909 2.909m-18 3.75h16.5a1.5 1.5 0 0 0 1.5-1.5V6a1.5 1.5 0 0 0-1.5-1.5H3.75A1.5 1.5 0 0 0 2.25 6v12a1.5 1.5 0 0 0 1.5 1.5Zm10.5-11.25h.008v.008h-.008V8.25Zm.375 0a.375.375 0 1 1-.75 0 .375.375 0 0 1 .75 0Z" />
            </svg>
            {{ end }}
            <div class="margin-bottom-widget padding-inline-widget flex flex-column grow">
                <a href="{{ .Link }}" class="text-truncate-3-lines color-primary-if-not-visited margin-top-10 margin-bottom-auto" target="_blank" rel="noreferrer">{{ .Title }}</a>
                <ul class="list-horizontal-text flex-nowrap margin-top-7">
                    <li class="shrink-0" {{ dynamicRelativeTimeAttrs .PublishedAt }}></li>
                    <li class="min-width-0 text-truncate">{{ .ChannelName }}</li>
                </ul>
            </div>
        </div>
        {{ end }}
    </div>
</div>
{{ else }}
<div class="widget-content-frame padding-widget">{{ .NoItemsMessage }}</div>
{{ end }}
{{ end }}
</file>

<file path="internal/glance/templates/rss-list.html">
{{ template "widget-base.html" . }}
{{ define "widget-content" }}
<ul class="list list-gap-14 collapsible-container{{ if .SingleLineTitles }} single-line-titles{{ end }}" data-collapse-after="{{ .CollapseAfter }}">
    {{ range .Items }}
    <li>
        <a class="title size-title-dynamic color-primary-if-not-visited" href="{{ .Link }}" target="_blank" rel="noreferrer">{{ .Title }}</a>
        <ul class="list-horizontal-text flex-nowrap">
            <li {{ dynamicRelativeTimeAttrs .PublishedAt }}></li>
            <li class="min-width-0">
                <a class="block text-truncate" href="{{ .ChannelURL }}" target="_blank" rel="noreferrer">{{ .ChannelName }}</a>
            </li>
        </ul>
    </li>
    {{ else }}
    <li>{{ .NoItemsMessage }}</li>
    {{ end }}
</ul>
{{ end }}
</file>

<file path="internal/glance/templates/split-column.html">
{{ template "widget-base.html" . }}
{{ define "widget-content-classes" }}widget-content-frameless{{ end }}
{{ define "widget-content" }}
<div class="masonry" data-max-columns="{{ .MaxColumns }}">
{{ range .Widgets }}
    {{ .Render }}
{{ end }}
</div>
{{ end }}
</file>

<file path="internal/glance/templates/videos-grid.html">
{{ template "widget-base.html" . }}
{{ define "widget-content-classes" }}widget-content-frameless{{ end }}
{{ define "widget-content" }}
<div class="cards-grid collapsible-container" data-collapse-after-rows="{{ .CollapseAfterRows }}">
    {{ range .Videos }}
    <div class="card widget-content-frame thumbnail-parent">
        {{ template "video-card-contents" . }}
    </div>
    {{ end }}
</div>
{{ end }}
</file>

<file path="internal/glance/templates/videos.html">
{{ template "widget-base.html" . }}
{{ define "widget-content-classes" }}widget-content-frameless{{ end }}
{{ define "widget-content" }}
<div class="carousel-container">
    <div class="cards-horizontal carousel-items-container">
        {{ range .Videos }}
        <div class="card widget-content-frame thumbnail-parent">
            {{ template "video-card-contents" . }}
        </div>
        {{ end }}
    </div>
</div>
{{ end }}
</file>

<file path="internal/glance/templates/weather.html">
{{ template "widget-base.html" . }}
{{ define "widget-content" }}
<div class="widget-small-content-bounds">
    <div class="size-h2 color-highlight text-center">{{ .Weather.WeatherCodeAsString }}</div>
    <div class="size-h4 text-center">Feels like {{ .Weather.ApparentTemperature }}°{{ if eq .Units "metric" }}C{{ else }}F{{ end }}</div>
    <div class="weather-columns flex margin-top-15 justify-center">
        {{ range $i, $column := .Weather.Columns }}
        <div class="weather-column{{ if eq $i $.Weather.CurrentColumn }} weather-column-current{{ end }}">
            {{ if $column.HasPrecipitation }}
            <div class="weather-column-rain"></div>
            {{ end }}
            {{ if and (ge $i $.Weather.SunriseColumn) (le $i $.Weather.SunsetColumn ) }}
            <div class="weather-column-daylight{{ if eq $i $.Weather.SunriseColumn }} weather-column-daylight-sunrise{{ else if eq $i $.Weather.SunsetColumn }} weather-column-daylight-sunset{{ end }}"></div>
            {{ end }}
            <div class="weather-column-value{{ if lt $column.Temperature 0 }} weather-column-value-negative{{ end }}">{{ $column.Temperature | absInt }}</div>
            <div class="weather-bar" style='--weather-bar-height: {{ printf "%.2f" $column.Scale }}'></div>
            <div class="weather-column-time">{{ index $.TimeLabels $i }}</div>
        </div>
        {{ end }}
    </div>
    {{ if not .HideLocation }}
    <div class="flex items-center justify-center margin-top-15 gap-7 size-h5">
        <div class="location-icon"></div>
        <div class="text-truncate">{{ .Place.Name }},{{ if .ShowAreaName }} {{ .Place.Area }},{{ end }} {{ .Place.Country }}</div>
    </div>
    {{ end }}
</div>
{{ end }}
</file>

<file path="internal/glance/widget-changedetection.go">
package glance
import (
	"context"
	"fmt"
	"html/template"
	"log/slog"
	"net/http"
	"sort"
	"strings"
	"time"
)
var changeDetectionWidgetTemplate = mustParseTemplate("change-detection.html", "widget-base.html")
type changeDetectionWidget struct {
	widgetBase       `yaml:",inline"`
	ChangeDetections changeDetectionWatchList `yaml:"-"`
	WatchUUIDs       []string                 `yaml:"watches"`
	InstanceURL      string                   `yaml:"instance-url"`
	Token            string                   `yaml:"token"`
	Limit            int                      `yaml:"limit"`
	CollapseAfter    int                      `yaml:"collapse-after"`
}
func (widget *changeDetectionWidget) initialize() error {
	widget.withTitle("Change Detection").withCacheDuration(1 * time.Hour)
	if widget.Limit <= 0 {
		widget.Limit = 10
	}
	if widget.CollapseAfter == 0 || widget.CollapseAfter < -1 {
		widget.CollapseAfter = 5
	}
	if widget.InstanceURL == "" {
		widget.InstanceURL = "https://www.changedetection.io"
	}
	return nil
}
func (widget *changeDetectionWidget) update(ctx context.Context) {
	if len(widget.WatchUUIDs) == 0 {
		uuids, err := fetchWatchUUIDsFromChangeDetection(widget.InstanceURL, string(widget.Token))
		if !widget.canContinueUpdateAfterHandlingErr(err) {
			return
		}
		widget.WatchUUIDs = uuids
	}
	watches, err := fetchWatchesFromChangeDetection(widget.InstanceURL, widget.WatchUUIDs, string(widget.Token))
	if !widget.canContinueUpdateAfterHandlingErr(err) {
		return
	}
	if len(watches) > widget.Limit {
		watches = watches[:widget.Limit]
	}
	widget.ChangeDetections = watches
}
func (widget *changeDetectionWidget) Render() template.HTML {
	return widget.renderTemplate(widget, changeDetectionWidgetTemplate)
}
type changeDetectionWatch struct {
	Title        string
	URL          string
	LastChanged  time.Time
	DiffURL      string
	PreviousHash string
}
type changeDetectionWatchList []changeDetectionWatch
func (r changeDetectionWatchList) sortByNewest() changeDetectionWatchList {
	sort.Slice(r, func(i, j int) bool {
		return r[i].LastChanged.After(r[j].LastChanged)
	})
	return r
}
type changeDetectionResponseJson struct {
	Title        string `json:"title"`
	URL          string `json:"url"`
	LastChanged  int64  `json:"last_changed"`
	DateCreated  int64  `json:"date_created"`
	PreviousHash string `json:"previous_md5"`
}
func fetchWatchUUIDsFromChangeDetection(instanceURL string, token string) ([]string, error) {
	request, _ := http.NewRequest("GET", fmt.Sprintf("%s/api/v1/watch", instanceURL), nil)
	if token != "" {
		request.Header.Add("x-api-key", token)
	}
	uuidsMap, err := decodeJsonFromRequest[map[string]struct{}](defaultHTTPClient, request)
	if err != nil {
		return nil, fmt.Errorf("could not fetch list of watch UUIDs: %v", err)
	}
	uuids := make([]string, 0, len(uuidsMap))
	for uuid := range uuidsMap {
		uuids = append(uuids, uuid)
	}
	return uuids, nil
}
func fetchWatchesFromChangeDetection(instanceURL string, requestedWatchIDs []string, token string) (changeDetectionWatchList, error) {
	watches := make(changeDetectionWatchList, 0, len(requestedWatchIDs))
	if len(requestedWatchIDs) == 0 {
		return watches, nil
	}
	requests := make([]*http.Request, len(requestedWatchIDs))
	for i, repository := range requestedWatchIDs {
		request, _ := http.NewRequest("GET", fmt.Sprintf("%s/api/v1/watch/%s", instanceURL, repository), nil)
		if token != "" {
			request.Header.Add("x-api-key", token)
		}
		requests[i] = request
	}
	task := decodeJsonFromRequestTask[changeDetectionResponseJson](defaultHTTPClient)
	job := newJob(task, requests).withWorkers(15)
	responses, errs, err := workerPoolDo(job)
	if err != nil {
		return nil, err
	}
	var failed int
	for i := range responses {
		if errs[i] != nil {
			failed++
			slog.Error("Failed to fetch or parse change detection watch", "url", requests[i].URL, "error", errs[i])
			continue
		}
		watchJson := responses[i]
		watch := changeDetectionWatch{
			URL:     watchJson.URL,
			DiffURL: fmt.Sprintf("%s/diff/%s?from_version=%d", instanceURL, requestedWatchIDs[i], watchJson.LastChanged-1),
		}
		if watchJson.LastChanged == 0 {
			watch.LastChanged = time.Unix(watchJson.DateCreated, 0)
		} else {
			watch.LastChanged = time.Unix(watchJson.LastChanged, 0)
		}
		if watchJson.Title != "" {
			watch.Title = watchJson.Title
		} else {
			watch.Title = strings.TrimPrefix(strings.Trim(stripURLScheme(watchJson.URL), "/"), "www.")
		}
		if watchJson.PreviousHash != "" {
			var hashLength = 8
			if len(watchJson.PreviousHash) < hashLength {
				hashLength = len(watchJson.PreviousHash)
			}
			watch.PreviousHash = watchJson.PreviousHash[0:hashLength]
		}
		watches = append(watches, watch)
	}
	if len(watches) == 0 {
		return nil, errNoContent
	}
	watches.sortByNewest()
	if failed > 0 {
		return watches, fmt.Errorf("%w: could not get %d watches", errPartialContent, failed)
	}
	return watches, nil
}
</file>

<file path="internal/glance/widget-clock.go">
package glance
import (
	"errors"
	"fmt"
	"html/template"
	"time"
)
var clockWidgetTemplate = mustParseTemplate("clock.html", "widget-base.html")
type clockWidget struct {
	widgetBase `yaml:",inline"`
	cachedHTML template.HTML `yaml:"-"`
	HourFormat string        `yaml:"hour-format"`
	Timezones  []struct {
		Timezone string `yaml:"timezone"`
		Label    string `yaml:"label"`
	} `yaml:"timezones"`
}
func (widget *clockWidget) initialize() error {
	widget.withTitle("Clock").withError(nil)
	if widget.HourFormat == "" {
		widget.HourFormat = "24h"
	} else if widget.HourFormat != "12h" && widget.HourFormat != "24h" {
		return errors.New("hour-format must be either 12h or 24h")
	}
	for t := range widget.Timezones {
		if widget.Timezones[t].Timezone == "" {
			return errors.New("missing timezone value")
		}
		if _, err := time.LoadLocation(widget.Timezones[t].Timezone); err != nil {
			return fmt.Errorf("invalid timezone '%s': %v", widget.Timezones[t].Timezone, err)
		}
	}
	widget.cachedHTML = widget.renderTemplate(widget, clockWidgetTemplate)
	return nil
}
func (widget *clockWidget) Render() template.HTML {
	return widget.cachedHTML
}
</file>

<file path="internal/glance/widget-container.go">
package glance
import (
	"context"
	"sync"
	"time"
)
type containerWidgetBase struct {
	Widgets widgets `yaml:"widgets"`
}
func (widget *containerWidgetBase) _initializeWidgets() error {
	for i := range widget.Widgets {
		if err := widget.Widgets[i].initialize(); err != nil {
			return formatWidgetInitError(err, widget.Widgets[i])
		}
	}
	return nil
}
func (widget *containerWidgetBase) _update(ctx context.Context) {
	var wg sync.WaitGroup
	now := time.Now()
	for w := range widget.Widgets {
		widget := widget.Widgets[w]
		if !widget.requiresUpdate(&now) {
			continue
		}
		wg.Add(1)
		go func() {
			defer wg.Done()
			widget.update(ctx)
		}()
	}
	wg.Wait()
}
func (widget *containerWidgetBase) _setProviders(providers *widgetProviders) {
	for i := range widget.Widgets {
		widget.Widgets[i].setProviders(providers)
	}
}
func (widget *containerWidgetBase) _requiresUpdate(now *time.Time) bool {
	for i := range widget.Widgets {
		if widget.Widgets[i].requiresUpdate(now) {
			return true
		}
	}
	return false
}
</file>

<file path="internal/glance/widget-group.go">
package glance
import (
	"context"
	"errors"
	"html/template"
	"time"
)
var groupWidgetTemplate = mustParseTemplate("group.html", "widget-base.html")
type groupWidget struct {
	widgetBase          `yaml:",inline"`
	containerWidgetBase `yaml:",inline"`
}
func (widget *groupWidget) initialize() error {
	widget.withError(nil)
	widget.HideHeader = true
	for i := range widget.Widgets {
		widget.Widgets[i].setHideHeader(true)
		if widget.Widgets[i].GetType() == "group" {
			return errors.New("nested groups are not supported")
		} else if widget.Widgets[i].GetType() == "split-column" {
			return errors.New("split columns inside of groups are not supported")
		}
	}
	if err := widget.containerWidgetBase._initializeWidgets(); err != nil {
		return err
	}
	return nil
}
func (widget *groupWidget) update(ctx context.Context) {
	widget.containerWidgetBase._update(ctx)
}
func (widget *groupWidget) setProviders(providers *widgetProviders) {
	widget.containerWidgetBase._setProviders(providers)
}
func (widget *groupWidget) requiresUpdate(now *time.Time) bool {
	return widget.containerWidgetBase._requiresUpdate(now)
}
func (widget *groupWidget) Render() template.HTML {
	return widget.renderTemplate(widget, groupWidgetTemplate)
}
</file>

<file path="internal/glance/widget-hacker-news.go">
package glance
import (
	"context"
	"fmt"
	"html/template"
	"log/slog"
	"net/http"
	"strconv"
	"strings"
	"time"
)
type hackerNewsWidget struct {
	widgetBase          `yaml:",inline"`
	Posts               forumPostList `yaml:"-"`
	Limit               int           `yaml:"limit"`
	SortBy              string        `yaml:"sort-by"`
	ExtraSortBy         string        `yaml:"extra-sort-by"`
	CollapseAfter       int           `yaml:"collapse-after"`
	CommentsUrlTemplate string        `yaml:"comments-url-template"`
	ShowThumbnails      bool          `yaml:"-"`
}
func (widget *hackerNewsWidget) initialize() error {
	widget.
		withTitle("Hacker News").
		withTitleURL("https://news.ycombinator.com/").
		withCacheDuration(30 * time.Minute)
	if widget.Limit <= 0 {
		widget.Limit = 15
	}
	if widget.CollapseAfter == 0 || widget.CollapseAfter < -1 {
		widget.CollapseAfter = 5
	}
	if widget.SortBy != "top" && widget.SortBy != "new" && widget.SortBy != "best" {
		widget.SortBy = "top"
	}
	return nil
}
func (widget *hackerNewsWidget) update(ctx context.Context) {
	posts, err := fetchHackerNewsPosts(widget.SortBy, 40, widget.CommentsUrlTemplate)
	if !widget.canContinueUpdateAfterHandlingErr(err) {
		return
	}
	if widget.ExtraSortBy == "engagement" {
		posts.calculateEngagement()
		posts.sortByEngagement()
	}
	if widget.Limit < len(posts) {
		posts = posts[:widget.Limit]
	}
	widget.Posts = posts
}
func (widget *hackerNewsWidget) Render() template.HTML {
	return widget.renderTemplate(widget, forumPostsTemplate)
}
type hackerNewsPostResponseJson struct {
	Id           int    `json:"id"`
	Score        int    `json:"score"`
	Title        string `json:"title"`
	TargetUrl    string `json:"url,omitempty"`
	CommentCount int    `json:"descendants"`
	TimePosted   int64  `json:"time"`
}
func fetchHackerNewsPostIds(sort string) ([]int, error) {
	request, _ := http.NewRequest("GET", fmt.Sprintf("https://hacker-news.firebaseio.com/v0/%sstories.json", sort), nil)
	response, err := decodeJsonFromRequest[[]int](defaultHTTPClient, request)
	if err != nil {
		return nil, fmt.Errorf("%w: could not fetch list of post IDs", errNoContent)
	}
	return response, nil
}
func fetchHackerNewsPostsFromIds(postIds []int, commentsUrlTemplate string) (forumPostList, error) {
	requests := make([]*http.Request, len(postIds))
	for i, id := range postIds {
		request, _ := http.NewRequest("GET", fmt.Sprintf("https://hacker-news.firebaseio.com/v0/item/%d.json", id), nil)
		requests[i] = request
	}
	task := decodeJsonFromRequestTask[hackerNewsPostResponseJson](defaultHTTPClient)
	job := newJob(task, requests).withWorkers(30)
	results, errs, err := workerPoolDo(job)
	if err != nil {
		return nil, err
	}
	posts := make(forumPostList, 0, len(postIds))
	for i := range results {
		if errs[i] != nil {
			slog.Error("Failed to fetch or parse hacker news post", "error", errs[i], "url", requests[i].URL)
			continue
		}
		var commentsUrl string
		if commentsUrlTemplate == "" {
			commentsUrl = "https://news.ycombinator.com/item?id=" + strconv.Itoa(results[i].Id)
		} else {
			commentsUrl = strings.ReplaceAll(commentsUrlTemplate, "{POST-ID}", strconv.Itoa(results[i].Id))
		}
		posts = append(posts, forumPost{
			Title:           results[i].Title,
			DiscussionUrl:   commentsUrl,
			TargetUrl:       results[i].TargetUrl,
			TargetUrlDomain: extractDomainFromUrl(results[i].TargetUrl),
			CommentCount:    results[i].CommentCount,
			Score:           results[i].Score,
			TimePosted:      time.Unix(results[i].TimePosted, 0),
		})
	}
	if len(posts) == 0 {
		return nil, errNoContent
	}
	if len(posts) != len(postIds) {
		return posts, fmt.Errorf("%w could not fetch some hacker news posts", errPartialContent)
	}
	return posts, nil
}
func fetchHackerNewsPosts(sort string, limit int, commentsUrlTemplate string) (forumPostList, error) {
	postIds, err := fetchHackerNewsPostIds(sort)
	if err != nil {
		return nil, err
	}
	if len(postIds) > limit {
		postIds = postIds[:limit]
	}
	return fetchHackerNewsPostsFromIds(postIds, commentsUrlTemplate)
}
</file>

<file path="internal/glance/widget-html.go">
package glance
import (
	"html/template"
)
type htmlWidget struct {
	widgetBase `yaml:",inline"`
	Source     template.HTML `yaml:"source"`
}
func (widget *htmlWidget) initialize() error {
	widget.withTitle("").withError(nil)
	return nil
}
func (widget *htmlWidget) Render() template.HTML {
	return widget.Source
}
</file>

<file path="internal/glance/widget-iframe.go">
package glance
import (
	"errors"
	"fmt"
	"html/template"
	"net/url"
)
var iframeWidgetTemplate = mustParseTemplate("iframe.html", "widget-base.html")
type iframeWidget struct {
	widgetBase `yaml:",inline"`
	cachedHTML template.HTML `yaml:"-"`
	Source     string        `yaml:"source"`
	Height     int           `yaml:"height"`
}
func (widget *iframeWidget) initialize() error {
	widget.withTitle("IFrame").withError(nil)
	if widget.Source == "" {
		return errors.New("source is required")
	}
	if _, err := url.Parse(widget.Source); err != nil {
		return fmt.Errorf("parsing URL: %v", err)
	}
	if widget.Height == 50 {
		widget.Height = 300
	} else if widget.Height < 50 {
		widget.Height = 50
	}
	widget.cachedHTML = widget.renderTemplate(widget, iframeWidgetTemplate)
	return nil
}
func (widget *iframeWidget) Render() template.HTML {
	return widget.cachedHTML
}
</file>

<file path="internal/glance/widget-lobsters.go">
package glance
import (
	"context"
	"html/template"
	"net/http"
	"strings"
	"time"
)
type lobstersWidget struct {
	widgetBase     `yaml:",inline"`
	Posts          forumPostList `yaml:"-"`
	InstanceURL    string        `yaml:"instance-url"`
	CustomURL      string        `yaml:"custom-url"`
	Limit          int           `yaml:"limit"`
	CollapseAfter  int           `yaml:"collapse-after"`
	SortBy         string        `yaml:"sort-by"`
	Tags           []string      `yaml:"tags"`
	ShowThumbnails bool          `yaml:"-"`
}
func (widget *lobstersWidget) initialize() error {
	widget.withTitle("Lobsters").withCacheDuration(time.Hour)
	if widget.InstanceURL == "" {
		widget.withTitleURL("https://lobste.rs")
	} else {
		widget.withTitleURL(widget.InstanceURL)
	}
	if widget.SortBy == "" || (widget.SortBy != "hot" && widget.SortBy != "new") {
		widget.SortBy = "hot"
	}
	if widget.Limit <= 0 {
		widget.Limit = 15
	}
	if widget.CollapseAfter == 0 || widget.CollapseAfter < -1 {
		widget.CollapseAfter = 5
	}
	return nil
}
func (widget *lobstersWidget) update(ctx context.Context) {
	posts, err := fetchLobstersPosts(widget.CustomURL, widget.InstanceURL, widget.SortBy, widget.Tags)
	if !widget.canContinueUpdateAfterHandlingErr(err) {
		return
	}
	if widget.Limit < len(posts) {
		posts = posts[:widget.Limit]
	}
	widget.Posts = posts
}
func (widget *lobstersWidget) Render() template.HTML {
	return widget.renderTemplate(widget, forumPostsTemplate)
}
type lobstersPostResponseJson struct {
	CreatedAt    string   `json:"created_at"`
	Title        string   `json:"title"`
	URL          string   `json:"url"`
	Score        int      `json:"score"`
	CommentCount int      `json:"comment_count"`
	CommentsURL  string   `json:"comments_url"`
	Tags         []string `json:"tags"`
}
type lobstersFeedResponseJson []lobstersPostResponseJson
func fetchLobstersPostsFromFeed(feedUrl string) (forumPostList, error) {
	request, err := http.NewRequest("GET", feedUrl, nil)
	if err != nil {
		return nil, err
	}
	feed, err := decodeJsonFromRequest[lobstersFeedResponseJson](defaultHTTPClient, request)
	if err != nil {
		return nil, err
	}
	posts := make(forumPostList, 0, len(feed))
	for i := range feed {
		createdAt, _ := time.Parse(time.RFC3339, feed[i].CreatedAt)
		posts = append(posts, forumPost{
			Title:           feed[i].Title,
			DiscussionUrl:   feed[i].CommentsURL,
			TargetUrl:       feed[i].URL,
			TargetUrlDomain: extractDomainFromUrl(feed[i].URL),
			CommentCount:    feed[i].CommentCount,
			Score:           feed[i].Score,
			TimePosted:      createdAt,
			Tags:            feed[i].Tags,
		})
	}
	if len(posts) == 0 {
		return nil, errNoContent
	}
	return posts, nil
}
func fetchLobstersPosts(customURL string, instanceURL string, sortBy string, tags []string) (forumPostList, error) {
	var feedUrl string
	if customURL != "" {
		feedUrl = customURL
	} else {
		if instanceURL != "" {
			instanceURL = strings.TrimRight(instanceURL, "/") + "/"
		} else {
			instanceURL = "https://lobste.rs/"
		}
		if sortBy == "hot" {
			sortBy = "hottest"
		} else if sortBy == "new" {
			sortBy = "newest"
		}
		if len(tags) == 0 {
			feedUrl = instanceURL + sortBy + ".json"
		} else {
			tags := strings.Join(tags, ",")
			feedUrl = instanceURL + "t/" + tags + ".json"
		}
	}
	posts, err := fetchLobstersPostsFromFeed(feedUrl)
	if err != nil {
		return nil, err
	}
	return posts, nil
}
</file>

<file path="internal/glance/widget-repository.go">
package glance
import (
	"context"
	"fmt"
	"html/template"
	"net/http"
	"strings"
	"sync"
	"time"
)
var repositoryWidgetTemplate = mustParseTemplate("repository.html", "widget-base.html")
type repositoryWidget struct {
	widgetBase          `yaml:",inline"`
	RequestedRepository string     `yaml:"repository"`
	Token               string     `yaml:"token"`
	PullRequestsLimit   int        `yaml:"pull-requests-limit"`
	IssuesLimit         int        `yaml:"issues-limit"`
	CommitsLimit        int        `yaml:"commits-limit"`
	Repository          repository `yaml:"-"`
}
func (widget *repositoryWidget) initialize() error {
	widget.withTitle("Repository").withCacheDuration(1 * time.Hour)
	if widget.PullRequestsLimit == 0 || widget.PullRequestsLimit < -1 {
		widget.PullRequestsLimit = 3
	}
	if widget.IssuesLimit == 0 || widget.IssuesLimit < -1 {
		widget.IssuesLimit = 3
	}
	if widget.CommitsLimit == 0 || widget.CommitsLimit < -1 {
		widget.CommitsLimit = -1
	}
	return nil
}
func (widget *repositoryWidget) update(ctx context.Context) {
	details, err := fetchRepositoryDetailsFromGithub(
		widget.RequestedRepository,
		string(widget.Token),
		widget.PullRequestsLimit,
		widget.IssuesLimit,
		widget.CommitsLimit,
	)
	if !widget.canContinueUpdateAfterHandlingErr(err) {
		return
	}
	widget.Repository = details
}
func (widget *repositoryWidget) Render() template.HTML {
	return widget.renderTemplate(widget, repositoryWidgetTemplate)
}
type repository struct {
	Name             string
	Stars            int
	Forks            int
	OpenPullRequests int
	PullRequests     []githubTicket
	OpenIssues       int
	Issues           []githubTicket
	LastCommits      int
	Commits          []githubCommitDetails
}
type githubTicket struct {
	Number    int
	CreatedAt time.Time
	Title     string
}
type githubCommitDetails struct {
	Sha       string
	Author    string
	CreatedAt time.Time
	Message   string
}
type githubRepositoryResponseJson struct {
	Name  string `json:"full_name"`
	Stars int    `json:"stargazers_count"`
	Forks int    `json:"forks_count"`
}
type githubTicketResponseJson struct {
	Count   int `json:"total_count"`
	Tickets []struct {
		Number    int    `json:"number"`
		CreatedAt string `json:"created_at"`
		Title     string `json:"title"`
	} `json:"items"`
}
type gitHubCommitResponseJson struct {
	Sha    string `json:"sha"`
	Commit struct {
		Author struct {
			Name string `json:"name"`
			Date string `json:"date"`
		} `json:"author"`
		Message string `json:"message"`
	} `json:"commit"`
}
func fetchRepositoryDetailsFromGithub(repo string, token string, maxPRs int, maxIssues int, maxCommits int) (repository, error) {
	repositoryRequest, err := http.NewRequest("GET", fmt.Sprintf("https://api.github.com/repos/%s", repo), nil)
	if err != nil {
		return repository{}, fmt.Errorf("%w: could not create request with repository: %v", errNoContent, err)
	}
	PRsRequest, _ := http.NewRequest("GET", fmt.Sprintf("https://api.github.com/search/issues?q=is:pr+is:open+repo:%s&per_page=%d", repo, maxPRs), nil)
	issuesRequest, _ := http.NewRequest("GET", fmt.Sprintf("https://api.github.com/search/issues?q=is:issue+is:open+repo:%s&per_page=%d", repo, maxIssues), nil)
	CommitsRequest, _ := http.NewRequest("GET", fmt.Sprintf("https://api.github.com/repos/%s/commits?per_page=%d", repo, maxCommits), nil)
	if token != "" {
		token = fmt.Sprintf("Bearer %s", token)
		repositoryRequest.Header.Add("Authorization", token)
		PRsRequest.Header.Add("Authorization", token)
		issuesRequest.Header.Add("Authorization", token)
		CommitsRequest.Header.Add("Authorization", token)
	}
	var repositoryResponse githubRepositoryResponseJson
	var detailsErr error
	var PRsResponse githubTicketResponseJson
	var PRsErr error
	var issuesResponse githubTicketResponseJson
	var issuesErr error
	var commitsResponse []gitHubCommitResponseJson
	var CommitsErr error
	var wg sync.WaitGroup
	wg.Add(1)
	go (func() {
		defer wg.Done()
		repositoryResponse, detailsErr = decodeJsonFromRequest[githubRepositoryResponseJson](defaultHTTPClient, repositoryRequest)
	})()
	if maxPRs > 0 {
		wg.Add(1)
		go (func() {
			defer wg.Done()
			PRsResponse, PRsErr = decodeJsonFromRequest[githubTicketResponseJson](defaultHTTPClient, PRsRequest)
		})()
	}
	if maxIssues > 0 {
		wg.Add(1)
		go (func() {
			defer wg.Done()
			issuesResponse, issuesErr = decodeJsonFromRequest[githubTicketResponseJson](defaultHTTPClient, issuesRequest)
		})()
	}
	if maxCommits > 0 {
		wg.Add(1)
		go (func() {
			defer wg.Done()
			commitsResponse, CommitsErr = decodeJsonFromRequest[[]gitHubCommitResponseJson](defaultHTTPClient, CommitsRequest)
		})()
	}
	wg.Wait()
	if detailsErr != nil {
		return repository{}, fmt.Errorf("%w: could not get repository details: %s", errNoContent, detailsErr)
	}
	details := repository{
		Name:         repositoryResponse.Name,
		Stars:        repositoryResponse.Stars,
		Forks:        repositoryResponse.Forks,
		PullRequests: make([]githubTicket, 0, len(PRsResponse.Tickets)),
		Issues:       make([]githubTicket, 0, len(issuesResponse.Tickets)),
		Commits:      make([]githubCommitDetails, 0, len(commitsResponse)),
	}
	err = nil
	if maxPRs > 0 {
		if PRsErr != nil {
			err = fmt.Errorf("%w: could not get PRs: %s", errPartialContent, PRsErr)
		} else {
			details.OpenPullRequests = PRsResponse.Count
			for i := range PRsResponse.Tickets {
				details.PullRequests = append(details.PullRequests, githubTicket{
					Number:    PRsResponse.Tickets[i].Number,
					CreatedAt: parseRFC3339Time(PRsResponse.Tickets[i].CreatedAt),
					Title:     PRsResponse.Tickets[i].Title,
				})
			}
		}
	}
	if maxIssues > 0 {
		if issuesErr != nil {
			// TODO: fix, overwriting the previous error
			err = fmt.Errorf("%w: could not get issues: %s", errPartialContent, issuesErr)
		} else {
			details.OpenIssues = issuesResponse.Count
			for i := range issuesResponse.Tickets {
				details.Issues = append(details.Issues, githubTicket{
					Number:    issuesResponse.Tickets[i].Number,
					CreatedAt: parseRFC3339Time(issuesResponse.Tickets[i].CreatedAt),
					Title:     issuesResponse.Tickets[i].Title,
				})
			}
		}
	}
	if maxCommits > 0 {
		if CommitsErr != nil {
			err = fmt.Errorf("%w: could not get commits: %s", errPartialContent, CommitsErr)
		} else {
			for i := range commitsResponse {
				details.Commits = append(details.Commits, githubCommitDetails{
					Sha:       commitsResponse[i].Sha,
					Author:    commitsResponse[i].Commit.Author.Name,
					CreatedAt: parseRFC3339Time(commitsResponse[i].Commit.Author.Date),
					Message:   strings.SplitN(commitsResponse[i].Commit.Message, "\n\n", 2)[0],
				})
			}
		}
	}
	return details, err
}
</file>

<file path="internal/glance/widget-shared.go">
package glance
import (
	"math"
	"sort"
	"time"
)
const twitchGqlEndpoint = "https://gql.twitch.tv/gql"
const twitchGqlClientId = "kimne78kx3ncx6brgo4mv6wki5h1ko"
var forumPostsTemplate = mustParseTemplate("forum-posts.html", "widget-base.html")
type forumPost struct {
	Title           string
	DiscussionUrl   string
	TargetUrl       string
	TargetUrlDomain string
	ThumbnailUrl    string
	CommentCount    int
	Score           int
	Engagement      float64
	TimePosted      time.Time
	Tags            []string
	IsCrosspost     bool
}
type forumPostList []forumPost
const depreciatePostsOlderThanHours = 7
const maxDepreciation = 0.9
const maxDepreciationAfterHours = 24
func (p forumPostList) calculateEngagement() {
	var totalComments int
	var totalScore int
	for i := range p {
		totalComments += p[i].CommentCount
		totalScore += p[i].Score
	}
	numberOfPosts := float64(len(p))
	averageComments := float64(totalComments) / numberOfPosts
	averageScore := float64(totalScore) / numberOfPosts
	for i := range p {
		p[i].Engagement = (float64(p[i].CommentCount)/averageComments + float64(p[i].Score)/averageScore) / 2
		elapsed := time.Since(p[i].TimePosted)
		if elapsed < time.Hour*depreciatePostsOlderThanHours {
			continue
		}
		p[i].Engagement *= 1.0 - (math.Max(elapsed.Hours()-depreciatePostsOlderThanHours, maxDepreciationAfterHours)/maxDepreciationAfterHours)*maxDepreciation
	}
}
func (p forumPostList) sortByEngagement() {
	sort.Slice(p, func(i, j int) bool {
		return p[i].Engagement > p[j].Engagement
	})
}
</file>

<file path="internal/glance/widget-split-column.go">
package glance
import (
	"context"
	"html/template"
	"time"
)
var splitColumnWidgetTemplate = mustParseTemplate("split-column.html", "widget-base.html")
type splitColumnWidget struct {
	widgetBase          `yaml:",inline"`
	containerWidgetBase `yaml:",inline"`
	MaxColumns          int `yaml:"max-columns"`
}
func (widget *splitColumnWidget) initialize() error {
	widget.withError(nil).withTitle("Split Column").setHideHeader(true)
	if err := widget.containerWidgetBase._initializeWidgets(); err != nil {
		return err
	}
	if widget.MaxColumns < 2 {
		widget.MaxColumns = 2
	}
	return nil
}
func (widget *splitColumnWidget) update(ctx context.Context) {
	widget.containerWidgetBase._update(ctx)
}
func (widget *splitColumnWidget) setProviders(providers *widgetProviders) {
	widget.containerWidgetBase._setProviders(providers)
}
func (widget *splitColumnWidget) requiresUpdate(now *time.Time) bool {
	return widget.containerWidgetBase._requiresUpdate(now)
}
func (widget *splitColumnWidget) Render() template.HTML {
	return widget.renderTemplate(widget, splitColumnWidgetTemplate)
}
</file>

<file path="internal/glance/widget-twitch-top-games.go">
package glance
import (
	"context"
	"errors"
	"fmt"
	"html/template"
	"net/http"
	"slices"
	"strings"
	"time"
)
var twitchGamesWidgetTemplate = mustParseTemplate("twitch-games-list.html", "widget-base.html")
type twitchGamesWidget struct {
	widgetBase    `yaml:",inline"`
	Categories    []twitchCategory `yaml:"-"`
	Exclude       []string         `yaml:"exclude"`
	Limit         int              `yaml:"limit"`
	CollapseAfter int              `yaml:"collapse-after"`
}
func (widget *twitchGamesWidget) initialize() error {
	widget.
		withTitle("Top games on Twitch").
		withTitleURL("https://www.twitch.tv/directory?sort=VIEWER_COUNT").
		withCacheDuration(time.Minute * 10)
	if widget.Limit <= 0 {
		widget.Limit = 10
	}
	if widget.CollapseAfter == 0 || widget.CollapseAfter < -1 {
		widget.CollapseAfter = 5
	}
	return nil
}
func (widget *twitchGamesWidget) update(ctx context.Context) {
	categories, err := fetchTopGamesFromTwitch(widget.Exclude, widget.Limit)
	if !widget.canContinueUpdateAfterHandlingErr(err) {
		return
	}
	widget.Categories = categories
}
func (widget *twitchGamesWidget) Render() template.HTML {
	return widget.renderTemplate(widget, twitchGamesWidgetTemplate)
}
type twitchCategory struct {
	Slug         string `json:"slug"`
	Name         string `json:"name"`
	AvatarUrl    string `json:"avatarURL"`
	ViewersCount int    `json:"viewersCount"`
	Tags         []struct {
		Name string `json:"tagName"`
	} `json:"tags"`
	GameReleaseDate string `json:"originalReleaseDate"`
	IsNew           bool   `json:"-"`
}
type twitchDirectoriesOperationResponse struct {
	Data struct {
		DirectoriesWithTags struct {
			Edges []struct {
				Node twitchCategory `json:"node"`
			} `json:"edges"`
		} `json:"directoriesWithTags"`
	} `json:"data"`
}
const twitchDirectoriesOperationRequestBody = `[
{"operationName": "BrowsePage_AllDirectories","variables": {"limit": %d,"options": {"sort": "VIEWER_COUNT","tags": []}},"extensions": {"persistedQuery": {"version": 1,"sha256Hash": "2f67f71ba89f3c0ed26a141ec00da1defecb2303595f5cda4298169549783d9e"}}}
]`
func fetchTopGamesFromTwitch(exclude []string, limit int) ([]twitchCategory, error) {
	reader := strings.NewReader(fmt.Sprintf(twitchDirectoriesOperationRequestBody, len(exclude)+limit))
	request, _ := http.NewRequest("POST", twitchGqlEndpoint, reader)
	request.Header.Add("Client-ID", twitchGqlClientId)
	response, err := decodeJsonFromRequest[[]twitchDirectoriesOperationResponse](defaultHTTPClient, request)
	if err != nil {
		return nil, err
	}
	if len(response) == 0 {
		return nil, errors.New("no categories could be retrieved")
	}
	edges := (response)[0].Data.DirectoriesWithTags.Edges
	categories := make([]twitchCategory, 0, len(edges))
	for i := range edges {
		if slices.Contains(exclude, edges[i].Node.Slug) {
			continue
		}
		category := &edges[i].Node
		category.AvatarUrl = strings.Replace(category.AvatarUrl, "285x380", "144x192", 1)
		if len(category.Tags) > 2 {
			category.Tags = category.Tags[:2]
		}
		gameReleasedDate, err := time.Parse("2006-01-02T15:04:05Z", category.GameReleaseDate)
		if err == nil {
			if time.Since(gameReleasedDate) < 14*24*time.Hour {
				category.IsNew = true
			}
		}
		categories = append(categories, *category)
	}
	if len(categories) > limit {
		categories = categories[:limit]
	}
	return categories, nil
}
</file>

<file path=".github/FUNDING.yml">
github: [glanceapp]
patreon: glanceapp
</file>

<file path=".github/ISSUE_TEMPLATE/bug_report.yml">
name: Bug report
description: Let us know if something isn't working as expected
labels: ["bug report"]
body:
  - type: markdown
    attributes:
      value: |
        > [!NOTE]
        >
        > Do not prefix your title with "[BUG]", "[Bug report]", etc., a label will be added automatically.
        If you're unsure whether you're experiencing a bug or not, consider using the [Discussions](https://github.com/glanceapp/glance/discussions) or [Discord](https://discord.com/invite/7KQ7Xa9kJd) to ask for help.
        Please include only the information you think is relevant to the bug:
        * How did you install Glance? (Docker container, manual binary install, etc)
        * Which version of Glance are you using?
        * Include the relevant parts of your `glance.yml` if applicable (widget, data source, properties used, etc)
        * Include any relevant logs or screenshots if applicable
        * Is the issue specific to a certain browser or OS?
        * Steps to reliably reproduce the issue
        * Are you hosting Glance on a VPS?
        * Anything else you think might be relevant
        **No need to copy the above list into your description, it's just a guide to help you provide the most useful information.**
  - type: textarea
    id: description
    validations:
      required: true
    attributes:
      label: Description
  - type: markdown
    attributes:
      value: |
        Thank you for taking the time to submit a bug report.
</file>

<file path=".github/ISSUE_TEMPLATE/config.yml">
blank_issues_enabled: false
contact_links:
  - name: Discussions
    url: https://github.com/glanceapp/glance/discussions
    about: For help, feedback, guides, resources and more
  - name: Discord
    url: https://discord.com/invite/7KQ7Xa9kJd
    about: Much like the discussions but more chatty
</file>

<file path=".github/ISSUE_TEMPLATE/feature_request.yml">
name: Feature request
description: Share your ideas for new features or improvements
labels: ["feature request"]
body:
  - type: markdown
    attributes:
      value: |
        > [!NOTE]
        >
        > Do not prefix your title with "[REQUEST]", "[Feature request]", etc., a label will be added automatically.
        Please provide a detailed description of what the feature would do and what it would look like:
        * What problem would this feature solve?
        * Are there any potential downsides to this feature?
        * If applicable, what would the configuration for this feature look like?
        * Are there any existing examples of this feature in other software?
        * If applicable, include any external documentation required to implement this feature
        * Anything else you think might be relevant
        **No need to copy the above list into your description, it's just a guide to help you provide the most useful information.**
  - type: textarea
    id: description
    validations:
      required: true
    attributes:
      label: Description
  - type: markdown
    attributes:
      value: |
        Thank you for taking the time to submit your idea.
</file>

<file path="internal/glance/auth_test.go">
package glance
import (
	"bytes"
	"encoding/base64"
	"testing"
	"time"
)
func TestAuthTokenGenerationAndVerification(t *testing.T) {
	secret, err := makeAuthSecretKey(AUTH_SECRET_KEY_LENGTH)
	if err != nil {
		t.Fatalf("Failed to generate secret key: %v", err)
	}
	secretBytes, err := base64.StdEncoding.DecodeString(secret)
	if err != nil {
		t.Fatalf("Failed to decode secret key: %v", err)
	}
	if len(secretBytes) != AUTH_SECRET_KEY_LENGTH {
		t.Fatalf("Secret key length is not %d bytes", AUTH_SECRET_KEY_LENGTH)
	}
	now := time.Now()
	username := "admin"
	token, err := generateSessionToken(username, secretBytes, now)
	if err != nil {
		t.Fatalf("Failed to generate session token: %v", err)
	}
	usernameHashBytes, shouldRegen, err := verifySessionToken(token, secretBytes, now)
	if err != nil {
		t.Fatalf("Failed to verify session token: %v", err)
	}
	if shouldRegen {
		t.Fatal("Token should not need to be regenerated immediately after generation")
	}
	computedUsernameHash, err := computeUsernameHash(username, secretBytes)
	if err != nil {
		t.Fatalf("Failed to compute username hash: %v", err)
	}
	if !bytes.Equal(usernameHashBytes, computedUsernameHash) {
		t.Fatal("Username hash does not match the expected value")
	}
	// Test token regeneration
	timeRightAfterRegenPeriod := now.Add(AUTH_TOKEN_VALID_PERIOD - AUTH_TOKEN_REGEN_BEFORE + 2*time.Second)
	_, shouldRegen, err = verifySessionToken(token, secretBytes, timeRightAfterRegenPeriod)
	if err != nil {
		t.Fatalf("Token verification should not fail during regeneration period, err: %v", err)
	}
	if !shouldRegen {
		t.Fatal("Token should have been marked for regeneration")
	}
	// Test token expiration
	_, _, err = verifySessionToken(token, secretBytes, now.Add(AUTH_TOKEN_VALID_PERIOD+2*time.Second))
	if err == nil {
		t.Fatal("Expected token verification to fail after token expiration")
	}
	// Test tampered token
	decodedToken, err := base64.StdEncoding.DecodeString(token)
	if err != nil {
		t.Fatalf("Failed to decode token: %v", err)
	}
	// If any of the bytes are off by 1, the token should be considered invalid
	for i := range len(decodedToken) {
		tampered := make([]byte, len(decodedToken))
		copy(tampered, decodedToken)
		tampered[i] += 1
		_, _, err = verifySessionToken(base64.StdEncoding.EncodeToString(tampered), secretBytes, now)
		if err == nil {
			t.Fatalf("Expected token verification to fail for tampered token at index %d", i)
		}
	}
}
</file>

<file path="internal/glance/auth.go">
package glance
import (
	"bytes"
	"crypto/hmac"
	"crypto/rand"
	"crypto/sha256"
	"encoding/base64"
	"encoding/binary"
	"encoding/json"
	"fmt"
	"io"
	"log"
	mathrand "math/rand/v2"
	"net/http"
	"strconv"
	"strings"
	"time"
	"golang.org/x/crypto/bcrypt"
)
const AUTH_SESSION_COOKIE_NAME = "session_token"
const AUTH_RATE_LIMIT_WINDOW = 5 * time.Minute
const AUTH_RATE_LIMIT_MAX_ATTEMPTS = 5
const AUTH_TOKEN_SECRET_LENGTH = 32
const AUTH_USERNAME_HASH_LENGTH = 32
const AUTH_SECRET_KEY_LENGTH = AUTH_TOKEN_SECRET_LENGTH + AUTH_USERNAME_HASH_LENGTH
const AUTH_TIMESTAMP_LENGTH = 4 // uint32
const AUTH_TOKEN_DATA_LENGTH = AUTH_USERNAME_HASH_LENGTH + AUTH_TIMESTAMP_LENGTH
// How long the token will be valid for
const AUTH_TOKEN_VALID_PERIOD = 14 * 24 * time.Hour // 14 days
// How long the token has left before it should be regenerated
const AUTH_TOKEN_REGEN_BEFORE = 7 * 24 * time.Hour // 7 days
var loginPageTemplate = mustParseTemplate("login.html", "document.html", "footer.html")
type doWhenUnauthorized int
const (
	redirectToLogin doWhenUnauthorized = iota
	showUnauthorizedJSON
)
type failedAuthAttempt struct {
	attempts int
	first    time.Time
}
func generateSessionToken(username string, secret []byte, now time.Time) (string, error) {
	if len(secret) != AUTH_SECRET_KEY_LENGTH {
		return "", fmt.Errorf("secret key length is not %d bytes", AUTH_SECRET_KEY_LENGTH)
	}
	usernameHash, err := computeUsernameHash(username, secret)
	if err != nil {
		return "", err
	}
	data := make([]byte, AUTH_TOKEN_DATA_LENGTH)
	copy(data, usernameHash)
	expires := now.Add(AUTH_TOKEN_VALID_PERIOD).Unix()
	binary.LittleEndian.PutUint32(data[AUTH_USERNAME_HASH_LENGTH:], uint32(expires))
	h := hmac.New(sha256.New, secret[0:AUTH_TOKEN_SECRET_LENGTH])
	h.Write(data)
	signature := h.Sum(nil)
	encodedToken := base64.StdEncoding.EncodeToString(append(data, signature...))
	// encodedToken ends up being (hashed username + expiration timestamp + signature) encoded as base64
	return encodedToken, nil
}
func computeUsernameHash(username string, secret []byte) ([]byte, error) {
	if len(secret) != AUTH_SECRET_KEY_LENGTH {
		return nil, fmt.Errorf("secret key length is not %d bytes", AUTH_SECRET_KEY_LENGTH)
	}
	h := hmac.New(sha256.New, secret[AUTH_TOKEN_SECRET_LENGTH:])
	h.Write([]byte(username))
	return h.Sum(nil), nil
}
func verifySessionToken(token string, secretBytes []byte, now time.Time) ([]byte, bool, error) {
	tokenBytes, err := base64.StdEncoding.DecodeString(token)
	if err != nil {
		return nil, false, err
	}
	if len(tokenBytes) != AUTH_TOKEN_DATA_LENGTH+32 {
		return nil, false, fmt.Errorf("token length is invalid")
	}
	if len(secretBytes) != AUTH_SECRET_KEY_LENGTH {
		return nil, false, fmt.Errorf("secret key length is not %d bytes", AUTH_SECRET_KEY_LENGTH)
	}
	usernameHashBytes := tokenBytes[0:AUTH_USERNAME_HASH_LENGTH]
	timestampBytes := tokenBytes[AUTH_USERNAME_HASH_LENGTH : AUTH_USERNAME_HASH_LENGTH+AUTH_TIMESTAMP_LENGTH]
	providedSignatureBytes := tokenBytes[AUTH_TOKEN_DATA_LENGTH:]
	h := hmac.New(sha256.New, secretBytes[0:32])
	h.Write(tokenBytes[0:AUTH_TOKEN_DATA_LENGTH])
	expectedSignatureBytes := h.Sum(nil)
	if !hmac.Equal(expectedSignatureBytes, providedSignatureBytes) {
		return nil, false, fmt.Errorf("signature does not match")
	}
	expiresTimestamp := int64(binary.LittleEndian.Uint32(timestampBytes))
	if now.Unix() > expiresTimestamp {
		return nil, false, fmt.Errorf("token has expired")
	}
	return usernameHashBytes,
		// True if the token should be regenerated
		time.Unix(expiresTimestamp, 0).Add(-AUTH_TOKEN_REGEN_BEFORE).Before(now),
		nil
}
func makeAuthSecretKey(length int) (string, error) {
	key := make([]byte, length)
	_, err := rand.Read(key)
	if err != nil {
		return "", err
	}
	return base64.StdEncoding.EncodeToString(key), nil
}
func (a *application) handleAuthenticationAttempt(w http.ResponseWriter, r *http.Request) {
	if r.Header.Get("Content-Type") != "application/json" {
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	waitOnFailure := 1*time.Second - time.Duration(mathrand.IntN(500))*time.Millisecond
	ip := a.addressOfRequest(r)
	a.authAttemptsMu.Lock()
	exceededRateLimit, retryAfter := func() (bool, int) {
		attempt, exists := a.failedAuthAttempts[ip]
		if !exists {
			a.failedAuthAttempts[ip] = &failedAuthAttempt{
				attempts: 1,
				first:    time.Now(),
			}
			return false, 0
		}
		elapsed := time.Since(attempt.first)
		if elapsed < AUTH_RATE_LIMIT_WINDOW && attempt.attempts >= AUTH_RATE_LIMIT_MAX_ATTEMPTS {
			return true, max(1, int(AUTH_RATE_LIMIT_WINDOW.Seconds()-elapsed.Seconds()))
		}
		attempt.attempts++
		return false, 0
	}()
	if exceededRateLimit {
		a.authAttemptsMu.Unlock()
		time.Sleep(waitOnFailure)
		w.Header().Set("Retry-After", strconv.Itoa(retryAfter))
		w.WriteHeader(http.StatusTooManyRequests)
		return
	} else {
		// Clean up old failed attempts
		for ipOfAttempt := range a.failedAuthAttempts {
			if time.Since(a.failedAuthAttempts[ipOfAttempt].first) > AUTH_RATE_LIMIT_WINDOW {
				delete(a.failedAuthAttempts, ipOfAttempt)
			}
		}
		a.authAttemptsMu.Unlock()
	}
	body, err := io.ReadAll(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	var creds struct {
		Username string `json:"username"`
		Password string `json:"password"`
	}
	err = json.Unmarshal(body, &creds)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	logAuthFailure := func() {
		log.Printf(
			"Failed login attempt for user '%s' from %s",
			creds.Username, ip,
		)
	}
	if len(creds.Username) == 0 || len(creds.Password) == 0 {
		time.Sleep(waitOnFailure)
		w.WriteHeader(http.StatusUnauthorized)
		return
	}
	if len(creds.Username) > 50 || len(creds.Password) > 100 {
		logAuthFailure()
		time.Sleep(waitOnFailure)
		w.WriteHeader(http.StatusUnauthorized)
		return
	}
	u, exists := a.Config.Auth.Users[creds.Username]
	if !exists {
		logAuthFailure()
		time.Sleep(waitOnFailure)
		w.WriteHeader(http.StatusUnauthorized)
		return
	}
	if err := bcrypt.CompareHashAndPassword(u.PasswordHash, []byte(creds.Password)); err != nil {
		logAuthFailure()
		time.Sleep(waitOnFailure)
		w.WriteHeader(http.StatusUnauthorized)
		return
	}
	token, err := generateSessionToken(creds.Username, a.authSecretKey, time.Now())
	if err != nil {
		log.Printf("Could not compute session token during login attempt: %v", err)
		time.Sleep(waitOnFailure)
		w.WriteHeader(http.StatusUnauthorized)
		return
	}
	a.setAuthSessionCookie(w, r, token, time.Now().Add(AUTH_TOKEN_VALID_PERIOD))
	a.authAttemptsMu.Lock()
	delete(a.failedAuthAttempts, ip)
	a.authAttemptsMu.Unlock()
	w.WriteHeader(http.StatusOK)
}
func (a *application) isAuthorized(w http.ResponseWriter, r *http.Request) bool {
	if !a.RequiresAuth {
		return true
	}
	token, err := r.Cookie(AUTH_SESSION_COOKIE_NAME)
	if err != nil || token.Value == "" {
		return false
	}
	usernameHash, shouldRegenerate, err := verifySessionToken(token.Value, a.authSecretKey, time.Now())
	if err != nil {
		return false
	}
	username, exists := a.usernameHashToUsername[string(usernameHash)]
	if !exists {
		return false
	}
	_, exists = a.Config.Auth.Users[username]
	if !exists {
		return false
	}
	if shouldRegenerate {
		newToken, err := generateSessionToken(username, a.authSecretKey, time.Now())
		if err != nil {
			log.Printf("Could not compute session token during regeneration: %v", err)
			return false
		}
		a.setAuthSessionCookie(w, r, newToken, time.Now().Add(AUTH_TOKEN_VALID_PERIOD))
	}
	return true
}
// Handles sending the appropriate response for an unauthorized request and returns true if the request was unauthorized
func (a *application) handleUnauthorizedResponse(w http.ResponseWriter, r *http.Request, fallback doWhenUnauthorized) bool {
	if a.isAuthorized(w, r) {
		return false
	}
	switch fallback {
	case redirectToLogin:
		http.Redirect(w, r, a.Config.Server.BaseURL+"/login", http.StatusSeeOther)
	case showUnauthorizedJSON:
		w.WriteHeader(http.StatusUnauthorized)
		w.Write([]byte(`{"error": "Unauthorized"}`))
	}
	return true
}
// Maybe this should be a POST request instead?
func (a *application) handleLogoutRequest(w http.ResponseWriter, r *http.Request) {
	a.setAuthSessionCookie(w, r, "", time.Now().Add(-1*time.Hour))
	http.Redirect(w, r, a.Config.Server.BaseURL+"/login", http.StatusSeeOther)
}
func (a *application) setAuthSessionCookie(w http.ResponseWriter, r *http.Request, token string, expires time.Time) {
	http.SetCookie(w, &http.Cookie{
		Name:     AUTH_SESSION_COOKIE_NAME,
		Value:    token,
		Expires:  expires,
		Secure:   strings.ToLower(r.Header.Get("X-Forwarded-Proto")) == "https",
		Path:     a.Config.Server.BaseURL + "/",
		SameSite: http.SameSiteLaxMode,
		HttpOnly: true,
	})
}
func (a *application) handleLoginPageRequest(w http.ResponseWriter, r *http.Request) {
	if a.isAuthorized(w, r) {
		http.Redirect(w, r, a.Config.Server.BaseURL+"/", http.StatusSeeOther)
		return
	}
	data := &templateData{
		App: a,
	}
	a.populateTemplateRequestData(&data.Request, r)
	var responseBytes bytes.Buffer
	err := loginPageTemplate.Execute(&responseBytes, data)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		w.Write([]byte(err.Error()))
		return
	}
	w.Write(responseBytes.Bytes())
}
</file>

<file path="internal/glance/hub.go">
package glance
import (
	"log"
	"net/http"
	"sync"
	"time"
	"github.com/gorilla/websocket"
)
var upgrader = websocket.Upgrader{
	ReadBufferSize:  1024,
	WriteBufferSize: 1024,
	CheckOrigin: func(r *http.Request) bool {
		return true // Allow all for personal dashboard
	},
}
type client struct {
	hub  *hub
	conn *websocket.Conn
	send chan []byte
}
func (c *client) writePump() {
	ticker := time.NewTicker(54 * time.Second)
	defer func() {
		ticker.Stop()
		c.conn.Close()
	}()
	for {
		select {
		case message, ok := <-c.send:
			c.conn.SetWriteDeadline(time.Now().Add(10 * time.Second))
			if !ok {
				c.conn.WriteMessage(websocket.CloseMessage, []byte{})
				return
			}
			w, err := c.conn.NextWriter(websocket.TextMessage)
			if err != nil {
				return
			}
			w.Write(message)
			n := len(c.send)
			for i := 0; i < n; i++ {
				w.Write([]byte{'\n'})
				w.Write(<-c.send)
			}
			if err := w.Close(); err != nil {
				return
			}
		case <-ticker.C:
			c.conn.SetWriteDeadline(time.Now().Add(10 * time.Second))
			if err := c.conn.WriteMessage(websocket.PingMessage, nil); err != nil {
				return
			}
		}
	}
}
func (c *client) readPump() {
	defer func() {
		c.hub.unregister <- c
		c.conn.Close()
	}()
	c.conn.SetReadLimit(512)
	c.conn.SetReadDeadline(time.Now().Add(60 * time.Second))
	c.conn.SetPongHandler(func(string) error { c.conn.SetReadDeadline(time.Now().Add(60 * time.Second)); return nil })
	for {
		_, _, err := c.conn.ReadMessage()
		if err != nil {
			if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {
				log.Printf("error: %v", err)
			}
			break
		}
	}
}
type hub struct {
	clients    map[*client]bool
	broadcast  chan []byte
	register   chan *client
	unregister chan *client
	mu         sync.Mutex
}
func newHub() *hub {
	return &hub{
		broadcast:  make(chan []byte),
		register:   make(chan *client),
		unregister: make(chan *client),
		clients:    make(map[*client]bool),
	}
}
func (h *hub) run() {
	for {
		select {
		case client := <-h.register:
			h.mu.Lock()
			h.clients[client] = true
			h.mu.Unlock()
		case client := <-h.unregister:
			h.mu.Lock()
			if _, ok := h.clients[client]; ok {
				delete(h.clients, client)
				close(client.send)
			}
			h.mu.Unlock()
		case message := <-h.broadcast:
			h.mu.Lock()
			for client := range h.clients {
				select {
				case client.send <- message:
				default:
					close(client.send)
					delete(h.clients, client)
				}
			}
			h.mu.Unlock()
		}
	}
}
func (h *hub) broadcastHTML(html string) {
	h.broadcast <- []byte(html)
}
func (h *hub) close() {
	h.mu.Lock()
	defer h.mu.Unlock()
	for client := range h.clients {
		close(client.send)
		delete(h.clients, client)
	}
}
func (h *hub) handleWebSocket(w http.ResponseWriter, r *http.Request) {
	conn, err := upgrader.Upgrade(w, r, nil)
	if err != nil {
		log.Println(err)
		return
	}
	client := &client{hub: h, conn: conn, send: make(chan []byte, 256)}
	client.hub.register <- client
	go client.writePump()
	go client.readPump()
}
</file>

<file path="internal/glance/static/css/forum-posts.css">
.forum-post-list-thumbnail {
    flex-shrink: 0;
    width: 6rem;
    height: 4.1rem;
    border-radius: var(--border-radius);
    object-fit: cover;
    border: 1px solid var(--color-separator);
    margin-top: 0.1rem;
}
.forum-post-tags-container {
    transform: translateY(-0.15rem);
}
@container widget (max-width: 550px) {
    .forum-post-autohide {
        display: none;
    }
}
</file>

<file path="internal/glance/static/css/login.css">
.login-bounds {
    max-width: 500px;
    padding: 0 2rem;
}
.form-label {
    text-transform: uppercase;
    margin-bottom: 0.5rem;
}
.form-input {
    transition: border-color .2s;
}
.form-input input {
    border: 0;
    background: none;
    width: 100%;
    height: 5.2rem;
    font: inherit;
    outline: none;
    color: var(--color-text-highlight);
}
.form-input-icon {
    width: 2rem;
    height: 2rem;
    margin-top: -0.1rem;
    opacity: 0.5;
}
.form-input input[type="password"] {
    letter-spacing: 0.3rem;
    font-size: 0.9em;
}
.form-input input[type="password"]::placeholder {
    letter-spacing: 0;
    font-size: var(--font-size-base);
}
.form-input:hover {
    border-color: var(--color-progress-border);
}
.form-input:focus-within {
    border-color: var(--color-primary);
    transition-duration: .7s;
}
.login-button {
    width: 100%;
    display: block;
    padding: 1rem;
    background: none;
    border: 1px solid var(--color-text-subdue);
    border-radius: var(--border-radius);
    color: var(--color-text-paragraph);
    cursor: pointer;
    font: inherit;
    font-size: var(--font-size-h4);
    display: flex;
    gap: .5rem;
    align-items: center;
    justify-content: center;
    transition: all .3s, margin-top 0s;
    margin-top: 3rem;
}
.login-button:not(:disabled) {
    box-shadow: 0 0 10px 1px var(--color-separator);
}
.login-error-message:not(:empty) + .login-button {
    margin-top: 2rem;
}
.login-button:focus, .login-button:hover {
    outline: none;
    border-color: var(--color-primary);
    color: var(--color-primary);
}
.login-button:disabled {
    border-color: var(--color-separator);
    color: var(--color-text-subdue);
    cursor: not-allowed;
}
.login-button svg {
    width: 1.7rem;
    height: 1.7rem;
    transition: transform .2s;
}
.login-button:not(:disabled):hover svg, .login-button:not(:disabled):focus svg {
    transform: translateX(.5rem);
}
.animate-entrance {
    animation: fieldReveal 0.7s backwards;
    animation-timing-function: cubic-bezier(0.22, 1, 0.36, 1);
}
.animate-entrance:nth-child(1) { animation-delay: .1s; }
.animate-entrance:nth-child(2) { animation-delay: .2s; }
.animate-entrance:nth-child(4) { animation-delay: .3s; }
@keyframes fieldReveal {
    from {
        opacity: 0.0001;
        transform: translateY(4rem);
    }
}
.login-error-message {
    color: var(--color-negative);
    font-size: var(--font-size-base);
    padding: 1.3rem calc(var(--widget-content-horizontal-padding) + 1px);
    position: relative;
    margin-top: 2rem;
    animation: errorMessageEntrance 0.4s backwards cubic-bezier(0.34, 1.56, 0.64, 1);
}
@keyframes errorMessageEntrance {
    from {
        opacity: 0;
        transform: scale(1.1);
    }
}
.login-error-message:empty {
    display: none;
}
.login-error-message::before {
    content: "";
    position: absolute;
    inset: 0;
    border-radius: var(--border-radius);
    background: var(--color-negative);
    opacity: 0.05;
    z-index: -1;
}
.footer {
    animation-delay: .4s;
    animation-duration: 1s;
}
.toggle-password-visibility {
    background: none;
    border: none;
    cursor: pointer;
}
</file>

<file path="internal/glance/static/css/main.css">
@font-face {
    font-family: 'JetBrains Mono';
    font-style: normal;
    font-weight: 400;
    font-display: swap;
    src: url('../fonts/JetBrainsMono-Regular.woff2') format('woff2');
}
:root {
    font-size: 10px;
    --scheme: ;
    --bgh: 240;
    --bgs: 8%;
    --bgl: 9%;
    --bghs: var(--bgh), var(--bgs);
    --cm: 1;
    --tsm: 1;
    --widget-gap: 23px;
    --widget-content-vertical-padding: 15px;
    --widget-content-horizontal-padding: 17px;
    --widget-content-padding: var(--widget-content-vertical-padding) var(--widget-content-horizontal-padding);
    --content-bounds-padding: 15px;
    --border-radius: 5px;
    --mobile-navigation-height: 50px;
    --color-primary: hsl(43, 50%, 70%);
    --color-positive: var(--color-primary);
    --color-negative: hsl(0, 70%, 70%);
    --color-background: hsl(var(--bghs), var(--bgl));
    --color-widget-background-hsl-values: var(--bghs), calc(var(--bgl) + 1%);
    --color-widget-background: hsl(var(--color-widget-background-hsl-values));
    --color-separator: hsl(var(--bghs), calc(var(--scheme) ((var(--scheme) var(--bgl)) + 4% * var(--cm))));
    --color-widget-content-border: hsl(var(--bghs), calc(var(--scheme) (var(--scheme) var(--bgl) + 4%)));
    --color-widget-background-highlight: hsl(var(--bghs), calc(var(--scheme) (var(--scheme) var(--bgl) + 4%)));
    --color-popover-background: hsl(var(--bgh), calc(var(--bgs) + 3%), calc(var(--bgl) + 3%));
    --color-popover-border: hsl(var(--bghs), calc(var(--scheme) (var(--scheme) var(--bgl) + 12%)));
    --color-progress-border: hsl(var(--bghs), calc(var(--scheme) ((var(--scheme) var(--bgl)) + 10% * var(--cm))));
    --color-progress-value: hsl(var(--bgh), calc(var(--bgs) * var(--tsm)), calc(var(--scheme) ((var(--scheme) var(--bgl)) + 26% * var(--cm))));
    --color-vertical-progress-value: hsl(var(--bgh), calc(var(--bgs) * var(--tsm)), calc(var(--scheme) ((var(--scheme) var(--bgl)) + 28% * var(--cm))));
    --color-graph-gridlines: hsl(var(--bghs), calc(var(--scheme) ((var(--scheme) var(--bgl)) + 6% * var(--cm))));
    --ths: var(--bgh), calc(var(--bgs) * var(--tsm));
    --color-text-highlight: hsl(var(--ths), calc(var(--scheme) var(--cm) * 85%));
    --color-text-paragraph: hsl(var(--ths), calc(var(--scheme) var(--cm) * 73%));
    --color-text-base: hsl(var(--ths), calc(var(--scheme) var(--cm) * 58%));
    --color-text-base-muted: hsl(var(--ths), calc(var(--scheme) var(--cm) * 52%));
    --color-text-subdue: hsl(var(--ths), calc(var(--scheme) var(--cm) * 35%));
    --font-size-h1: 1.7rem;
    --font-size-h2: 1.6rem;
    --font-size-h3: 1.5rem;
    --font-size-h4: 1.4rem;
    --font-size-base: 1.3rem;
    --font-size-h5: 1.2rem;
    --font-size-h6: 1.1rem;
}
/* Do not change the order of the below imports unless you know what you're doing */
@import "site.css";
@import "widgets.css";
@import "popover.css";
@import "utils.css";
@import "mobile.css";
</file>

<file path="internal/glance/static/css/popover.css">
.popover-container, [data-popover-html] {
    display: none;
}
.popover-container {
    --triangle-size: 10px;
    --triangle-offset: 50%;
    --triangle-margin: calc(var(--triangle-size) + 3px);
    --entrance-y-offset: 8px;
    --entrance-direction: calc(var(--entrance-y-offset) * -1);
    z-index: 20;
    position: absolute;
    padding-top: var(--triangle-margin);
    padding-inline: var(--content-bounds-padding);
}
.popover-container.position-above {
    --entrance-direction: var(--entrance-y-offset);
    padding-top: 0;
    padding-bottom: var(--triangle-margin);
}
.popover-frame {
    --shadow-properties: 0 15px 20px -10px;
    --shadow-color: hsla(var(--bghs), calc(var(--bgl) * 0.2), 0.5);
    position: relative;
    padding: 10px;
    background: var(--color-popover-background);
    border: 1px solid var(--color-popover-border);
    border-radius: 5px;
    animation: popoverFrameEntrance 0.3s backwards cubic-bezier(0.16, 1, 0.3, 1);
    box-shadow: var(--shadow-properties) var(--shadow-color);
}
.popover-frame::before {
    content: '';
    position: absolute;
    width: var(--triangle-size);
    height: var(--triangle-size);
    transform: rotate(45deg);
    background-color: var(--color-popover-background);
    border-top-left-radius: 2px;
    border-left: 1px solid var(--color-popover-border);
    border-top: 1px solid var(--color-popover-border);
    left: calc(var(--triangle-offset) - (var(--triangle-size) / 2));
    top: calc(var(--triangle-size) / 2 * -1 - 1px);
}
.popover-container.position-above .popover-frame::before {
    transform: rotate(-135deg);
    top: auto;
    bottom: calc(var(--triangle-size) / 2 * -1 - 1px);
}
.popover-container.position-above .popover-frame {
    --shadow-properties: 0 10px 20px -10px;
}
@keyframes popoverFrameEntrance {
    from {
        opacity: 0;
        transform: translateY(var(--entrance-direction));
    }
}
</file>

<file path="internal/glance/static/css/widget-bookmarks.css">
.bookmarks-group {
    --bookmarks-group-color: var(--color-primary);
}
.bookmarks-group-title {
    color: var(--bookmarks-group-color);
}
.bookmarks-link:not(.bookmarks-link-no-arrow)::after {
    content: '↗' / "";
    margin-left: 0.5em;
    display: inline-block;
    position: relative;
    top: 0.15em;
    color: var(--bookmarks-group-color);
}
.bookmarks-icon-container {
    margin-block: 0.1rem;
    background-color: var(--color-widget-background-highlight);
    border-radius: var(--border-radius);
    padding: 0.5rem;
    opacity: 0.7;
    flex-shrink: 0;
}
.bookmarks-icon {
    width: 20px;
    height: 20px;
    opacity: 0.8;
}
</file>

<file path="internal/glance/static/css/widget-calendar.css">
.old-calendar-day {
    width: calc(100% / 7);
    text-align: center;
    padding: 0.6rem 0;
}
.old-calendar-day-today {
    border-radius: var(--border-radius);
    background-color: hsl(var(--bghs), calc(var(--scheme) (var(--scheme) (var(--bgl)) + 6%)));
    color: var(--color-text-highlight);
}
.calendar-dates {
    text-align: center;
    display: grid;
    grid-template-columns: repeat(7, 1fr);
    gap: 2px;
}
.calendar-date {
    padding: 0.4rem 0;
    color: var(--color-text-base);
    position: relative;
    border-radius: var(--border-radius);
    background: none;
    border: none;
    font: inherit;
}
.calendar-current-date {
    border-radius: var(--border-radius);
    background-color: var(--color-popover-border);
    color: var(--color-text-highlight);
}
.calendar-spillover-date {
    color: var(--color-text-subdue);
}
.calendar-header-button {
    position: relative;
    cursor: pointer;
    width: 2rem;
    height: 2rem;
    z-index: 1;
    background: none;
    border: none;
}
.calendar-header-button::before {
    content: '';
    position: absolute;
    inset: -0.2rem;
    border-radius: var(--border-radius);
    background-color: var(--color-text-subdue);
    opacity: 0;
    transition: opacity 0.2s;
    z-index: -1;
}
.calendar-header-button:hover::before {
    opacity: 0.4;
}
.calendar-undo-button {
    display: inline-block;
    vertical-align: text-top;
    width: 2rem;
    height: 2rem;
    margin-left: 0.7rem;
}
</file>

<file path="internal/glance/static/css/widget-clock.css">
.clock-time {
    min-width: 8ch;
}
.clock-time span {
    color: var(--color-text-highlight);
}
</file>

<file path="internal/glance/static/css/widget-dns-stats.css">
.dns-stats-totals {
    transition: opacity .3s;
    transition-delay: 50ms;
}
.dns-stats:has(.dns-stats-graph .popover-active) .dns-stats-totals {
    opacity: 0.1;
    transition-delay: 0s;
}
.dns-stats-graph {
    --graph-height: 70px;
    height: var(--graph-height);
    position: relative;
    margin-bottom: 2.5rem;
}
.dns-stats-graph-gridlines-container {
    position: absolute;
    inset: 0;
}
.dns-stats-graph-gridlines {
    height: 100%;
    width: 100%;
}
.dns-stats-graph-columns {
    display: flex;
    height: 100%;
}
.dns-stats-graph-column {
    display: flex;
    justify-content: flex-end;
    align-items: center;
    flex-direction: column;
    width: calc(100% / 8);
    position: relative;
}
.dns-stats-graph-column::before {
    content: '';
    position: absolute;
    inset: 1px 0;
    opacity: 0;
    background: var(--color-text-base);
    transition: opacity .2s;
}
.dns-stats-graph-column:hover::before {
    opacity: 0.05;
}
.dns-stats-graph-bar {
    width: 14px;
    height: calc((var(--bar-height) / 100) * var(--graph-height));
    border: 1px solid var(--color-progress-border);
    border-radius: var(--border-radius) var(--border-radius) 0 0;
    display: flex;
    background: var(--color-widget-background);
    padding: 2px 2px 0 2px;
    flex-direction: column;
    gap: 2px;
    transition: border-color .2s;
    min-height: 10px;
}
.dns-stats-graph-column.popover-active .dns-stats-graph-bar {
    border-color: var(--color-text-subdue);
    border-bottom-color: var(--color-progress-border);
}
.dns-stats-graph-bar > * {
    border-radius: 2px;
    background: var(--color-vertical-progress-value);
    min-height: 1px;
}
.dns-stats-graph-bar > .queries {
    flex-grow: 1;
}
.dns-stats-graph-bar > *:last-child {
    border-bottom-right-radius: 0;
    border-bottom-left-radius: 0;
}
.dns-stats-graph-bar > .blocked {
    background-color: var(--color-negative);
    flex-basis: calc(var(--percent) - 1px);
}
.dns-stats-graph-column:nth-child(even) .dns-stats-graph-time {
    opacity: 1;
    transform: translateY(0);
}
.dns-stats-graph-time, .dns-stats-graph-columns:hover .dns-stats-graph-time {
    position: absolute;
    font-size: var(--font-size-h6);
    inset-inline: 0;
    text-align: center;
    height: 2.5rem;
    line-height: 2.5rem;
    top: 100%;
    user-select: none;
    opacity: 0;
    transform: translateY(-0.5rem);
    transition: opacity .2s, transform .2s;
}
.dns-stats-graph-column:hover .dns-stats-graph-time {
    opacity: 1;
    transform: translateY(0);
}
.dns-stats-graph-columns:hover .dns-stats-graph-column:not(:hover) .dns-stats-graph-time {
    opacity: 0;
}
</file>

<file path="internal/glance/static/css/widget-docker-containers.css">
.docker-container-icon {
    display: block;
    filter: grayscale(0.4);
    object-fit: contain;
    aspect-ratio: 1 / 1;
    width: 2.7rem;
    opacity: 0.8;
    transition: filter 0.3s, opacity 0.3s;
}
.docker-container-icon.flat-icon {
    opacity: 0.7;
}
.docker-container:hover .docker-container-icon {
    opacity: 1;
}
.docker-container:hover .docker-container-icon:not(.flat-icon) {
    filter: grayscale(0);
}
.docker-container-status-icon {
    width: 2rem;
    height: 2rem;
}
</file>

<file path="internal/glance/static/css/widget-group.css">
.widget-group-header {
    overflow-x: auto;
    scrollbar-width: thin;
}
.widget-group-title {
    background: none;
    font: inherit;
    border: none;
    text-transform: uppercase;
    border-bottom: 1px dotted transparent;
    cursor: pointer;
    flex-shrink: 0;
    transition: color .3s, border-color .3s;
    color: var(--color-text-subdue);
    line-height: calc(1.6em - 1px);
}
.widget-group-title:hover:not(.widget-group-title-current) {
    color: var(--color-text-base);
}
.widget-group-title-current {
    border-bottom-color: var(--color-text-base-muted);
    color: var(--color-text-base);
}
.widget-group-content {
    animation: widgetGroupContentEntrance .3s cubic-bezier(0.25, 1, 0.5, 1) backwards;
}
.widget-group-content[data-direction="right"] {
    --direction: 5px;
}
.widget-group-content[data-direction="left"] {
    --direction: -5px;
}
@keyframes widgetGroupContentEntrance {
    from {
        opacity: 0;
        transform: translateX(var(--direction));
    }
}
.widget-group-content:not(.widget-group-content-current) {
    display: none;
}
</file>

<file path="internal/glance/static/css/widget-markets.css">
.market-chart {
    margin-left: auto;
    width: 6.5rem;
    flex-shrink: 0;
}
.market-chart svg {
    width: 100%;
}
.market-values {
    min-width: 8rem;
}
</file>

<file path="internal/glance/static/css/widget-monitor.css">
.monitor-site-icon {
    display: block;
    opacity: 0.8;
    filter: grayscale(0.4);
    object-fit: contain;
    aspect-ratio: 1 / 1;
    width: 3.2rem;
    position: relative;
    top: -0.1rem;
    transition: filter 0.3s, opacity 0.3s;
}
.monitor-site-icon.flat-icon {
    opacity: 0.7;
}
.monitor-site:hover .monitor-site-icon {
    opacity: 1;
}
.monitor-site:hover .monitor-site-icon:not(.flat-icon) {
    filter: grayscale(0);
}
.monitor-site-status-icon {
    flex-shrink: 0;
    margin-left: auto;
    width: 2rem;
    height: 2rem;
}
.monitor-site-status-icon-compact {
    width: 1.8rem;
    height: 1.8rem;
    flex-shrink: 0;
}
</file>

<file path="internal/glance/static/css/widget-reddit.css">
.reddit-card-thumbnail {
    width: 100%;
    height: 100%;
    object-fit: cover;
    object-position: 0% 20%;
    opacity: 0.15;
    filter: blur(1px);
}
.reddit-card-thumbnail-container {
    position: absolute;
    inset: 0;
    overflow: hidden;
    border-radius: var(--border-radius);
}
.reddit-card-thumbnail-container::after {
    content: '';
    position: absolute;
    inset: 0;
    background: linear-gradient(0deg, var(--color-widget-background) 10%, transparent);
}
</file>

<file path="internal/glance/static/css/widget-releases.css">
.release-source-icon {
    width: 16px;
    height: 16px;
    flex-shrink: 0;
    opacity: 0.4;
}
</file>

<file path="internal/glance/static/css/widget-rss.css">
.rss-card-image {
    height: var(--rss-thumbnail-height, 10rem);
    object-fit: cover;
    border-radius: var(--border-radius) var(--border-radius) 0 0;
}
.rss-card-2 {
    position: relative;
    height: var(--rss-card-height, 27rem);
    overflow: hidden;
}
.rss-card-2::before {
    content: '';
    position: absolute;
    inset: 0;
    pointer-events: none;
    background-image: linear-gradient(
        0deg,
        var(--color-widget-background),
        hsla(var(--color-widget-background-hsl-values), 0.8) 6rem, transparent 14rem
    );
    z-index: 2;
}
.rss-card-2-image {
    position: absolute;
    width: 100%;
    height: 100%;
    object-fit: cover;
    /* +1px is required to fix some weird graphical bug where the image overflows on the bottom in firefox */
    border-radius: calc(var(--border-radius) + 1px);
    opacity: 0.9;
    z-index: 1;
}
.rss-card-2-content {
    position: absolute;
    inset-inline: 0;
    bottom: var(--widget-content-vertical-padding);
    z-index: 3;
}
.rss-detailed-description {
    max-width: 55rem;
    color: var(--color-text-base-muted);
}
.rss-detailed-thumbnail {
    margin-top: 0.3rem;
}
.rss-detailed-thumbnail > * {
    aspect-ratio: 3 / 2;
    height: 8.7rem;
}
</file>

<file path="internal/glance/static/css/widget-search.css">
.search-icon {
    width: 2.3rem;
}
.search-icon-container {
    position: relative;
    flex-shrink: 0;
}
/* gives a wider hit area for the 3 people that will notice the animation : ) */
.search-icon-container::before {
    content: '';
    position: absolute;
    inset: -1rem;
}
.search-icon-container:hover > .search-icon {
    animation: searchIconHover 2.9s forwards;
}
@keyframes searchIconHover {
    0%, 39% { translate: 0 0; }
    20% { scale: 1.3; }
    40% { scale: 1; }
    50% { translate: -30% 30%; }
    70% { translate: 30% -30%; }
    90% { translate: -30% -30%; }
    100% { translate: 0 0; }
}
.search {
    transition: border-color .2s;
    position: relative;
}
.search:hover {
    border-color: var(--color-text-subdue);
}
.search:focus-within {
    border-color: var(--color-primary);
}
.search-input {
    border: 0;
    background: none;
    width: 100%;
    height: 6rem;
    font: inherit;
    outline: none;
    color: var(--color-text-highlight);
}
.search-input::placeholder {
    color: var(--color-text-base-muted);
    opacity: 1;
}
.search-bangs { display: none; }
.search-bang {
    border-radius: calc(var(--border-radius) * 2);
    background: var(--color-widget-background-highlight);
    padding: 0.3rem 1rem;
    flex-shrink: 0;
    font-size: var(--font-size-h5);
    animation: searchBangsEntrance .3s cubic-bezier(0.25, 1, 0.5, 1) backwards;
}
@keyframes searchBangsEntrance {
    0% {
        opacity: 0;
        transform: translateX(-10px);
    }
}
.search-bang:empty {
    display: none;
}
</file>

<file path="internal/glance/static/css/widget-server-stats.css">
.widget-type-server-info {
    position: relative;
}
.server + .server {
    margin-top: 3rem;
}
.server {
    gap: 1rem;
    display: flex;
    flex-direction: column;
}
.server-info {
    align-items: center;
    display: flex;
    justify-content: space-between;
    gap: 1.5rem;
    flex-shrink: 1;
    min-width: 0;
}
.server-details {
    min-width: 0;
}
.server-icon {
    height: 3rem;
    width: 3rem;
}
.server-spicy-cpu-icon {
    height: 1em;
    align-self: center;
    margin-left: 0.4em;
    margin-bottom: 0.2rem;
}
.server-stats {
    display: flex;
    gap: 1.5rem;
    margin-top: 0.5rem;
}
.server-stat-unavailable {
    opacity: 0.5;
}
@container widget (min-width: 650px) {
    .server {
        gap: 2rem;
        flex-direction: row;
        align-items: center;
    }
    .server + .server {
        margin-top: 1rem;
    }
    .server-info {
        flex-direction: row-reverse;
        justify-content: unset;
        margin-right: auto;
        z-index: 1;
    }
    .server-stats {
        flex-direction: row;
        justify-content: right;
        min-width: 450px;
        margin-top: 0;
        gap: 2rem;
        padding-bottom: 0.8rem;
        z-index: 1;
    }
    .server-stats > * {
        max-width: 200px;
    }
}
</file>

<file path="internal/glance/static/css/widget-todo.css">
.todo-widget {
    padding-top: 4rem;
}
.todo-plus-icon {
    --icon-color: var(--color-text-subdue);
    position: relative;
    width: 1.4rem;
    height: 1.4rem;
}
.todo-plus-icon::before, .todo-plus-icon::after {
    content: "";
    position: absolute;
    background-color: var(--icon-color);
    transition: background-color .2s;
}
.todo-plus-icon::before {
    width: 2px;
    inset-block: 0.2rem;
    left: 50%;
    transform: translateX(-50%);
}
.todo-plus-icon::after {
    height: 2px;
    inset-inline: 0.2rem;
    top: 50%;
    transform: translateY(-50%);
}
.todo-input textarea::placeholder {
    color: var(--color-text-base-muted);
}
.todo-input {
    position: relative;
    color: var(--color-text-highlight);
}
.todo-input:focus-within .todo-plus-icon {
    --icon-color: var(--color-text-base);
}
.todo-item {
    transform-origin: center;
    padding: 0.5rem 0;
}
.todo-item-checkbox {
    -webkit-appearance: none;
    appearance: none;
    border: 2px solid var(--color-text-subdue);
    width: 1.4rem;
    height: 1.4rem;
    position: relative;
    cursor: pointer;
    border-radius: 0.3rem;
    transition: border-color .2s;
}
.todo-item-checkbox::before {
    content: "";
    inset: -1rem;
    position: absolute;
}
.todo-item-checkbox::after {
    content: '';
    position: absolute;
    inset: 0.3rem;
    border-radius: 0.1rem;
    opacity: 0;
    transition: opacity .2s;
}
.todo-item-checkbox:checked::after {
    background: var(--color-primary);
    opacity: 1;
}
.todo-item-checkbox:focus-visible {
    outline: none;
    border-color: var(--color-primary);
}
.todo-item-text {
    color: var(--color-text-base);
    transition: color .35s;
}
.todo-item-text:focus {
    color: var(--color-text-highlight);
}
.todo-item-drag-handle {
    position: absolute;
    top: -0.5rem;
    inset-inline: 0;
    height: 1rem;
    cursor: grab;
}
.todo-item.is-being-dragged .todo-item-drag-handle {
    height: 3rem;
    top: -1.5rem;
}
.todo-item:has(.todo-item-checkbox:checked) .todo-item-text {
    text-decoration: line-through;
    color: var(--color-text-subdue);
}
.todo-item-delete {
    width: 1.5rem;
    height: 1.5rem;
    opacity: 0;
    transition: opacity .2s;
    outline-offset: .5rem;
}
.todo-item:hover .todo-item-delete, .todo-item:focus-within .todo-item-delete {
    opacity: 1;
}
.todo-item.is-being-dragged .todo-item-delete {
    opacity: 0;
}
</file>

<file path="internal/glance/static/css/widget-twitch.css">
.twitch-category-thumbnail {
    width: 5rem;
    aspect-ratio: 3 / 4;
    border-radius: var(--border-radius);
}
.twitch-channel-avatar {
    aspect-ratio: 1;
    border-radius: 50%;
}
.twitch-channel-avatar-container {
    width: 4.4rem;
    height: 4.4rem;
    border: 2px solid var(--color-text-subdue);
    padding: 2px;
    border-radius: 50%;
    position: relative;
    flex-shrink: 0;
}
.twitch-channel-live .twitch-channel-avatar-container {
    border: 2px solid var(--color-positive);
    margin-bottom: 1rem;
}
.twitch-channel-live .twitch-channel-avatar-container::after {
    content: 'LIVE';
    position: absolute;
    background: var(--color-positive);
    color: var(--color-widget-background);
    font-size: var(--font-size-h6);
    left: 50%;
    bottom: -35%;
    border-radius: var(--border-radius);
    padding-inline: 0.3rem;
    transform: translate(-50%);
    border: 2px solid var(--color-widget-background);
}
.twitch-stream-preview {
    max-width: 100%;
    width: 400px;
    aspect-ratio: 16 / 9;
    border-radius: var(--border-radius);
    object-fit: cover;
}
</file>

<file path="internal/glance/static/css/widget-videos.css">
.video-thumbnail {
    width: 100%;
    aspect-ratio: 16 / 8.9;
    object-fit: cover;
    border-radius: var(--border-radius) var(--border-radius) 0 0;
}
.video-horizontal-list-thumbnail {
    height: 4rem;
    aspect-ratio: 16 / 8.9;
    object-fit: cover;
    border-radius: var(--border-radius);
}
</file>

<file path="internal/glance/static/css/widget-weather.css">
.weather-column {
    position: relative;
    display: flex;
    align-items: center;
    justify-content: end;
    flex-direction: column;
    width: calc(100% / 12);
    padding-top: 3px;
}
.weather-column-value, .weather-columns:hover .weather-column-value {
    font-size: 13px;
    color: var(--color-text-highlight);
    letter-spacing: -0.1rem;
    margin-right: 0.1rem;
    position: relative;
    margin-bottom: 0.3rem;
    opacity: 0;
    transform: translateY(0.5rem);
    transition: opacity .2s, transform .2s;
    user-select: none;
}
.weather-column-current .weather-column-value, .weather-column:hover .weather-column-value {
    opacity: 1;
    transform: translateY(0);
}
.weather-column-value::after {
    position: absolute;
    content: '°';
    left: 100%;
    color: var(--color-text-subdue);
}
.weather-column-value.weather-column-value-negative::before {
    position: absolute;
    content: '-';
    right: 100%;
}
.weather-bar, .weather-columns:hover .weather-bar {
    height: calc(20px + var(--weather-bar-height) * 40px);
    width: 6px;
    background-color: hsl(var(--ths), calc(var(--scheme) ((var(--scheme) var(--bgl)) + 18%)));
    border: 1px solid hsl(var(--ths), calc(var(--scheme) ((var(--scheme) var(--bgl)) + 24%)));
    border-bottom: 0;
    border-radius: 6px 6px 0 0;
    mask-image: linear-gradient(0deg, transparent 0, #000 10px);
    -webkit-mask-image: linear-gradient(0deg, transparent 0, #000 10px);
    transition: background-color .2s, border-color .2s, width .2s;
}
.weather-column-current .weather-bar, .weather-column:hover .weather-bar {
    width: 10px;
    background-color: hsl(var(--ths), calc(var(--scheme) ((var(--scheme) var(--bgl)) + 40%)));
    border: 1px solid hsl(var(--ths), calc(var(--scheme) ((var(--scheme) var(--bgl)) + 50%)));
}
.weather-column-rain {
    position: absolute;
    inset: 0;
    bottom: 20%;
    overflow: hidden;
    mask-image: linear-gradient(0deg, transparent 40%, #000);
    -webkit-mask-image: linear-gradient(0deg, transparent 40%, #000);
}
.weather-column-rain::before {
    content: '';
    position: absolute;
    /* TODO: figure out a way to make it look continuous between columns, right now */
    /* depending on the width of the page the rain inside two columns next to each other */
    /* can overlap and look bad */
    background: radial-gradient(circle at 4px 4px, hsl(200, 90%, 70%, 0.4) 1px, transparent 0);
    background-size: 8px 8px;
    transform: rotate(45deg) translate(-50%, 25%);
    height: 130%;
    aspect-ratio: 1;
    left: 55%;
}
.weather-column:nth-child(3) .weather-column-time,
.weather-column:nth-child(7) .weather-column-time,
.weather-column:nth-child(11) .weather-column-time {
    opacity: 1;
    transform: translateY(0);
}
.weather-column-time, .weather-columns:hover .weather-column-time {
    margin-top: 0.3rem;
    font-size: var(--font-size-h6);
    opacity: 0;
    transform: translateY(-0.5rem);
    transition: opacity .2s, transform .2s;
    user-select: none;
}
.weather-column:hover .weather-column-time {
    opacity: 1;
    transform: translateY(0);
}
.weather-column-daylight {
    position: absolute;
    inset: 0;
    background: linear-gradient(0deg, transparent 30px, hsl(50, 50%, 30%, 0.2));
}
.weather-column-daylight-sunrise {
    border-radius: 20px 0 0 0;
}
.weather-column-daylight-sunset {
    border-radius: 0 20px 0 0;
}
.location-icon {
    width: 0.8em;
    height: 0.8em;
    border-radius: 0 50% 50% 50%;
    background-color: currentColor;
    transform: rotate(225deg) translate(.1em, .1em);
    position: relative;
    flex-shrink: 0;
}
.location-icon::after {
    content: '';
    position: absolute;
    z-index: 2;
    width: .4em;
    height: .4em;
    border-radius: 50%;
    background-color: var(--color-widget-background);
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}
</file>

<file path="internal/glance/templates/calendar.html">
{{ template "widget-base.html" . }}
{{ define "widget-content" }}
<div class="widget-small-content-bounds">
    <div class="calendar" data-first-day-of-week="{{ .FirstDay }}"></div>
</div>
{{ end }}
</file>

<file path="internal/glance/templates/dns-stats.html">
{{ template "widget-base.html" . }}
{{ define "widget-content" }}
<div class="widget-small-content-bounds dns-stats">
    <div class="flex text-center justify-between dns-stats-totals">
        <div>
            <div class="color-highlight size-h3">{{ .Stats.TotalQueries | formatNumber }}</div>
            <div class="size-h6">QUERIES</div>
        </div>
        <div>
            <div class="color-highlight size-h3">{{ .Stats.BlockedPercent }}%</div>
            <div class="size-h6">BLOCKED</div>
        </div>
        {{ if gt .Stats.ResponseTime 0 }}
        <div>
            <div class="color-highlight size-h3">{{ .Stats.ResponseTime | formatNumber }}ms</div>
            <div class="size-h6">LATENCY</div>
        </div>
        {{ else }}
        <div class="cursor-help" data-popover-type="text" data-popover-text="Total number of blocked domains from all adlists" data-popover-max-width="200px" data-popover-text-align="center">
            <div class="color-highlight size-h3">{{ .Stats.DomainsBlocked | formatApproxNumber }}</div>
            <div class="size-h6">DOMAINS</div>
        </div>
        {{ end }}
    </div>
    {{ $showGraph := not (or .HideGraph (eq (len .Stats.Series) 0)) }}
    {{ if $showGraph }}
    <div class="dns-stats-graph margin-top-15">
        <div class="dns-stats-graph-gridlines-container">
            <svg class="dns-stats-graph-gridlines" shape-rendering="crispEdges" viewBox="0 0 1 100" preserveAspectRatio="none">
                <g stroke="var(--color-graph-gridlines)" stroke-width="1">
                    <line x1="0" y1="1" x2="1" y2="1" vector-effect="non-scaling-stroke" />
                    <line x1="0" y1="25" x2="1" y2="25" vector-effect="non-scaling-stroke" />
                    <line x1="0" y1="50" x2="1" y2="50" vector-effect="non-scaling-stroke" />
                    <line x1="0" y1="75" x2="1" y2="75" vector-effect="non-scaling-stroke" />
                    <line x1="0" y1="99" x2="1" y2="99" vector-effect="non-scaling-stroke" stroke="var(--color-progress-bar-border)"/>
                </g>
            </svg>
        </div>
        <div class="dns-stats-graph-columns">
            {{ range $i, $column := .Stats.Series }}
            <div class="dns-stats-graph-column" data-popover-type="html" data-popover-position="above" data-popover-show-delay="500">
                <div data-popover-html>
                    <div class="flex text-center justify-between gap-25">
                        <div>
                            <div class="color-highlight size-h3">{{ $column.Queries | formatNumber }}</div>
                            <div class="size-h6">QUERIES</div>
                        </div>
                        <div>
                            <div class="color-highlight size-h3">{{ $column.PercentBlocked }}%</div>
                            <div class="size-h6">BLOCKED</div>
                        </div>
                    </div>
                </div>
                {{ if gt $column.PercentTotal 0}}
                <div class="dns-stats-graph-bar" style="--bar-height: {{ $column.PercentTotal }}">
                    {{ if ne $column.Queries $column.Blocked }}
                        <div class="queries"></div>
                    {{ end }}
                    {{ if gt $column.PercentBlocked 0 }}
                        <div class="blocked" style="--percent: {{ $column.PercentBlocked }}%"></div>
                    {{ end }}
                </div>
                {{ end }}
                <div class="dns-stats-graph-time">{{ index $.TimeLabels $i }}</div>
            </div>
            {{ end }}
        </div>
    </div>
    {{ end }}
    {{ if and (not .HideTopDomains) .Stats.TopBlockedDomains }}
    <details class="details {{ if $showGraph }}margin-top-40{{ else }}margin-top-15{{ end }}">
        <summary class="summary">Top blocked domains</summary>
        <ul class="list list-gap-4 list-with-transition size-h5">
            {{ range .Stats.TopBlockedDomains }}
            <li class="flex justify-between gap-10">
                <div class="text-truncate rtl">{{ .Domain }}</div>
                <div class="text-right" style="width: 4rem;"><span class="color-highlight">{{ .PercentBlocked }}</span>%</div>
            </li>
            {{ end }}
        </ul>
    </details>
    {{ end }}
</div>
{{ end }}
</file>

<file path="internal/glance/templates/footer.html">
{{ if not .App.Config.Branding.HideFooter }}
<footer class="footer flex items-center flex-column">
{{ if eq "" .App.Config.Branding.CustomFooter }}
    <div>
        <a class="size-h3" href="https://github.com/glanceapp/glance" target="_blank" rel="noreferrer">Glance</a> {{ if ne "dev" .App.Version }}<a class="visited-indicator" title="Release notes" href="https://github.com/glanceapp/glance/releases/tag/{{ .App.Version }}" target="_blank" rel="noreferrer">{{ .App.Version }}</a>{{ else }}({{ .App.Version }}){{ end }}
    </div>
{{ else }}
    {{ .App.Config.Branding.CustomFooter }}
{{ end }}
</footer>
{{ end }}
</file>

<file path="internal/glance/templates/login.html">
{{- template "document.html" . }}
{{- define "document-title" }}Login{{ end }}
{{- define "document-head-before" }}
<link rel="preload" href='{{ .App.StaticAssetPath "js/templating.js" }}' as="script"/>
<link rel="prefetch" href='{{ .App.StaticAssetPath "js/page.js" }}'/>
{{- end }}
{{- define "document-head-after" }}
<link rel="stylesheet" href='{{ .App.StaticAssetPath "css/login.css" }}'>
<script type="module" src='{{ .App.StaticAssetPath "js/login.js" }}'></script>
{{- end }}
{{- define "document-body" }}
<div class="flex flex-column body-content">
    <div class="flex grow items-center justify-center" style="padding-bottom: 5rem">
        <h1 class="visually-hidden">Login</h1>
        <main id="login-container" class="grow login-bounds" style="display: none;">
            <div class="animate-entrance">
                <label class="form-label widget-header" for="username">Username</label>
                <div class="form-input widget-content-frame padding-inline-widget flex gap-10 items-center">
                    <svg class="form-input-icon" fill="var(--color-text-subdue)" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" aria-hidden="true">
                        <path d="M10 8a3 3 0 1 0 0-6 3 3 0 0 0 0 6ZM3.465 14.493a1.23 1.23 0 0 0 .41 1.412A9.957 9.957 0 0 0 10 18c2.31 0 4.438-.784 6.131-2.1.43-.333.604-.903.408-1.41a7.002 7.002 0 0 0-13.074.003Z" />
                    </svg>
                    <input type="text" id="username" class="input" placeholder="Enter your username" autocomplete="off">
                </div>
            </div>
            <div class="animate-entrance">
                <label class="form-label widget-header margin-top-20" for="password">Password</label>
                <div class="form-input widget-content-frame padding-inline-widget flex gap-10 items-center">
                    <svg class="form-input-icon" fill="var(--color-text-subdue)" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" aria-hidden="true">
                        <path fill-rule="evenodd" d="M8 7a5 5 0 1 1 3.61 4.804l-1.903 1.903A1 1 0 0 1 9 14H8v1a1 1 0 0 1-1 1H6v1a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1v-2a1 1 0 0 1 .293-.707L8.196 8.39A5.002 5.002 0 0 1 8 7Zm5-3a.75.75 0 0 0 0 1.5A1.5 1.5 0 0 1 14.5 7 .75.75 0 0 0 16 7a3 3 0 0 0-3-3Z" clip-rule="evenodd" />
                    </svg>
                    <input type="password" id="password" class="input" placeholder="********" autocomplete="off">
                    <button class="toggle-password-visibility" id="toggle-password-visibility" tabindex="-1"></button>
                </div>
            </div>
            <div class="login-error-message" id="error-message"></div>
            <button class="login-button animate-entrance" id="login-button">
                <div>LOGIN</div>
                <svg stroke="currentColor" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" aria-hidden="true">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M13.5 4.5 21 12m0 0-7.5 7.5M21 12H3" />
                </svg>
            </button>
        </main>
    </div>
    {{ template "footer.html" . }}
</div>
{{- end }}
</file>

<file path="internal/glance/templates/markets.html">
{{ template "widget-base.html" . }}
{{ define "widget-content" }}
<div class="dynamic-columns list-gap-20 list-with-separator">
    {{ range .Markets }}
    <div class="flex items-center gap-15">
        <div class="min-width-0">
            <a{{ if ne "" .SymbolLink }} href="{{ .SymbolLink }}" target="_blank" rel="noreferrer"{{ end }} class="color-highlight size-h3 block text-truncate">{{ .Symbol }}</a>
            <div class="text-truncate">{{ .Name }}</div>
        </div>
        <a class="market-chart" {{ if ne "" .ChartLink }} href="{{ .ChartLink }}" target="_blank" rel="noreferrer"{{ end }}>
            <svg class="market-chart shrink-0" viewBox="0 0 100 50">
                <polyline fill="none" stroke="var(--color-text-subdue)" stroke-linejoin="round" stroke-width="1.5px" points="{{ .SvgChartPoints }}" vector-effect="non-scaling-stroke"></polyline>
            </svg>
        </a>
        <div class="market-values shrink-0">
            <div class="size-h3 text-right {{ if eq .PercentChange 0.0 }}{{ else if gt .PercentChange 0.0 }}color-positive{{ else }}color-negative{{ end }}">{{ printf "%+.2f" .PercentChange }}%</div>
            <div class="text-right">{{ .Currency }}{{ .Price | formatPriceWithPrecision .PriceHint }}</div>
        </div>
    </div>
    {{ end }}
</div>
{{ end }}
</file>

<file path="internal/glance/templates/old-calendar.html">
{{ template "widget-base.html" . }}
{{ define "widget-content" }}
<div class="widget-small-content-bounds">
    <div class="flex justify-between items-center">
        <div class="color-highlight size-h1">{{ .Calendar.CurrentMonthName }}</div>
        <ul class="list-horizontal-text color-highlight size-h4">
            <li>Week {{ .Calendar.CurrentWeekNumber }}</li>
            <li>{{ .Calendar.CurrentYear }}</li>
        </ul>
    </div>
    <div class="flex flex-wrap size-h6 margin-top-10 color-subdue">
        {{ if .StartSunday }}
            <div class="old-calendar-day">Su</div>
        {{ end }}
        <div class="old-calendar-day">Mo</div>
        <div class="old-calendar-day">Tu</div>
        <div class="old-calendar-day">We</div>
        <div class="old-calendar-day">Th</div>
        <div class="old-calendar-day">Fr</div>
        <div class="old-calendar-day">Sa</div>
        {{ if not .StartSunday }}
            <div class="old-calendar-day">Su</div>
        {{ end }}
    </div>
    <div class="flex flex-wrap">
        {{ range .Calendar.Days }}
        <div class="old-calendar-day{{ if eq . $.Calendar.CurrentDay }} old-calendar-day-today{{ end }}">{{ . }}</div>
        {{ end }}
    </div>
</div>
{{ end }}
</file>

<file path="internal/glance/templates/page-content.html">
{{ if .Page.ShowMobileHeader }}
<div class="mobile-reachability-header">{{ .Page.Title }}</div>
{{ end }}
{{ if .Page.HeadWidgets }}
<div class="head-widgets">
    {{- range .Page.HeadWidgets }}
    {{- .Render }}
    {{- end }}
</div>
{{ end }}
<div class="page-columns">
{{- range .Page.Columns }}
    <div class="page-column page-column-{{ .Size }}">
        {{- range .Widgets }}
        {{- .Render }}
        {{- end }}
    </div>
{{- end }}
</div>
</file>

<file path="internal/glance/templates/reddit-horizontal-cards.html">
{{ template "widget-base.html" . }}
{{ define "widget-content-classes" }}widget-content-frameless{{ end }}
{{ define "widget-content" }}
<div class="carousel-container">
    <div class="cards-horizontal carousel-items-container">
        {{ range .Posts }}
        <div class="card widget-content-frame relative">
            {{ if ne "" .ThumbnailUrl }}
            <div class="reddit-card-thumbnail-container">
                <img class="reddit-card-thumbnail" loading="lazy" src="{{ .ThumbnailUrl }}" alt="">
            </div>
            {{ end }}
            <div class="padding-widget flex flex-column grow relative">
                {{ if ne "" .TargetUrl }}
                <a class="color-highlight size-h5 text-truncate visited-indicator" href="{{ .TargetUrl }}" target="_blank" rel="noreferrer">{{ .TargetUrlDomain }}</a>
                {{ else }}
                <div class="color-highlight size-h5 text-truncate">/r/{{ $.Subreddit }}</div>
                {{ end }}
                <a href="{{ .DiscussionUrl }}" class="text-truncate-3-lines color-primary-if-not-visited margin-top-7 margin-bottom-auto" target="_blank" rel="noreferrer">{{ .Title }}</a>
                <ul class="list-horizontal-text margin-top-7">
                    <li {{ dynamicRelativeTimeAttrs .TimePosted }}></li>
                    <li>{{ .Score | formatApproxNumber }} points</li>
                </ul>
            </div>
        </div>
        {{ end }}
    </div>
</div>
{{ end }}
</file>

<file path="internal/glance/templates/reddit-vertical-cards.html">
{{ template "widget-base.html" . }}
{{ define "widget-content-classes" }}widget-content-frameless{{ end }}
{{ define "widget-content" }}
<div class="cards-vertical">
    {{ range .Posts }}
    <div class="widget-content-frame relative">
        {{ if ne "" .ThumbnailUrl }}
        <div class="reddit-card-thumbnail-container">
            <img class="reddit-card-thumbnail" loading="lazy" src="{{ .ThumbnailUrl }}" alt="">
        </div>
        {{ end }}
        <div class="padding-widget relative">
            {{ if ne "" .TargetUrl }}
            <a class="color-highlight size-h5 text-truncate visited-indicator block" href="{{ .TargetUrl }}" target="_blank" rel="noreferrer">{{ .TargetUrlDomain }}</a>
            {{ else }}
            <div class="color-highlight size-h5 text-truncate">/r/{{ $.Subreddit }}</div>
            {{ end }}
            <a href="{{ .DiscussionUrl }}" class="text-truncate-3-lines color-primary-if-not-visited margin-top-7" target="_blank" rel="noreferrer">{{ .Title }}</a>
            <ul class="list-horizontal-text margin-top-7">
                <li {{ dynamicRelativeTimeAttrs .TimePosted }}></li>
                <li>{{ .Score | formatApproxNumber }} points</li>
            </ul>
        </div>
    </div>
    {{ end }}
</div>
{{ end }}
</file>

<file path="internal/glance/templates/repository.html">
{{ template "widget-base.html" . }}
{{ define "widget-content" }}
<a class="size-h4 color-highlight" href="https://github.com/{{ $.Repository.Name }}" target="_blank" rel="noreferrer">{{ .Repository.Name }}</a>
<ul class="list-horizontal-text">
    <li>{{ .Repository.Stars | formatNumber }} stars</li>
    <li>{{ .Repository.Forks | formatNumber }} forks</li>
</ul>
{{ if gt (len .Repository.Commits) 0 }}
<hr class="margin-block-8">
<a class="text-compact" href="https://github.com/{{ $.Repository.Name }}/commits" target="_blank" rel="noreferrer">Last {{ .CommitsLimit }} commits</a>
<div class="flex gap-7 size-h5 size-base-on-mobile margin-top-3">
    <ul class="list list-gap-2">
        {{ range .Repository.Commits }}
        <li {{ dynamicRelativeTimeAttrs .CreatedAt }}></li>
        {{ end }}
    </ul>
    <ul class="list list-gap-2 min-width-0">
        {{ range .Repository.Commits }}
        <li><a class="color-primary-if-not-visited text-truncate block" title="{{ .Author }}" target="_blank" rel="noreferrer" href="https://github.com/{{ $.Repository.Name }}/commit/{{ .Sha }}">{{ .Message }}</a></li>
        {{ end }}
    </ul>
</div>
{{ end }}
{{ if gt (len .Repository.PullRequests) 0 }}
<hr class="margin-block-8">
<a class="text-compact" href="https://github.com/{{ $.Repository.Name }}/pulls" target="_blank" rel="noreferrer">Open pull requests ({{ .Repository.OpenPullRequests | formatNumber }} total)</a>
<div class="flex gap-7 size-h5 size-base-on-mobile margin-top-3">
    <ul class="list list-gap-2">
        {{ range .Repository.PullRequests }}
        <li {{ dynamicRelativeTimeAttrs .CreatedAt }}></li>
        {{ end }}
    </ul>
    <ul class="list list-gap-2 min-width-0">
        {{ range .Repository.PullRequests }}
        <li><a class="color-primary-if-not-visited text-truncate block" target="_blank" rel="noreferrer" href="https://github.com/{{ $.Repository.Name }}/pull/{{ .Number }}">{{ .Title }}</a></li>
        {{ end }}
    </ul>
</div>
{{ end }}
{{ if gt (len .Repository.Issues) 0 }}
<hr class="margin-block-10">
<a class="text-compact" href="https://github.com/{{ $.Repository.Name }}/issues" target="_blank" rel="noreferrer">Open issues ({{ .Repository.OpenIssues | formatNumber }} total)</a>
<div class="flex gap-7 size-h5 size-base-on-mobile margin-top-3">
    <ul class="list list-gap-2">
        {{ range .Repository.Issues }}
        <li {{ dynamicRelativeTimeAttrs .CreatedAt }}></li>
        {{ end }}
    </ul>
    <ul class="list list-gap-2 min-width-0">
        {{ range .Repository.Issues }}
        <li><a class="color-primary-if-not-visited text-truncate block" target="_blank" rel="noreferrer" href="https://github.com/{{ $.Repository.Name }}/issues/{{ .Number }}">{{ .Title }}</a></li>
        {{ end }}
    </ul>
</div>
{{ end }}
{{ end }}
</file>

<file path="internal/glance/templates/search.html">
{{ template "widget-base.html" . }}
{{ define "widget-content-classes" }}widget-content-frameless{{ end }}
{{ define "widget-content" }}
<div class="search widget-content-frame padding-inline-widget flex gap-15 items-center" data-default-search-url="{{ .SearchEngine }}" data-new-tab="{{ .NewTab }}" data-target="{{ .Target }}">
    <div class="search-bangs">
        {{ range .Bangs }}
        <input type="hidden" data-shortcut="{{ .Shortcut }}" data-title="{{ .Title }}" data-url="{{ .URL }}">
        {{ end }}
    </div>
    <div class="search-icon-container">
        <svg class="search-icon" stroke="var(--color-text-subdue)" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5">
            <path stroke-linecap="round" stroke-linejoin="round" d="m21 21-5.197-5.197m0 0A7.5 7.5 0 1 0 5.196 5.196a7.5 7.5 0 0 0 10.607 10.607Z" />
        </svg>
    </div>
    <input class="search-input" type="text" placeholder="{{ .Placeholder }}" autocomplete="off"{{ if .Autofocus }} autofocus{{ end }}>
    <div class="search-bang"></div>
    <kbd class="hide-on-mobile" title="Press [S] to focus the search input">S</kbd>
</div>
{{ end }}
</file>

<file path="internal/glance/templates/server-stats.html">
{{ template "widget-base.html" . }}
{{- define "widget-content" }}
{{- range .Servers }}
<div class="server">
    <div class="server-info">
        <div class="server-details">
            <div class="server-name color-highlight size-h3">{{ if .Name }}{{ .Name }}{{ else }}{{ .Info.Hostname }}{{ end }}</div>
            <div>
                {{- if .IsReachable }}
                    {{ if .Info.HostInfoIsAvailable }}<span {{ dynamicRelativeTimeAttrs .Info.BootTime }}></span>{{ else }}unknown{{ end }} uptime
                {{- else }}
                    unreachable
                {{- end }}
            </div>
        </div>
        <div class="shrink-0"{{ if .IsReachable }} data-popover-type="html" data-popover-margin="0.2rem" data-popover-max-width="400px"{{ end }}>
            {{- if .IsReachable }}
            <div data-popover-html>
                <div class="size-h5 text-compact">PLATFORM</div>
                <div class="color-highlight">{{ if .Info.HostInfoIsAvailable }}{{ .Info.Platform }}{{ else }}Unknown{{ end }}</div>
            </div>
            {{- end }}
            <svg class="server-icon" stroke="var(--color-{{ if .IsReachable }}positive{{ else }}negative{{ end }})" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5">
                <path stroke-linecap="round" stroke-linejoin="round" d="M21.75 17.25v-.228a4.5 4.5 0 0 0-.12-1.03l-2.268-9.64a3.375 3.375 0 0 0-3.285-2.602H7.923a3.375 3.375 0 0 0-3.285 2.602l-2.268 9.64a4.5 4.5 0 0 0-.12 1.03v.228m19.5 0a3 3 0 0 1-3 3H5.25a3 3 0 0 1-3-3m19.5 0a3 3 0 0 0-3-3H5.25a3 3 0 0 0-3 3m16.5 0h.008v.008h-.008v-.008Zm-3 0h.008v.008h-.008v-.008Z" />
            </svg>
        </div>
    </div>
    <div class="server-stats">
        <div class="flex-1{{ if not .Info.CPU.LoadIsAvailable }} server-stat-unavailable{{ end }}">
            <div class="flex items-end size-h5">
                <div>CPU</div>
                {{- if and .Info.CPU.TemperatureIsAvailable (ge .Info.CPU.TemperatureC 80) }}
                <svg class="server-spicy-cpu-icon" fill="var(--color-negative)" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" >
                    <path fill-rule="evenodd" d="M8.074.945A4.993 4.993 0 0 0 6 5v.032c.004.6.114 1.176.311 1.709.16.428-.204.91-.61.7a5.023 5.023 0 0 1-1.868-1.677c-.202-.304-.648-.363-.848-.058a6 6 0 1 0 8.017-1.901l-.004-.007a4.98 4.98 0 0 1-2.18-2.574c-.116-.31-.477-.472-.744-.28Zm.78 6.178a3.001 3.001 0 1 1-3.473 4.341c-.205-.365.215-.694.62-.59a4.008 4.008 0 0 0 1.873.03c.288-.065.413-.386.321-.666A3.997 3.997 0 0 1 8 8.999c0-.585.126-1.14.351-1.641a.42.42 0 0 1 .503-.235Z" clip-rule="evenodd" />
                </svg>
                {{- end }}
                <div class="color-highlight margin-left-auto text-very-compact">{{ if .Info.CPU.LoadIsAvailable }}{{ .Info.CPU.Load1Percent }} <span class="color-base">%</span>{{ else }}n/a{{ end }}</div>
            </div>
            <div{{ if .Info.CPU.LoadIsAvailable }} data-popover-type="html"{{ end }}>
                {{- if .Info.CPU.LoadIsAvailable }}
                <div data-popover-html>
                    <div class="flex">
                        <div class="size-h5">1M AVG</div>
                        <div class="value-separator"></div>
                        <div class="color-highlight text-very-compact">{{ .Info.CPU.Load1Percent }} <span class="color-base size-h5">%</span></div>
                    </div>
                    <div class="flex margin-top-3">
                        <div class="size-h5">15M AVG</div>
                        <div class="value-separator"></div>
                        <div class="color-highlight text-very-compact">{{ .Info.CPU.Load15Percent }} <span class="color-base size-h5">%</span></div>
                    </div>
                    {{- if .Info.CPU.TemperatureIsAvailable }}
                    <div class="flex margin-top-3">
                        <div class="size-h5">TEMP C</div>
                        <div class="value-separator"></div>
                        <div class="color-highlight text-very-compact">{{ .Info.CPU.TemperatureC }} <span class="color-base size-h5">°</span></div>
                    </div>
                    {{- end }}
                </div>
                {{- end }}
                <div class="progress-bar progress-bar-combined">
                    {{- if .Info.CPU.LoadIsAvailable }}
                    <div class="progress-value{{ if ge .Info.CPU.Load1Percent 85 }} progress-value-notice{{ end }}" style="--percent: {{ .Info.CPU.Load1Percent }}"></div>
                    <div class="progress-value{{ if ge .Info.CPU.Load15Percent 85 }} progress-value-notice{{ end }}" style="--percent: {{ .Info.CPU.Load15Percent }}"></div>
                    {{- end }}
                </div>
            </div>
        </div>
        <div class="flex-1{{ if not .Info.Memory.IsAvailable }} server-stat-unavailable{{ end }}">
            <div class="flex justify-between items-end size-h5">
                <div>RAM</div>
                <div class="color-highlight text-very-compact">{{ if .Info.Memory.IsAvailable }}{{ .Info.Memory.UsedPercent }} <span class="color-base">%</span>{{ else }}n/a{{ end }}</div>
            </div>
            <div{{ if .Info.Memory.IsAvailable }} data-popover-type="html"{{ end }}>
                {{- if .Info.Memory.IsAvailable }}
                <div data-popover-html>
                    <div class="flex">
                        <div class="size-h5">RAM</div>
                        <div class="value-separator"></div>
                        <div class="color-highlight text-very-compact">
                            {{ .Info.Memory.UsedMB | formatServerMegabytes }} <span class="color-base size-h5">/</span> {{ .Info.Memory.TotalMB | formatServerMegabytes }}
                        </div>
                    </div>
                    {{- if and (not .HideSwap) .Info.Memory.SwapIsAvailable }}
                    <div class="flex margin-top-3">
                        <div class="size-h5">SWAP</div>
                        <div class="value-separator"></div>
                        <div class="color-highlight text-very-compact">
                            {{ .Info.Memory.SwapUsedMB | formatServerMegabytes }} <span class="color-base size-h5">/</span> {{ .Info.Memory.SwapTotalMB | formatServerMegabytes }}
                        </div>
                    </div>
                    {{- end }}
                </div>
                {{- end }}
                <div class="progress-bar progress-bar-combined">
                    {{- if .Info.Memory.IsAvailable }}
                    <div class="progress-value{{ if ge .Info.Memory.UsedPercent 85 }} progress-value-notice{{ end }}" style="--percent: {{ .Info.Memory.UsedPercent }}"></div>
                    {{- if and (not .HideSwap) .Info.Memory.SwapIsAvailable }}
                    <div class="progress-value{{ if ge .Info.Memory.SwapUsedPercent 85 }} progress-value-notice{{ end }}" style="--percent: {{ .Info.Memory.SwapUsedPercent }}"></div>
                    {{- end }}
                    {{- end }}
                </div>
            </div>
        </div>
        <div class="flex-1{{ if not .Info.Mountpoints }} server-stat-unavailable{{ end }}">
            <div class="flex justify-between items-end size-h5">
                <div>DISK</div>
                <div class="color-highlight text-very-compact">{{ if .Info.Mountpoints }}{{ (index .Info.Mountpoints 0).UsedPercent }} <span class="color-base">%</span>{{ else }}n/a{{ end }}</div>
            </div>
            <div{{ if .Info.Mountpoints }} data-popover-type="html"{{ end }}>
                {{- if .Info.Mountpoints }}
                <div data-popover-html>
                    <ul class="list list-gap-2">
                        {{- range .Info.Mountpoints }}
                        <li class="flex">
                            <div class="size-h5">{{ if .Name }}{{ .Name }}{{ else }}{{ .Path }}{{ end }}</div>
                            <div class="value-separator"></div>
                            <div class="color-highlight text-very-compact">
                                {{ .UsedMB | formatServerMegabytes }} <span class="color-base size-h5">/</span> {{ .TotalMB | formatServerMegabytes }}
                            </div>
                        </li>
                        {{- end }}
                    </ul>
                </div>
                {{- end }}
                <div class="progress-bar progress-bar-combined">
                    {{- if .Info.Mountpoints }}
                    <div class="progress-value{{ if ge ((index .Info.Mountpoints 0).UsedPercent) 85 }} progress-value-notice{{ end }}" style="--percent: {{ (index .Info.Mountpoints 0).UsedPercent }}"></div>
                    {{- if ge (len .Info.Mountpoints) 2 }}
                    <div class="progress-value{{ if ge ((index .Info.Mountpoints 1).UsedPercent) 85 }} progress-value-notice{{ end }}" style="--percent: {{ (index .Info.Mountpoints 1).UsedPercent }}"></div>
                    {{- end }}
                    {{- end }}
                </div>
            </div>
        </div>
    </div>
</div>
{{- end }}
{{- end }}
</file>

<file path="internal/glance/templates/theme-preset-preview.html">
{{- $background := "hsl(240, 8%, 9%)" | safeCSS }}
{{- $primary := "hsl(43, 50%, 70%)" | safeCSS  }}
{{- $positive := "hsl(43, 50%, 70%)" | safeCSS }}
{{- $negative := "hsl(0, 70%, 70%)" | safeCSS }}
{{- if .BackgroundColor }}{{ $background = .BackgroundColor.String | safeCSS }}{{ end }}
{{- if .PrimaryColor }}
    {{- $primary = .PrimaryColor.String | safeCSS }}
    {{- if not .PositiveColor }}
        {{- $positive = $primary }}
    {{- else }}
        {{- $positive = .PositiveColor.String | safeCSS }}
    {{- end }}
{{- end }}
{{- if .NegativeColor }}{{ $negative = .NegativeColor.String | safeCSS }}{{ end }}
<button class="theme-preset{{ if .Light }} theme-preset-light{{ end }}" style="--color: {{ $background }}" data-key="{{ .Key }}">
    <div class="theme-color" style="--color: {{ $primary }}"></div>
    <div class="theme-color" style="--color: {{ $positive }}"></div>
    <div class="theme-color" style="--color: {{ $negative }}"></div>
</button>
</file>

<file path="internal/glance/templates/todo.html">
{{ template "widget-base.html" . }}
{{ define "widget-content" }}
<div class="todo" data-todo-id="{{ .TodoID }}"></div>
{{ end }}
</file>

<file path="internal/glance/templates/twitch-channels.html">
{{ template "widget-base.html" . }}
{{ define "widget-content" }}
<ul class="list list-gap-14 collapsible-container" data-collapse-after="{{ .CollapseAfter }}">
    {{ range .Channels }}
    <li>
        <div class="{{ if .IsLive }}twitch-channel-live {{ end }}flex gap-10 items-start thumbnail-parent">
            <div class="twitch-channel-avatar-container"{{ if .IsLive }} data-popover-type="html" data-popover-position="above" data-popover-margin="0.15rem" data-popover-offset="0.2"{{ end }}>
                {{ if .IsLive }}
                <div data-popover-html>
                    <img class="twitch-stream-preview" src="https://static-cdn.jtvnw.net/previews-ttv/live_user_{{ .Login }}-440x248.jpg" loading="lazy" alt="">
                    <p class="margin-top-10 color-highlight text-truncate-3-lines">{{ .StreamTitle }}</p>
                </div>
                {{ end }}
                {{ if .Exists }}
                <a href="https://twitch.tv/{{ .Login }}" target="_blank" rel="noreferrer">
                    <img class="twitch-channel-avatar thumbnail" src="{{ .AvatarUrl }}" alt="" loading="lazy">
                </a>
                {{ else }}
                <svg class="twitch-channel-avatar thumbnail" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 6a3.75 3.75 0 1 1-7.5 0 3.75 3.75 0 0 1 7.5 0ZM4.501 20.118a7.5 7.5 0 0 1 14.998 0A17.933 17.933 0 0 1 12 21.75c-2.676 0-5.216-.584-7.499-1.632Z" />
                </svg>
                {{ end }}
            </div>
            <div class="min-width-0">
                <a href="https://twitch.tv/{{ .Login }}" class="size-h3{{ if .IsLive }} color-highlight{{ end }} block text-truncate" target="_blank" rel="noreferrer">{{ .Name }}</a>
                {{ if .Exists }}
                    {{ if .IsLive }}
                        {{ if .Category }}
                            <a class="text-truncate block" href="https://www.twitch.tv/directory/category/{{ .CategorySlug }}" target="_blank" rel="noreferrer">{{ .Category }}</a>
                        {{ end }}
                    <ul class="list-horizontal-text">
                        <li {{ dynamicRelativeTimeAttrs .LiveSince }}></li>
                        <li>{{ .ViewersCount | formatApproxNumber }} viewers</li>
                    </ul>
                    {{ else }}
                    <div>Offline</div>
                    {{ end }}
                {{ else }}
                <div class="color-negative">Not found</div>
                {{ end }}
            </div>
        </div>
    </li>
    {{ end }}
</ul>
{{ end }}
</file>

<file path="internal/glance/templates/twitch-games-list.html">
{{ template "widget-base.html" . }}
{{ define "widget-content" }}
<ul class="list list-gap-14 collapsible-container" data-collapse-after="{{ .CollapseAfter }}">
    {{ range .Categories }}
    <li class="twitch-category thumbnail-parent">
        <div class="flex gap-10 items-start">
            <img class="twitch-category-thumbnail thumbnail" loading="lazy" src="{{ .AvatarUrl }}" alt="">
            <div class="min-width-0">
                <a class="size-h3 color-highlight text-truncate block" href="https://www.twitch.tv/directory/category/{{ .Slug }}" target="_blank" rel="noreferrer">{{ .Name }}</a>
                <ul class="list-horizontal-text">
                    <li>{{ .ViewersCount | formatApproxNumber }} viewers</li>
                    {{ if .IsNew }}
                    <li class="color-primary">NEW</li>
                    {{ end }}
                </ul>
                <ul class="list-horizontal-text flex-nowrap">
                    {{ range $i, $tag := .Tags }}
                        {{ if eq $i 0 }}
                        <li class="shrink-0">{{ $tag.Name }}</li>
                        {{ else }}
                        <li class="text-truncate min-width-0">{{ $tag.Name }}</li>
                        {{ end }}
                    {{ end }}
                </ul>
            </div>
        </div>
    </li>
    {{ end }}
</ul>
{{ end }}
</file>

<file path="internal/glance/templates/v0.7-update-notice-page.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="static/main.css">
    <title>Update notice</title>
    <style>
        body {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .content-bounds {
            max-width: 700px;
            margin-top: -10rem;
        }
        .comfy-line-height {
            line-height: 1.9;
        }
    </style>
</head>
<body>
<div class="content-bounds color-paragraph">
    <p class="uppercase size-h5 color-negative padding-inline-widget">UPDATE NOTICE</p>
    <div class="widget-content-frame margin-top-10 padding-widget">
        <p class="comfy-line-height">
            The default location of glance.yml in the Docker image has
            changed since v0.7.0, please see the <a class="color-primary" href="https://github.com/glanceapp/glance/blob/main/docs/v0.7.0-upgrade.md" target="_blank">migration guide</a>
            for instructions or visit the <a class="color-primary" href="https://github.com/glanceapp/glance/releases/tag/v0.7.0" target="_blank">release notes</a>
            to find out more about why this change was necessary. Sorry for the inconvenience.
        </p>
        <p class="margin-top-15 color-base">Migration should take around 5 minutes.</p>
    </div>
</div>
</body>
</html>
</file>

<file path="internal/glance/templates/video-card-contents.html">
{{ define "video-card-contents" }}
<img class="video-thumbnail thumbnail" loading="lazy" src="{{ .ThumbnailUrl }}" alt="">
<div class="margin-top-10 margin-bottom-widget flex flex-column grow padding-inline-widget">
    <a class="text-truncate-2-lines margin-bottom-auto color-primary-if-not-visited" href="{{ .Url | safeURL }}" target="_blank" rel="noreferrer">{{ .Title }}</a>
    <ul class="list-horizontal-text flex-nowrap margin-top-7">
        <li class="shrink-0" {{ dynamicRelativeTimeAttrs .TimePosted }}></li>
        <li class="min-width-0">
            <a class="block text-truncate" href="{{ .AuthorUrl }}" target="_blank" rel="noreferrer">{{ .Author }}</a>
        </li>
    </ul>
</div>
{{ end }}
</file>

<file path="internal/glance/widget-bookmarks.go">
package glance
import (
	"html/template"
)
var bookmarksWidgetTemplate = mustParseTemplate("bookmarks.html", "widget-base.html")
type bookmarksWidget struct {
	widgetBase `yaml:",inline"`
	cachedHTML template.HTML `yaml:"-"`
	Groups     []struct {
		Title     string         `yaml:"title"`
		Color     *hslColorField `yaml:"color"`
		SameTab   bool           `yaml:"same-tab"`
		HideArrow bool           `yaml:"hide-arrow"`
		Target    string         `yaml:"target"`
		Links     []struct {
			Title       string          `yaml:"title"`
			URL         string          `yaml:"url"`
			Description string          `yaml:"description"`
			Icon        customIconField `yaml:"icon"`
			// we need a pointer to bool to know whether a value was provided,
			// however there's no way to dereference a pointer in a template so
			// {{ if not .SameTab }} would return true for any non-nil pointer
			// which leaves us with no way of checking if the value is true or
			// false, hence the duplicated fields below
			SameTabRaw   *bool  `yaml:"same-tab"`
			SameTab      bool   `yaml:"-"`
			HideArrowRaw *bool  `yaml:"hide-arrow"`
			HideArrow    bool   `yaml:"-"`
			Target       string `yaml:"target"`
		} `yaml:"links"`
	} `yaml:"groups"`
}
func (widget *bookmarksWidget) initialize() error {
	widget.withTitle("Bookmarks").withError(nil)
	for g := range widget.Groups {
		group := &widget.Groups[g]
		for l := range group.Links {
			link := &group.Links[l]
			if link.SameTabRaw == nil {
				link.SameTab = group.SameTab
			} else {
				link.SameTab = *link.SameTabRaw
			}
			if link.HideArrowRaw == nil {
				link.HideArrow = group.HideArrow
			} else {
				link.HideArrow = *link.HideArrowRaw
			}
			if link.Target == "" {
				if group.Target != "" {
					link.Target = group.Target
				} else {
					if link.SameTab {
						link.Target = ""
					} else {
						link.Target = "_blank"
					}
				}
			}
		}
	}
	widget.cachedHTML = widget.renderTemplate(widget, bookmarksWidgetTemplate)
	return nil
}
func (widget *bookmarksWidget) Render() template.HTML {
	return widget.cachedHTML
}
</file>

<file path="internal/glance/widget-calendar.go">
package glance
import (
	"errors"
	"html/template"
	"time"
)
var calendarWidgetTemplate = mustParseTemplate("calendar.html", "widget-base.html")
var calendarWeekdaysToInt = map[string]time.Weekday{
	"sunday":    time.Sunday,
	"monday":    time.Monday,
	"tuesday":   time.Tuesday,
	"wednesday": time.Wednesday,
	"thursday":  time.Thursday,
	"friday":    time.Friday,
	"saturday":  time.Saturday,
}
type calendarWidget struct {
	widgetBase     `yaml:",inline"`
	FirstDayOfWeek string        `yaml:"first-day-of-week"`
	FirstDay       int           `yaml:"-"`
	cachedHTML     template.HTML `yaml:"-"`
}
func (widget *calendarWidget) initialize() error {
	widget.withTitle("Calendar").withError(nil)
	if widget.FirstDayOfWeek == "" {
		widget.FirstDayOfWeek = "monday"
	} else if _, ok := calendarWeekdaysToInt[widget.FirstDayOfWeek]; !ok {
		return errors.New("invalid first day of week")
	}
	widget.FirstDay = int(calendarWeekdaysToInt[widget.FirstDayOfWeek])
	widget.cachedHTML = widget.renderTemplate(widget, calendarWidgetTemplate)
	return nil
}
func (widget *calendarWidget) Render() template.HTML {
	return widget.cachedHTML
}
</file>

<file path="internal/glance/widget-dns-stats.go">
package glance
import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"html/template"
	"io"
	"log/slog"
	"net/http"
	"sort"
	"strings"
	"sync"
	"time"
)
var dnsStatsWidgetTemplate = mustParseTemplate("dns-stats.html", "widget-base.html")
const (
	dnsStatsBars            = 8
	dnsStatsHoursSpan       = 24
	dnsStatsHoursPerBar int = dnsStatsHoursSpan / dnsStatsBars
)
type dnsStatsWidget struct {
	widgetBase `yaml:",inline"`
	TimeLabels      [8]string `yaml:"-"`
	Stats           *dnsStats `yaml:"-"`
	piholeSessionID string    `yaml:"-"`
	HourFormat     string `yaml:"hour-format"`
	HideGraph      bool   `yaml:"hide-graph"`
	HideTopDomains bool   `yaml:"hide-top-domains"`
	Service        string `yaml:"service"`
	AllowInsecure  bool   `yaml:"allow-insecure"`
	URL            string `yaml:"url"`
	Token          string `yaml:"token"`
	Username       string `yaml:"username"`
	Password       string `yaml:"password"`
}
const (
	dnsServiceAdguard    = "adguard"
	dnsServicePihole     = "pihole"
	dnsServiceTechnitium = "technitium"
	dnsServicePiholeV6   = "pihole-v6"
)
func makeDNSWidgetTimeLabels(format string) [8]string {
	now := time.Now()
	var labels [dnsStatsBars]string
	for h := dnsStatsHoursSpan; h > 0; h -= dnsStatsHoursPerBar {
		labels[7-(h/3-1)] = strings.ToLower(now.Add(-time.Duration(h) * time.Hour).Format(format))
	}
	return labels
}
func (widget *dnsStatsWidget) initialize() error {
	titleURL := strings.TrimRight(widget.URL, "/")
	switch widget.Service {
	case dnsServicePihole, dnsServicePiholeV6:
		titleURL = titleURL + "/admin"
	}
	widget.
		withTitle("DNS Stats").
		withTitleURL(titleURL).
		withCacheDuration(10 * time.Minute)
	switch widget.Service {
	case dnsServiceAdguard:
	case dnsServicePiholeV6:
	case dnsServicePihole:
	case dnsServiceTechnitium:
	default:
		return fmt.Errorf("service must be one of: %s, %s, %s, %s", dnsServiceAdguard, dnsServicePihole, dnsServicePiholeV6, dnsServiceTechnitium)
	}
	return nil
}
func (widget *dnsStatsWidget) update(ctx context.Context) {
	var stats *dnsStats
	var err error
	switch widget.Service {
	case dnsServiceAdguard:
		stats, err = fetchAdguardStats(widget.URL, widget.AllowInsecure, widget.Username, widget.Password, widget.HideGraph)
	case dnsServicePihole:
		stats, err = fetchPihole5Stats(widget.URL, widget.AllowInsecure, widget.Token, widget.HideGraph)
	case dnsServiceTechnitium:
		stats, err = fetchTechnitiumStats(widget.URL, widget.AllowInsecure, widget.Token, widget.HideGraph)
	case dnsServicePiholeV6:
		var newSessionID string
		stats, newSessionID, err = fetchPiholeStats(
			widget.URL,
			widget.AllowInsecure,
			widget.Password,
			widget.piholeSessionID,
			!widget.HideGraph,
			!widget.HideTopDomains,
		)
		if err == nil {
			widget.piholeSessionID = newSessionID
		}
	}
	if !widget.canContinueUpdateAfterHandlingErr(err) {
		return
	}
	if widget.HourFormat == "24h" {
		widget.TimeLabels = makeDNSWidgetTimeLabels("15:00")
	} else {
		widget.TimeLabels = makeDNSWidgetTimeLabels("3PM")
	}
	widget.Stats = stats
}
func (widget *dnsStatsWidget) Render() template.HTML {
	return widget.renderTemplate(widget, dnsStatsWidgetTemplate)
}
type dnsStats struct {
	TotalQueries      int
	BlockedQueries    int // we don't actually use this anywhere in templates, maybe remove it later?
	BlockedPercent    int
	ResponseTime      int
	DomainsBlocked    int
	Series            [dnsStatsBars]dnsStatsSeries
	TopBlockedDomains []dnsStatsBlockedDomain
}
type dnsStatsSeries struct {
	Queries        int
	Blocked        int
	PercentTotal   int
	PercentBlocked int
}
type dnsStatsBlockedDomain struct {
	Domain         string
	PercentBlocked int
}
type adguardStatsResponse struct {
	TotalQueries      int              `json:"num_dns_queries"`
	QueriesSeries     []int            `json:"dns_queries"`
	BlockedQueries    int              `json:"num_blocked_filtering"`
	BlockedSeries     []int            `json:"blocked_filtering"`
	ResponseTime      float64          `json:"avg_processing_time"`
	TopBlockedDomains []map[string]int `json:"top_blocked_domains"`
}
func fetchAdguardStats(instanceURL string, allowInsecure bool, username, password string, noGraph bool) (*dnsStats, error) {
	requestURL := strings.TrimRight(instanceURL, "/") + "/control/stats"
	request, err := http.NewRequest("GET", requestURL, nil)
	if err != nil {
		return nil, err
	}
	request.SetBasicAuth(username, password)
	var client = ternary(allowInsecure, defaultInsecureHTTPClient, defaultHTTPClient)
	responseJson, err := decodeJsonFromRequest[adguardStatsResponse](client, request)
	if err != nil {
		return nil, err
	}
	var topBlockedDomainsCount = min(len(responseJson.TopBlockedDomains), 5)
	stats := &dnsStats{
		TotalQueries:      responseJson.TotalQueries,
		BlockedQueries:    responseJson.BlockedQueries,
		ResponseTime:      int(responseJson.ResponseTime * 1000),
		TopBlockedDomains: make([]dnsStatsBlockedDomain, 0, topBlockedDomainsCount),
	}
	if stats.TotalQueries <= 0 {
		return stats, nil
	}
	stats.BlockedPercent = int(float64(responseJson.BlockedQueries) / float64(responseJson.TotalQueries) * 100)
	for i := range topBlockedDomainsCount {
		domain := responseJson.TopBlockedDomains[i]
		var firstDomain string
		for k := range domain {
			firstDomain = k
			break
		}
		if firstDomain == "" {
			continue
		}
		stats.TopBlockedDomains = append(stats.TopBlockedDomains, dnsStatsBlockedDomain{
			Domain: firstDomain,
		})
		if stats.BlockedQueries > 0 {
			stats.TopBlockedDomains[i].PercentBlocked = int(float64(domain[firstDomain]) / float64(responseJson.BlockedQueries) * 100)
		}
	}
	if noGraph {
		return stats, nil
	}
	queriesSeries := responseJson.QueriesSeries
	blockedSeries := responseJson.BlockedSeries
	if len(queriesSeries) > dnsStatsHoursSpan {
		queriesSeries = queriesSeries[len(queriesSeries)-dnsStatsHoursSpan:]
	} else if len(queriesSeries) < dnsStatsHoursSpan {
		queriesSeries = append(make([]int, dnsStatsHoursSpan-len(queriesSeries)), queriesSeries...)
	}
	if len(blockedSeries) > dnsStatsHoursSpan {
		blockedSeries = blockedSeries[len(blockedSeries)-dnsStatsHoursSpan:]
	} else if len(blockedSeries) < dnsStatsHoursSpan {
		blockedSeries = append(make([]int, dnsStatsHoursSpan-len(blockedSeries)), blockedSeries...)
	}
	maxQueriesInSeries := 0
	for i := range dnsStatsBars {
		queries := 0
		blocked := 0
		for j := range dnsStatsHoursPerBar {
			queries += queriesSeries[i*dnsStatsHoursPerBar+j]
			blocked += blockedSeries[i*dnsStatsHoursPerBar+j]
		}
		stats.Series[i] = dnsStatsSeries{
			Queries: queries,
			Blocked: blocked,
		}
		if queries > 0 {
			stats.Series[i].PercentBlocked = int(float64(blocked) / float64(queries) * 100)
		}
		if queries > maxQueriesInSeries {
			maxQueriesInSeries = queries
		}
	}
	for i := range dnsStatsBars {
		stats.Series[i].PercentTotal = int(float64(stats.Series[i].Queries) / float64(maxQueriesInSeries) * 100)
	}
	return stats, nil
}
// Legacy Pi-hole stats response (before v6)
type pihole5StatsResponse struct {
	TotalQueries      int                      `json:"dns_queries_today"`
	QueriesSeries     pihole5QueriesSeries     `json:"domains_over_time"`
	BlockedQueries    int                      `json:"ads_blocked_today"`
	BlockedSeries     map[int64]int            `json:"ads_over_time"`
	BlockedPercentage float64                  `json:"ads_percentage_today"`
	TopBlockedDomains pihole5TopBlockedDomains `json:"top_ads"`
	DomainsBlocked    int                      `json:"domains_being_blocked"`
}
// If the user has query logging disabled it's possible for domains_over_time to be returned as an
// empty array rather than a map which will prevent unmashalling the rest of the data so we use
// custom unmarshal behavior to fallback to an empty map.
// See https://github.com/glanceapp/glance/issues/289
type pihole5QueriesSeries map[int64]int
func (p *pihole5QueriesSeries) UnmarshalJSON(data []byte) error {
	temp := make(map[int64]int)
	err := json.Unmarshal(data, &temp)
	if err != nil {
		*p = make(pihole5QueriesSeries)
	} else {
		*p = temp
	}
	return nil
}
// If user has some level of privacy enabled on Pihole, `json:"top_ads"` is an empty array
// Use custom unmarshal behavior to avoid not getting the rest of the valid data when unmarshalling
type pihole5TopBlockedDomains map[string]int
func (p *pihole5TopBlockedDomains) UnmarshalJSON(data []byte) error {
	// NOTE: do not change to piholeTopBlockedDomains type here or it will cause a stack overflow
	// because of the UnmarshalJSON method getting called recursively
	temp := make(map[string]int)
	err := json.Unmarshal(data, &temp)
	if err != nil {
		*p = make(pihole5TopBlockedDomains)
	} else {
		*p = temp
	}
	return nil
}
func fetchPihole5Stats(instanceURL string, allowInsecure bool, token string, noGraph bool) (*dnsStats, error) {
	if token == "" {
		return nil, errors.New("missing API token")
	}
	requestURL := strings.TrimRight(instanceURL, "/") +
		"/admin/api.php?summaryRaw&topItems&overTimeData10mins&auth=" + token
	request, err := http.NewRequest("GET", requestURL, nil)
	if err != nil {
		return nil, err
	}
	var client = ternary(allowInsecure, defaultInsecureHTTPClient, defaultHTTPClient)
	responseJson, err := decodeJsonFromRequest[pihole5StatsResponse](client, request)
	if err != nil {
		return nil, err
	}
	stats := &dnsStats{
		TotalQueries:   responseJson.TotalQueries,
		BlockedQueries: responseJson.BlockedQueries,
		BlockedPercent: int(responseJson.BlockedPercentage),
		DomainsBlocked: responseJson.DomainsBlocked,
	}
	if len(responseJson.TopBlockedDomains) > 0 {
		domains := make([]dnsStatsBlockedDomain, 0, len(responseJson.TopBlockedDomains))
		for domain, count := range responseJson.TopBlockedDomains {
			domains = append(domains, dnsStatsBlockedDomain{
				Domain:         domain,
				PercentBlocked: int(float64(count) / float64(responseJson.BlockedQueries) * 100),
			})
		}
		sort.Slice(domains, func(a, b int) bool {
			return domains[a].PercentBlocked > domains[b].PercentBlocked
		})
		stats.TopBlockedDomains = domains[:min(len(domains), 5)]
	}
	if noGraph {
		return stats, nil
	}
	// Pihole _should_ return data for the last 24 hours in a 10 minute interval, 6*24 = 144
	if len(responseJson.QueriesSeries) != 144 || len(responseJson.BlockedSeries) != 144 {
		slog.Warn(
			"DNS stats for pihole: did not get expected 144 data points",
			"len(queries)", len(responseJson.QueriesSeries),
			"len(blocked)", len(responseJson.BlockedSeries),
		)
		return stats, nil
	}
	var lowestTimestamp int64 = 0
	for timestamp := range responseJson.QueriesSeries {
		if lowestTimestamp == 0 || timestamp < lowestTimestamp {
			lowestTimestamp = timestamp
		}
	}
	maxQueriesInSeries := 0
	for i := range dnsStatsBars {
		queries := 0
		blocked := 0
		for j := range 18 {
			index := lowestTimestamp + int64(i*10800+j*600)
			queries += responseJson.QueriesSeries[index]
			blocked += responseJson.BlockedSeries[index]
		}
		if queries > maxQueriesInSeries {
			maxQueriesInSeries = queries
		}
		stats.Series[i] = dnsStatsSeries{
			Queries: queries,
			Blocked: blocked,
		}
		if queries > 0 {
			stats.Series[i].PercentBlocked = int(float64(blocked) / float64(queries) * 100)
		}
	}
	for i := range dnsStatsBars {
		stats.Series[i].PercentTotal = int(float64(stats.Series[i].Queries) / float64(maxQueriesInSeries) * 100)
	}
	return stats, nil
}
func fetchPiholeStats(
	instanceURL string,
	allowInsecure bool,
	password string,
	sessionID string,
	includeGraph bool,
	includeTopDomains bool,
) (*dnsStats, string, error) {
	instanceURL = strings.TrimRight(instanceURL, "/")
	var client = ternary(allowInsecure, defaultInsecureHTTPClient, defaultHTTPClient)
	fetchNewSessionID := func() error {
		newSessionID, err := fetchPiholeSessionID(instanceURL, client, password)
		if err != nil {
			return err
		}
		sessionID = newSessionID
		return nil
	}
	if sessionID == "" {
		if err := fetchNewSessionID(); err != nil {
			slog.Error("Failed to fetch Pihole v6 session ID", "error", err)
			return nil, "", fmt.Errorf("fetching session ID: %v", err)
		}
	} else {
		isValid, err := checkPiholeSessionIDIsValid(instanceURL, client, sessionID)
		if err != nil {
			slog.Error("Failed to check Pihole v6 session ID validity", "error", err)
			return nil, "", fmt.Errorf("checking session ID: %v", err)
		}
		if !isValid {
			if err := fetchNewSessionID(); err != nil {
				slog.Error("Failed to renew Pihole v6 session ID", "error", err)
				return nil, "", fmt.Errorf("renewing session ID: %v", err)
			}
		}
	}
	var wg sync.WaitGroup
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()
	type statsResponseJson struct {
		Queries struct {
			Total          int     `json:"total"`
			Blocked        int     `json:"blocked"`
			PercentBlocked float64 `json:"percent_blocked"`
		} `json:"queries"`
		Gravity struct {
			DomainsBlocked int `json:"domains_being_blocked"`
		} `json:"gravity"`
	}
	statsRequest, _ := http.NewRequestWithContext(ctx, "GET", instanceURL+"/api/stats/summary", nil)
	statsRequest.Header.Set("x-ftl-sid", sessionID)
	var statsResponse statsResponseJson
	var statsErr error
	wg.Add(1)
	go func() {
		defer wg.Done()
		statsResponse, statsErr = decodeJsonFromRequest[statsResponseJson](client, statsRequest)
		if statsErr != nil {
			cancel()
		}
	}()
	type seriesResponseJson struct {
		History []struct {
			Timestamp int64 `json:"timestamp"`
			Total     int   `json:"total"`
			Blocked   int   `json:"blocked"`
		} `json:"history"`
	}
	var seriesResponse seriesResponseJson
	var seriesErr error
	if includeGraph {
		seriesRequest, _ := http.NewRequestWithContext(ctx, "GET", instanceURL+"/api/history", nil)
		seriesRequest.Header.Set("x-ftl-sid", sessionID)
		wg.Add(1)
		go func() {
			defer wg.Done()
			seriesResponse, seriesErr = decodeJsonFromRequest[seriesResponseJson](client, seriesRequest)
		}()
	}
	type topDomainsResponseJson struct {
		Domains []struct {
			Domain string `json:"domain"`
			Count  int    `json:"count"`
		} `json:"domains"`
		TotalQueries   int     `json:"total_queries"`
		BlockedQueries int     `json:"blocked_queries"`
		Took           float64 `json:"took"`
	}
	var topDomainsResponse topDomainsResponseJson
	var topDomainsErr error
	if includeTopDomains {
		topDomainsRequest, _ := http.NewRequestWithContext(ctx, "GET", instanceURL+"/api/stats/top_domains?blocked=true", nil)
		topDomainsRequest.Header.Set("x-ftl-sid", sessionID)
		wg.Add(1)
		go func() {
			defer wg.Done()
			topDomainsResponse, topDomainsErr = decodeJsonFromRequest[topDomainsResponseJson](client, topDomainsRequest)
		}()
	}
	wg.Wait()
	partialContent := false
	if statsErr != nil {
		return nil, "", fmt.Errorf("fetching stats: %v", statsErr)
	}
	if includeGraph && seriesErr != nil {
		slog.Error("Failed to fetch Pihole v6 graph data", "error", seriesErr)
		partialContent = true
	}
	if includeTopDomains && topDomainsErr != nil {
		slog.Error("Failed to fetch Pihole v6 top domains", "error", topDomainsErr)
		partialContent = true
	}
	stats := &dnsStats{
		TotalQueries:   statsResponse.Queries.Total,
		BlockedQueries: statsResponse.Queries.Blocked,
		BlockedPercent: int(statsResponse.Queries.PercentBlocked),
		DomainsBlocked: statsResponse.Gravity.DomainsBlocked,
	}
	if includeGraph && seriesErr == nil {
		if len(seriesResponse.History) != 145 {
			slog.Error(
				"Pihole v6 graph data has unexpected length",
				"length", len(seriesResponse.History),
				"expected", 145,
			)
			partialContent = true
		} else {
			// The API from v5 used to return 144 data points, but v6 returns 145.
			// We only show data from the last 24 hours hours, Pihole returns data
			// points in a 10 minute interval, 24*(60/10) = 144. Why is there an extra
			// data point? I don't know, but we'll just ignore the first one since it's
			// the oldest data point.
			history := seriesResponse.History[1:]
			const interval = 10
			const dataPointsPerBar = dnsStatsHoursPerBar * (60 / interval)
			maxQueriesInSeries := 0
			for i := range dnsStatsBars {
				queries := 0
				blocked := 0
				for j := range dataPointsPerBar {
					index := i*dataPointsPerBar + j
					queries += history[index].Total
					blocked += history[index].Blocked
				}
				if queries > maxQueriesInSeries {
					maxQueriesInSeries = queries
				}
				stats.Series[i] = dnsStatsSeries{
					Queries: queries,
					Blocked: blocked,
				}
				if queries > 0 {
					stats.Series[i].PercentBlocked = int(float64(blocked) / float64(queries) * 100)
				}
			}
			for i := range dnsStatsBars {
				stats.Series[i].PercentTotal = int(float64(stats.Series[i].Queries) / float64(maxQueriesInSeries) * 100)
			}
		}
	}
	if includeTopDomains && topDomainsErr == nil && len(topDomainsResponse.Domains) > 0 {
		domains := make([]dnsStatsBlockedDomain, 0, len(topDomainsResponse.Domains))
		for i := range topDomainsResponse.Domains {
			d := &topDomainsResponse.Domains[i]
			domains = append(domains, dnsStatsBlockedDomain{
				Domain:         d.Domain,
				PercentBlocked: int(float64(d.Count) / float64(statsResponse.Queries.Blocked) * 100),
			})
		}
		sort.Slice(domains, func(a, b int) bool {
			return domains[a].PercentBlocked > domains[b].PercentBlocked
		})
		stats.TopBlockedDomains = domains[:min(len(domains), 5)]
	}
	return stats, sessionID, ternary(partialContent, errPartialContent, nil)
}
func fetchPiholeSessionID(instanceURL string, client *http.Client, password string) (string, error) {
	requestBody := []byte(`{"password":"` + password + `"}`)
	request, err := http.NewRequest("POST", instanceURL+"/api/auth", bytes.NewBuffer(requestBody))
	if err != nil {
		return "", fmt.Errorf("creating authentication request: %v", err)
	}
	request.Header.Set("Content-Type", "application/json")
	response, err := client.Do(request)
	if err != nil {
		return "", fmt.Errorf("sending authentication request: %v", err)
	}
	defer response.Body.Close()
	body, err := io.ReadAll(response.Body)
	if err != nil {
		return "", fmt.Errorf("reading authentication response: %v", err)
	}
	var jsonResponse struct {
		Session struct {
			SID     string `json:"sid"`
			Message string `json:"message"`
		} `json:"session"`
	}
	if err := json.Unmarshal(body, &jsonResponse); err != nil {
		return "", fmt.Errorf("parsing authentication response: %v", err)
	}
	if response.StatusCode != http.StatusOK {
		return "", fmt.Errorf(
			"authentication request returned status %s with message '%s'",
			response.Status, jsonResponse.Session.Message,
		)
	}
	if jsonResponse.Session.SID == "" {
		return "", fmt.Errorf(
			"authentication response returned empty session ID, status code %d, message '%s'",
			response.StatusCode, jsonResponse.Session.Message,
		)
	}
	return jsonResponse.Session.SID, nil
}
func checkPiholeSessionIDIsValid(instanceURL string, client *http.Client, sessionID string) (bool, error) {
	request, err := http.NewRequest("GET", instanceURL+"/api/auth", nil)
	if err != nil {
		return false, fmt.Errorf("creating session ID check request: %v", err)
	}
	request.Header.Set("x-ftl-sid", sessionID)
	response, err := client.Do(request)
	if err != nil {
		return false, err
	}
	defer response.Body.Close()
	if response.StatusCode != http.StatusOK && response.StatusCode != http.StatusUnauthorized {
		return false, fmt.Errorf("session ID check request returned status %s", response.Status)
	}
	return response.StatusCode == http.StatusOK, nil
}
type technitiumStatsResponse struct {
	Response struct {
		Stats struct {
			TotalQueries   int `json:"totalQueries"`
			BlockedQueries int `json:"totalBlocked"`
			BlockedZones   int `json:"blockedZones"`
			BlockListZones int `json:"blockListZones"`
		} `json:"stats"`
		MainChartData struct {
			Datasets []struct {
				Label string `json:"label"`
				Data  []int  `json:"data"`
			} `json:"datasets"`
		} `json:"mainChartData"`
		TopBlockedDomains []struct {
			Domain string `json:"name"`
			Count  int    `json:"hits"`
		}
	} `json:"response"`
}
func fetchTechnitiumStats(instanceUrl string, allowInsecure bool, token string, noGraph bool) (*dnsStats, error) {
	if token == "" {
		return nil, errors.New("missing API token")
	}
	requestURL := strings.TrimRight(instanceUrl, "/") + "/api/dashboard/stats/get?token=" + token + "&type=LastDay"
	request, err := http.NewRequest("GET", requestURL, nil)
	if err != nil {
		return nil, err
	}
	var client requestDoer
	if !allowInsecure {
		client = defaultHTTPClient
	} else {
		client = defaultInsecureHTTPClient
	}
	responseJson, err := decodeJsonFromRequest[technitiumStatsResponse](client, request)
	if err != nil {
		return nil, err
	}
	var topBlockedDomainsCount = min(len(responseJson.Response.TopBlockedDomains), 5)
	stats := &dnsStats{
		TotalQueries:      responseJson.Response.Stats.TotalQueries,
		BlockedQueries:    responseJson.Response.Stats.BlockedQueries,
		TopBlockedDomains: make([]dnsStatsBlockedDomain, 0, topBlockedDomainsCount),
		DomainsBlocked:    responseJson.Response.Stats.BlockedZones + responseJson.Response.Stats.BlockListZones,
	}
	if stats.TotalQueries <= 0 {
		return stats, nil
	}
	stats.BlockedPercent = int(float64(responseJson.Response.Stats.BlockedQueries) / float64(responseJson.Response.Stats.TotalQueries) * 100)
	for i := 0; i < topBlockedDomainsCount; i++ {
		domain := responseJson.Response.TopBlockedDomains[i]
		firstDomain := domain.Domain
		if firstDomain == "" {
			continue
		}
		stats.TopBlockedDomains = append(stats.TopBlockedDomains, dnsStatsBlockedDomain{
			Domain: firstDomain,
		})
		if stats.BlockedQueries > 0 {
			stats.TopBlockedDomains[i].PercentBlocked = int(float64(domain.Count) / float64(responseJson.Response.Stats.BlockedQueries) * 100)
		}
	}
	if noGraph {
		return stats, nil
	}
	var queriesSeries, blockedSeries []int
	for _, label := range responseJson.Response.MainChartData.Datasets {
		switch label.Label {
		case "Total":
			queriesSeries = label.Data
		case "Blocked":
			blockedSeries = label.Data
		}
	}
	if len(queriesSeries) > dnsStatsHoursSpan {
		queriesSeries = queriesSeries[len(queriesSeries)-dnsStatsHoursSpan:]
	} else if len(queriesSeries) < dnsStatsHoursSpan {
		queriesSeries = append(make([]int, dnsStatsHoursSpan-len(queriesSeries)), queriesSeries...)
	}
	if len(blockedSeries) > dnsStatsHoursSpan {
		blockedSeries = blockedSeries[len(blockedSeries)-dnsStatsHoursSpan:]
	} else if len(blockedSeries) < dnsStatsHoursSpan {
		blockedSeries = append(make([]int, dnsStatsHoursSpan-len(blockedSeries)), blockedSeries...)
	}
	maxQueriesInSeries := 0
	for i := 0; i < dnsStatsBars; i++ {
		queries := 0
		blocked := 0
		for j := 0; j < dnsStatsHoursPerBar; j++ {
			queries += queriesSeries[i*dnsStatsHoursPerBar+j]
			blocked += blockedSeries[i*dnsStatsHoursPerBar+j]
		}
		stats.Series[i] = dnsStatsSeries{
			Queries: queries,
			Blocked: blocked,
		}
		if queries > 0 {
			stats.Series[i].PercentBlocked = int(float64(blocked) / float64(queries) * 100)
		}
		if queries > maxQueriesInSeries {
			maxQueriesInSeries = queries
		}
	}
	for i := 0; i < dnsStatsBars; i++ {
		stats.Series[i].PercentTotal = int(float64(stats.Series[i].Queries) / float64(maxQueriesInSeries) * 100)
	}
	return stats, nil
}
</file>

<file path="internal/glance/widget-docker-containers.go">
package glance
import (
	"context"
	"encoding/json"
	"fmt"
	"html/template"
	"net"
	"net/http"
	"net/url"
	"sort"
	"strings"
	"time"
)
var dockerContainersWidgetTemplate = mustParseTemplate("docker-containers.html", "widget-base.html")
type dockerContainersWidget struct {
	widgetBase           `yaml:",inline"`
	HideByDefault        bool                         `yaml:"hide-by-default"`
	RunningOnly          bool                         `yaml:"running-only"`
	Category             string                       `yaml:"category"`
	SockPath             string                       `yaml:"sock-path"`
	FormatContainerNames bool                         `yaml:"format-container-names"`
	Containers           dockerContainerList          `yaml:"-"`
	LabelOverrides       map[string]map[string]string `yaml:"containers"`
}
func (widget *dockerContainersWidget) initialize() error {
	widget.withTitle("Docker Containers").withCacheDuration(1 * time.Minute)
	if widget.SockPath == "" {
		widget.SockPath = "/var/run/docker.sock"
	}
	return nil
}
func (widget *dockerContainersWidget) update(ctx context.Context) {
	containers, err := fetchDockerContainers(
		widget.SockPath,
		widget.HideByDefault,
		widget.Category,
		widget.RunningOnly,
		widget.FormatContainerNames,
		widget.LabelOverrides,
	)
	if !widget.canContinueUpdateAfterHandlingErr(err) {
		return
	}
	containers.sortByStateIconThenTitle()
	widget.Containers = containers
}
func (widget *dockerContainersWidget) Render() template.HTML {
	return widget.renderTemplate(widget, dockerContainersWidgetTemplate)
}
const (
	dockerContainerLabelHide        = "glance.hide"
	dockerContainerLabelName        = "glance.name"
	dockerContainerLabelURL         = "glance.url"
	dockerContainerLabelDescription = "glance.description"
	dockerContainerLabelSameTab     = "glance.same-tab"
	dockerContainerLabelIcon        = "glance.icon"
	dockerContainerLabelID          = "glance.id"
	dockerContainerLabelParent      = "glance.parent"
	dockerContainerLabelCategory    = "glance.category"
)
const (
	dockerContainerStateIconOK     = "ok"
	dockerContainerStateIconPaused = "paused"
	dockerContainerStateIconWarn   = "warn"
	dockerContainerStateIconOther  = "other"
)
var dockerContainerStateIconPriorities = map[string]int{
	dockerContainerStateIconWarn:   0,
	dockerContainerStateIconOther:  1,
	dockerContainerStateIconPaused: 2,
	dockerContainerStateIconOK:     3,
}
type dockerContainerJsonResponse struct {
	Names  []string              `json:"Names"`
	Image  string                `json:"Image"`
	State  string                `json:"State"`
	Status string                `json:"Status"`
	Labels dockerContainerLabels `json:"Labels"`
}
type dockerContainerLabels map[string]string
func (l *dockerContainerLabels) getOrDefault(label, def string) string {
	if l == nil {
		return def
	}
	v, ok := (*l)[label]
	if !ok {
		return def
	}
	if v == "" {
		return def
	}
	return v
}
type dockerContainer struct {
	Name        string
	URL         string
	SameTab     bool
	Image       string
	State       string
	StateText   string
	StateIcon   string
	Description string
	Icon        customIconField
	Children    dockerContainerList
}
type dockerContainerList []dockerContainer
func (containers dockerContainerList) sortByStateIconThenTitle() {
	p := &dockerContainerStateIconPriorities
	sort.SliceStable(containers, func(a, b int) bool {
		if containers[a].StateIcon != containers[b].StateIcon {
			return (*p)[containers[a].StateIcon] < (*p)[containers[b].StateIcon]
		}
		return strings.ToLower(containers[a].Name) < strings.ToLower(containers[b].Name)
	})
}
func dockerContainerStateToStateIcon(state string) string {
	switch state {
	case "running":
		return dockerContainerStateIconOK
	case "paused":
		return dockerContainerStateIconPaused
	case "exited", "unhealthy", "dead":
		return dockerContainerStateIconWarn
	default:
		return dockerContainerStateIconOther
	}
}
func fetchDockerContainers(
	socketPath string,
	hideByDefault bool,
	category string,
	runningOnly bool,
	formatNames bool,
	labelOverrides map[string]map[string]string,
) (dockerContainerList, error) {
	containers, err := fetchDockerContainersFromSource(socketPath, category, runningOnly, labelOverrides)
	if err != nil {
		return nil, fmt.Errorf("fetching containers: %w", err)
	}
	containers, children := groupDockerContainerChildren(containers, hideByDefault)
	dockerContainers := make(dockerContainerList, 0, len(containers))
	for i := range containers {
		container := &containers[i]
		dc := dockerContainer{
			Name:        deriveDockerContainerName(container, formatNames),
			URL:         container.Labels.getOrDefault(dockerContainerLabelURL, ""),
			Description: container.Labels.getOrDefault(dockerContainerLabelDescription, ""),
			SameTab:     stringToBool(container.Labels.getOrDefault(dockerContainerLabelSameTab, "false")),
			Image:       container.Image,
			State:       strings.ToLower(container.State),
			StateText:   strings.ToLower(container.Status),
			Icon:        newCustomIconField(container.Labels.getOrDefault(dockerContainerLabelIcon, "si:docker")),
		}
		if idValue := container.Labels.getOrDefault(dockerContainerLabelID, ""); idValue != "" {
			if children, ok := children[idValue]; ok {
				for i := range children {
					child := &children[i]
					dc.Children = append(dc.Children, dockerContainer{
						Name:      deriveDockerContainerName(child, formatNames),
						StateText: child.Status,
						StateIcon: dockerContainerStateToStateIcon(strings.ToLower(child.State)),
					})
				}
			}
		}
		dc.Children.sortByStateIconThenTitle()
		stateIconSupersededByChild := false
		for i := range dc.Children {
			if dc.Children[i].StateIcon == dockerContainerStateIconWarn {
				dc.StateIcon = dockerContainerStateIconWarn
				stateIconSupersededByChild = true
				break
			}
		}
		if !stateIconSupersededByChild {
			dc.StateIcon = dockerContainerStateToStateIcon(dc.State)
		}
		dockerContainers = append(dockerContainers, dc)
	}
	return dockerContainers, nil
}
func deriveDockerContainerName(container *dockerContainerJsonResponse, formatNames bool) string {
	if v := container.Labels.getOrDefault(dockerContainerLabelName, ""); v != "" {
		return v
	}
	if len(container.Names) == 0 || container.Names[0] == "" {
		return "n/a"
	}
	name := strings.TrimLeft(container.Names[0], "/")
	if formatNames {
		name = strings.ReplaceAll(name, "_", " ")
		name = strings.ReplaceAll(name, "-", " ")
		words := strings.Split(name, " ")
		for i := range words {
			if len(words[i]) > 0 {
				words[i] = strings.ToUpper(words[i][:1]) + words[i][1:]
			}
		}
		name = strings.Join(words, " ")
	}
	return name
}
func groupDockerContainerChildren(
	containers []dockerContainerJsonResponse,
	hideByDefault bool,
) (
	[]dockerContainerJsonResponse,
	map[string][]dockerContainerJsonResponse,
) {
	parents := make([]dockerContainerJsonResponse, 0, len(containers))
	children := make(map[string][]dockerContainerJsonResponse)
	for i := range containers {
		container := &containers[i]
		if isDockerContainerHidden(container, hideByDefault) {
			continue
		}
		isParent := container.Labels.getOrDefault(dockerContainerLabelID, "") != ""
		parent := container.Labels.getOrDefault(dockerContainerLabelParent, "")
		if !isParent && parent != "" {
			children[parent] = append(children[parent], *container)
		} else {
			parents = append(parents, *container)
		}
	}
	return parents, children
}
func isDockerContainerHidden(container *dockerContainerJsonResponse, hideByDefault bool) bool {
	if v := container.Labels.getOrDefault(dockerContainerLabelHide, ""); v != "" {
		return stringToBool(v)
	}
	return hideByDefault
}
func fetchDockerContainersFromSource(
	source string,
	category string,
	runningOnly bool,
	labelOverrides map[string]map[string]string,
) ([]dockerContainerJsonResponse, error) {
	var hostname string
	var client *http.Client
	if strings.HasPrefix(source, "tcp://") || strings.HasPrefix(source, "http://") {
		client = &http.Client{}
		parsed, err := url.Parse(source)
		if err != nil {
			return nil, fmt.Errorf("parsing URL: %w", err)
		}
		port := parsed.Port()
		if port == "" {
			port = "80"
		}
		hostname = parsed.Hostname() + ":" + port
	} else {
		hostname = "docker"
		client = &http.Client{
			Transport: &http.Transport{
				DialContext: func(_ context.Context, _, _ string) (net.Conn, error) {
					return net.Dial("unix", source)
				},
			},
		}
	}
	fetchAll := ternary(runningOnly, "false", "true")
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	request, err := http.NewRequestWithContext(ctx, "GET", "http://"+hostname+"/containers/json?all="+fetchAll, nil)
	if err != nil {
		return nil, fmt.Errorf("creating request: %w", err)
	}
	response, err := client.Do(request)
	if err != nil {
		return nil, fmt.Errorf("sending request to socket: %w", err)
	}
	defer response.Body.Close()
	if response.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("non-200 response status: %s", response.Status)
	}
	var containers []dockerContainerJsonResponse
	if err := json.NewDecoder(response.Body).Decode(&containers); err != nil {
		return nil, fmt.Errorf("decoding response: %w", err)
	}
	for i := range containers {
		container := &containers[i]
		name := strings.TrimLeft(itemAtIndexOrDefault(container.Names, 0, ""), "/")
		if name == "" {
			continue
		}
		overrides, ok := labelOverrides[name]
		if !ok {
			continue
		}
		if container.Labels == nil {
			container.Labels = make(dockerContainerLabels)
		}
		for label, value := range overrides {
			container.Labels["glance."+label] = value
		}
	}
	// We have to filter here instead of using the `filters` parameter of Docker's API
	// because the user may define a category override within their config
	if category != "" {
		filtered := make([]dockerContainerJsonResponse, 0, len(containers))
		for i := range containers {
			container := &containers[i]
			if container.Labels.getOrDefault(dockerContainerLabelCategory, "") == category {
				filtered = append(filtered, *container)
			}
		}
		containers = filtered
	}
	return containers, nil
}
</file>

<file path="internal/glance/widget-extension.go">
package glance
import (
	"context"
	"errors"
	"fmt"
	"html"
	"html/template"
	"io"
	"log/slog"
	"net/http"
	"net/url"
	"time"
)
var extensionWidgetTemplate = mustParseTemplate("extension.html", "widget-base.html")
const extensionWidgetDefaultTitle = "Extension"
type extensionWidget struct {
	widgetBase          `yaml:",inline"`
	URL                 string               `yaml:"url"`
	FallbackContentType string               `yaml:"fallback-content-type"`
	Parameters          queryParametersField `yaml:"parameters"`
	Headers             map[string]string    `yaml:"headers"`
	AllowHtml           bool                 `yaml:"allow-potentially-dangerous-html"`
	Extension           extension            `yaml:"-"`
	cachedHTML          template.HTML        `yaml:"-"`
}
func (widget *extensionWidget) initialize() error {
	widget.withTitle(extensionWidgetDefaultTitle).withCacheDuration(time.Minute * 30)
	if widget.URL == "" {
		return errors.New("URL is required")
	}
	if _, err := url.Parse(widget.URL); err != nil {
		return fmt.Errorf("parsing URL: %v", err)
	}
	return nil
}
func (widget *extensionWidget) update(ctx context.Context) {
	extension, err := fetchExtension(extensionRequestOptions{
		URL:                 widget.URL,
		FallbackContentType: widget.FallbackContentType,
		Parameters:          widget.Parameters,
		Headers:             widget.Headers,
		AllowHtml:           widget.AllowHtml,
	})
	widget.canContinueUpdateAfterHandlingErr(err)
	widget.Extension = extension
	if widget.Title == extensionWidgetDefaultTitle && extension.Title != "" {
		widget.Title = extension.Title
	}
	if widget.TitleURL == "" && extension.TitleURL != "" {
		widget.TitleURL = extension.TitleURL
	}
	widget.cachedHTML = widget.renderTemplate(widget, extensionWidgetTemplate)
}
func (widget *extensionWidget) Render() template.HTML {
	return widget.cachedHTML
}
type extensionType int
const (
	extensionContentHTML extensionType = iota
	extensionContentUnknown
)
var extensionStringToType = map[string]extensionType{
	"html": extensionContentHTML,
}
const (
	extensionHeaderTitle            = "Widget-Title"
	extensionHeaderTitleURL         = "Widget-Title-URL"
	extensionHeaderContentType      = "Widget-Content-Type"
	extensionHeaderContentFrameless = "Widget-Content-Frameless"
)
type extensionRequestOptions struct {
	URL                 string               `yaml:"url"`
	FallbackContentType string               `yaml:"fallback-content-type"`
	Parameters          queryParametersField `yaml:"parameters"`
	Headers             map[string]string    `yaml:"headers"`
	AllowHtml           bool                 `yaml:"allow-potentially-dangerous-html"`
}
type extension struct {
	Title     string
	TitleURL  string
	Content   template.HTML
	Frameless bool
}
func convertExtensionContent(options extensionRequestOptions, content []byte, contentType extensionType) template.HTML {
	switch contentType {
	case extensionContentHTML:
		if options.AllowHtml {
			return template.HTML(content)
		}
		fallthrough
	default:
		return template.HTML("<pre>" + html.EscapeString(string(content)) + "</pre>")
	}
}
func fetchExtension(options extensionRequestOptions) (extension, error) {
	request, _ := http.NewRequest("GET", options.URL, nil)
	if len(options.Parameters) > 0 {
		request.URL.RawQuery = options.Parameters.toQueryString()
	}
	for key, value := range options.Headers {
		request.Header.Add(key, value)
	}
	response, err := http.DefaultClient.Do(request)
	if err != nil {
		slog.Error("Failed fetching extension", "url", options.URL, "error", err)
		return extension{}, fmt.Errorf("%w: request failed: %w", errNoContent, err)
	}
	defer response.Body.Close()
	body, err := io.ReadAll(response.Body)
	if err != nil {
		slog.Error("Failed reading response body of extension", "url", options.URL, "error", err)
		return extension{}, fmt.Errorf("%w: could not read body: %w", errNoContent, err)
	}
	extension := extension{}
	if response.Header.Get(extensionHeaderTitle) == "" {
		extension.Title = "Extension"
	} else {
		extension.Title = response.Header.Get(extensionHeaderTitle)
	}
	if response.Header.Get(extensionHeaderTitleURL) != "" {
		extension.TitleURL = response.Header.Get(extensionHeaderTitleURL)
	}
	contentType, ok := extensionStringToType[response.Header.Get(extensionHeaderContentType)]
	if !ok {
		contentType, ok = extensionStringToType[options.FallbackContentType]
		if !ok {
			contentType = extensionContentUnknown
		}
	}
	if stringToBool(response.Header.Get(extensionHeaderContentFrameless)) {
		extension.Frameless = true
	}
	extension.Content = convertExtensionContent(options, body, contentType)
	return extension, nil
}
</file>

<file path="internal/glance/widget-markets.go">
package glance
import (
	"context"
	"fmt"
	"html/template"
	"log/slog"
	"math"
	"net/http"
	"sort"
	"strings"
	"time"
)
var marketsWidgetTemplate = mustParseTemplate("markets.html", "widget-base.html")
type marketsWidget struct {
	widgetBase         `yaml:",inline"`
	StocksRequests     []marketRequest `yaml:"stocks"`
	MarketRequests     []marketRequest `yaml:"markets"`
	ChartLinkTemplate  string          `yaml:"chart-link-template"`
	SymbolLinkTemplate string          `yaml:"symbol-link-template"`
	Sort               string          `yaml:"sort-by"`
	Markets            marketList      `yaml:"-"`
}
func (widget *marketsWidget) initialize() error {
	widget.withTitle("Markets").withCacheDuration(time.Hour)
	// legacy support, remove in v0.10.0
	if len(widget.MarketRequests) == 0 {
		widget.MarketRequests = widget.StocksRequests
	}
	for i := range widget.MarketRequests {
		m := &widget.MarketRequests[i]
		if widget.ChartLinkTemplate != "" && m.ChartLink == "" {
			m.ChartLink = strings.ReplaceAll(widget.ChartLinkTemplate, "{SYMBOL}", m.Symbol)
		}
		if widget.SymbolLinkTemplate != "" && m.SymbolLink == "" {
			m.SymbolLink = strings.ReplaceAll(widget.SymbolLinkTemplate, "{SYMBOL}", m.Symbol)
		}
	}
	return nil
}
func (widget *marketsWidget) update(ctx context.Context) {
	markets, err := fetchMarketsDataFromYahoo(widget.MarketRequests)
	if !widget.canContinueUpdateAfterHandlingErr(err) {
		return
	}
	if widget.Sort == "absolute-change" {
		markets.sortByAbsChange()
	} else if widget.Sort == "change" {
		markets.sortByChange()
	}
	widget.Markets = markets
}
func (widget *marketsWidget) Render() template.HTML {
	return widget.renderTemplate(widget, marketsWidgetTemplate)
}
type marketRequest struct {
	CustomName string `yaml:"name"`
	Symbol     string `yaml:"symbol"`
	ChartLink  string `yaml:"chart-link"`
	SymbolLink string `yaml:"symbol-link"`
}
type market struct {
	marketRequest
	Name           string
	Currency       string
	Price          float64
	PriceHint      int
	PercentChange  float64
	SvgChartPoints string
}
type marketList []market
func (t marketList) sortByAbsChange() {
	sort.Slice(t, func(i, j int) bool {
		return math.Abs(t[i].PercentChange) > math.Abs(t[j].PercentChange)
	})
}
func (t marketList) sortByChange() {
	sort.Slice(t, func(i, j int) bool {
		return t[i].PercentChange > t[j].PercentChange
	})
}
type marketResponseJson struct {
	Chart struct {
		Result []struct {
			Meta struct {
				Currency           string  `json:"currency"`
				Symbol             string  `json:"symbol"`
				RegularMarketPrice float64 `json:"regularMarketPrice"`
				ChartPreviousClose float64 `json:"chartPreviousClose"`
				ShortName          string  `json:"shortName"`
				PriceHint          int     `json:"priceHint"`
			} `json:"meta"`
			Indicators struct {
				Quote []struct {
					Close []float64 `json:"close,omitempty"`
				} `json:"quote"`
			} `json:"indicators"`
		} `json:"result"`
	} `json:"chart"`
}
// TODO: allow changing chart time frame
const marketChartDays = 21
func fetchMarketsDataFromYahoo(marketRequests []marketRequest) (marketList, error) {
	requests := make([]*http.Request, 0, len(marketRequests))
	for i := range marketRequests {
		request, _ := http.NewRequest("GET", fmt.Sprintf("https://query1.finance.yahoo.com/v8/finance/chart/%s?range=1mo&interval=1d", marketRequests[i].Symbol), nil)
		setBrowserUserAgentHeader(request)
		requests = append(requests, request)
	}
	job := newJob(decodeJsonFromRequestTask[marketResponseJson](defaultHTTPClient), requests)
	responses, errs, err := workerPoolDo(job)
	if err != nil {
		return nil, fmt.Errorf("%w: %v", errNoContent, err)
	}
	markets := make(marketList, 0, len(responses))
	var failed int
	for i := range responses {
		if errs[i] != nil {
			failed++
			slog.Error("Failed to fetch market data", "symbol", marketRequests[i].Symbol, "error", errs[i])
			continue
		}
		response := responses[i]
		if len(response.Chart.Result) == 0 {
			failed++
			slog.Error("Market response contains no data", "symbol", marketRequests[i].Symbol)
			continue
		}
		result := &response.Chart.Result[0]
		prices := result.Indicators.Quote[0].Close
		if len(prices) > marketChartDays {
			prices = prices[len(prices)-marketChartDays:]
		}
		previous := result.Meta.RegularMarketPrice
		if len(prices) >= 2 && prices[len(prices)-2] != 0 {
			previous = prices[len(prices)-2]
		}
		points := svgPolylineCoordsFromYValues(100, 50, maybeCopySliceWithoutZeroValues(prices))
		currency, exists := currencyToSymbol[strings.ToUpper(result.Meta.Currency)]
		if !exists {
			currency = result.Meta.Currency
		}
		markets = append(markets, market{
			marketRequest: marketRequests[i],
			Price:         result.Meta.RegularMarketPrice,
			Currency:      currency,
			PriceHint:     result.Meta.PriceHint,
			Name: ternary(marketRequests[i].CustomName == "",
				result.Meta.ShortName,
				marketRequests[i].CustomName,
			),
			PercentChange: percentChange(
				result.Meta.RegularMarketPrice,
				previous,
			),
			SvgChartPoints: points,
		})
	}
	if len(markets) == 0 {
		return nil, errNoContent
	}
	if failed > 0 {
		return markets, fmt.Errorf("%w: could not fetch data for %d market(s)", errPartialContent, failed)
	}
	return markets, nil
}
var currencyToSymbol = map[string]string{
	"USD": "$",
	"EUR": "€",
	"JPY": "¥",
	"CAD": "C$",
	"AUD": "A$",
	"GBP": "£",
	"CHF": "Fr",
	"NZD": "N$",
	"INR": "₹",
	"BRL": "R$",
	"RUB": "₽",
	"TRY": "₺",
	"ZAR": "R",
	"CNY": "¥",
	"KRW": "₩",
	"HKD": "HK$",
	"SGD": "S$",
	"SEK": "kr",
	"NOK": "kr",
	"DKK": "kr",
	"PLN": "zł",
	"PHP": "₱",
}
</file>

<file path="internal/glance/widget-old-calendar.go">
package glance
import (
	"context"
	"html/template"
	"time"
)
var oldCalendarWidgetTemplate = mustParseTemplate("old-calendar.html", "widget-base.html")
type oldCalendarWidget struct {
	widgetBase  `yaml:",inline"`
	Calendar    *calendar
	StartSunday bool `yaml:"start-sunday"`
}
func (widget *oldCalendarWidget) initialize() error {
	widget.withTitle("Calendar").withCacheOnTheHour()
	return nil
}
func (widget *oldCalendarWidget) update(ctx context.Context) {
	widget.Calendar = newCalendar(time.Now(), widget.StartSunday)
	widget.withError(nil).scheduleNextUpdate()
}
func (widget *oldCalendarWidget) Render() template.HTML {
	return widget.renderTemplate(widget, oldCalendarWidgetTemplate)
}
type calendar struct {
	CurrentDay        int
	CurrentWeekNumber int
	CurrentMonthName  string
	CurrentYear       int
	Days              []int
}
// TODO: very inflexible, refactor to allow more customizability
// TODO: allow changing between showing the previous and next week and the entire month
func newCalendar(now time.Time, startSunday bool) *calendar {
	year, week := now.ISOWeek()
	weekday := now.Weekday()
	if !startSunday {
		weekday = (weekday + 6) % 7 // Shift Monday to 0
	}
	currentMonthDays := daysInMonth(now.Month(), year)
	var previousMonthDays int
	if previousMonthNumber := now.Month() - 1; previousMonthNumber < 1 {
		previousMonthDays = daysInMonth(12, year-1)
	} else {
		previousMonthDays = daysInMonth(previousMonthNumber, year)
	}
	startDaysFrom := now.Day() - int(weekday) - 7
	days := make([]int, 21)
	for i := 0; i < 21; i++ {
		day := startDaysFrom + i
		if day < 1 {
			day = previousMonthDays + day
		} else if day > currentMonthDays {
			day = day - currentMonthDays
		}
		days[i] = day
	}
	return &calendar{
		CurrentDay:        now.Day(),
		CurrentWeekNumber: week,
		CurrentMonthName:  now.Month().String(),
		CurrentYear:       year,
		Days:              days,
	}
}
func daysInMonth(m time.Month, year int) int {
	return time.Date(year, m+1, 0, 0, 0, 0, 0, time.UTC).Day()
}
</file>

<file path="internal/glance/widget-reddit.go">
package glance
import (
	"context"
	"errors"
	"fmt"
	"html"
	"html/template"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"time"
)
var (
	redditWidgetHorizontalCardsTemplate = mustParseTemplate("reddit-horizontal-cards.html", "widget-base.html")
	redditWidgetVerticalCardsTemplate   = mustParseTemplate("reddit-vertical-cards.html", "widget-base.html")
)
type redditWidget struct {
	widgetBase          `yaml:",inline"`
	Posts               forumPostList     `yaml:"-"`
	Subreddit           string            `yaml:"subreddit"`
	Proxy               proxyOptionsField `yaml:"proxy"`
	Style               string            `yaml:"style"`
	ShowThumbnails      bool              `yaml:"show-thumbnails"`
	ShowFlairs          bool              `yaml:"show-flairs"`
	SortBy              string            `yaml:"sort-by"`
	TopPeriod           string            `yaml:"top-period"`
	Search              string            `yaml:"search"`
	ExtraSortBy         string            `yaml:"extra-sort-by"`
	CommentsURLTemplate string            `yaml:"comments-url-template"`
	Limit               int               `yaml:"limit"`
	CollapseAfter       int               `yaml:"collapse-after"`
	RequestURLTemplate  string            `yaml:"request-url-template"`
	AppAuth struct {
		Name   string `yaml:"name"`
		ID     string `yaml:"id"`
		Secret string `yaml:"secret"`
		enabled        bool
		accessToken    string
		tokenExpiresAt time.Time
	} `yaml:"app-auth"`
}
func (widget *redditWidget) initialize() error {
	if widget.Subreddit == "" {
		return errors.New("subreddit is required")
	}
	if widget.Limit <= 0 {
		widget.Limit = 15
	}
	if widget.CollapseAfter == 0 || widget.CollapseAfter < -1 {
		widget.CollapseAfter = 5
	}
	s := widget.SortBy
	if s != "hot" && s != "new" && s != "top" && s != "rising" {
		widget.SortBy = "hot"
	}
	p := widget.TopPeriod
	if p != "hour" && p != "day" && p != "week" && p != "month" && p != "year" && p != "all" {
		widget.TopPeriod = "day"
	}
	if widget.RequestURLTemplate != "" {
		if !strings.Contains(widget.RequestURLTemplate, "{REQUEST-URL}") {
			return errors.New("no `{REQUEST-URL}` placeholder specified")
		}
	}
	a := &widget.AppAuth
	if a.Name != "" || a.ID != "" || a.Secret != "" {
		if a.Name == "" || a.ID == "" || a.Secret == "" {
			return errors.New("application name, client ID and client secret are required")
		}
		a.enabled = true
	}
	widget.
		withTitle("r/" + widget.Subreddit).
		withTitleURL("https://www.reddit.com/r/" + widget.Subreddit + "/").
		withCacheDuration(30 * time.Minute)
	return nil
}
func (widget *redditWidget) update(ctx context.Context) {
	posts, err := widget.fetchSubredditPosts()
	if !widget.canContinueUpdateAfterHandlingErr(err) {
		return
	}
	if len(posts) > widget.Limit {
		posts = posts[:widget.Limit]
	}
	if widget.ExtraSortBy == "engagement" {
		posts.calculateEngagement()
		posts.sortByEngagement()
	}
	widget.Posts = posts
}
func (widget *redditWidget) Render() template.HTML {
	if widget.Style == "horizontal-cards" {
		return widget.renderTemplate(widget, redditWidgetHorizontalCardsTemplate)
	}
	if widget.Style == "vertical-cards" {
		return widget.renderTemplate(widget, redditWidgetVerticalCardsTemplate)
	}
	return widget.renderTemplate(widget, forumPostsTemplate)
}
type subredditResponseJson struct {
	Data struct {
		Children []struct {
			Data struct {
				Id            string  `json:"id"`
				Title         string  `json:"title"`
				Upvotes       int     `json:"ups"`
				Url           string  `json:"url"`
				Time          float64 `json:"created"`
				CommentsCount int     `json:"num_comments"`
				Domain        string  `json:"domain"`
				Permalink     string  `json:"permalink"`
				Stickied      bool    `json:"stickied"`
				Pinned        bool    `json:"pinned"`
				IsSelf        bool    `json:"is_self"`
				Thumbnail     string  `json:"thumbnail"`
				Flair         string  `json:"link_flair_text"`
				ParentList    []struct {
					Id        string `json:"id"`
					Subreddit string `json:"subreddit"`
					Permalink string `json:"permalink"`
				} `json:"crosspost_parent_list"`
			} `json:"data"`
		} `json:"children"`
	} `json:"data"`
}
func (widget *redditWidget) parseCustomCommentsURL(subreddit, postId, postPath string) string {
	template := strings.ReplaceAll(widget.CommentsURLTemplate, "{SUBREDDIT}", subreddit)
	template = strings.ReplaceAll(template, "{POST-ID}", postId)
	template = strings.ReplaceAll(template, "{POST-PATH}", strings.TrimLeft(postPath, "/"))
	return template
}
func (widget *redditWidget) fetchSubredditPosts() (forumPostList, error) {
	var client requestDoer = defaultHTTPClient
	var baseURL string
	var requestURL string
	var headers http.Header
	query := url.Values{}
	app := &widget.AppAuth
	if !app.enabled {
		baseURL = "https://www.reddit.com"
		headers = http.Header{
			"User-Agent": []string{getBrowserUserAgentHeader()},
		}
	} else {
		baseURL = "https://oauth.reddit.com"
		if app.accessToken == "" || time.Now().Add(time.Minute).After(app.tokenExpiresAt) {
			if err := widget.fetchNewAppAccessToken(); err != nil {
				return nil, fmt.Errorf("fetching new app access token: %v", err)
			}
		}
		headers = http.Header{
			"Authorization": []string{"Bearer " + app.accessToken},
			"User-Agent":    []string{app.Name + "/1.0"},
		}
	}
	if widget.Limit > 25 {
		query.Set("limit", strconv.Itoa(widget.Limit))
	}
	if widget.Search != "" {
		query.Set("q", widget.Search+" subreddit:"+widget.Subreddit)
		query.Set("sort", widget.SortBy)
		requestURL = fmt.Sprintf("%s/search.json?%s", baseURL, query.Encode())
	} else {
		if widget.SortBy == "top" {
			query.Set("t", widget.TopPeriod)
		}
		requestURL = fmt.Sprintf("%s/r/%s/%s.json?%s", baseURL, widget.Subreddit, widget.SortBy, query.Encode())
	}
	if widget.RequestURLTemplate != "" {
		requestURL = strings.ReplaceAll(widget.RequestURLTemplate, "{REQUEST-URL}", requestURL)
	} else if widget.Proxy.client != nil {
		client = widget.Proxy.client
	}
	request, err := http.NewRequest("GET", requestURL, nil)
	if err != nil {
		return nil, err
	}
	request.Header = headers
	responseJson, err := decodeJsonFromRequest[subredditResponseJson](client, request)
	if err != nil {
		return nil, err
	}
	if len(responseJson.Data.Children) == 0 {
		return nil, fmt.Errorf("no posts found")
	}
	posts := make(forumPostList, 0, len(responseJson.Data.Children))
	for i := range responseJson.Data.Children {
		post := &responseJson.Data.Children[i].Data
		if post.Stickied || post.Pinned {
			continue
		}
		var commentsUrl string
		if widget.CommentsURLTemplate == "" {
			commentsUrl = "https://www.reddit.com" + post.Permalink
		} else {
			commentsUrl = widget.parseCustomCommentsURL(widget.Subreddit, post.Id, post.Permalink)
		}
		forumPost := forumPost{
			Title:           html.UnescapeString(post.Title),
			DiscussionUrl:   commentsUrl,
			TargetUrlDomain: post.Domain,
			CommentCount:    post.CommentsCount,
			Score:           post.Upvotes,
			TimePosted:      time.Unix(int64(post.Time), 0),
		}
		if post.Thumbnail != "" && post.Thumbnail != "self" && post.Thumbnail != "default" && post.Thumbnail != "nsfw" {
			forumPost.ThumbnailUrl = html.UnescapeString(post.Thumbnail)
		}
		if !post.IsSelf {
			forumPost.TargetUrl = post.Url
		}
		if widget.ShowFlairs && post.Flair != "" {
			forumPost.Tags = append(forumPost.Tags, post.Flair)
		}
		if len(post.ParentList) > 0 {
			forumPost.IsCrosspost = true
			forumPost.TargetUrlDomain = "r/" + post.ParentList[0].Subreddit
			if widget.CommentsURLTemplate == "" {
				forumPost.TargetUrl = "https://www.reddit.com" + post.ParentList[0].Permalink
			} else {
				forumPost.TargetUrl = widget.parseCustomCommentsURL(
					post.ParentList[0].Subreddit,
					post.ParentList[0].Id,
					post.ParentList[0].Permalink,
				)
			}
		}
		posts = append(posts, forumPost)
	}
	return posts, nil
}
func (widget *redditWidget) fetchNewAppAccessToken() error {
	body := strings.NewReader("grant_type=client_credentials")
	req, err := http.NewRequest("POST", "https://www.reddit.com/api/v1/access_token", body)
	if err != nil {
		return fmt.Errorf("creating request for app access token: %v", err)
	}
	app := &widget.AppAuth
	req.SetBasicAuth(app.ID, app.Secret)
	req.Header.Add("User-Agent", app.Name+"/1.0")
	req.Header.Add("Content-Type", "application/x-www-form-urlencoded")
	type tokenResponse struct {
		AccessToken string `json:"access_token"`
		ExpiresIn   int    `json:"expires_in"`
	}
	client := ternary(widget.Proxy.client != nil, widget.Proxy.client, defaultHTTPClient)
	response, err := decodeJsonFromRequest[tokenResponse](client, req)
	if err != nil {
		return err
	}
	app.accessToken = response.AccessToken
	app.tokenExpiresAt = time.Now().Add(time.Duration(response.ExpiresIn) * time.Second)
	return nil
}
</file>

<file path="internal/glance/widget-releases.go">
package glance
import (
	"context"
	"errors"
	"fmt"
	"html/template"
	"log/slog"
	"net/http"
	"net/url"
	"sort"
	"strings"
	"time"
	"gopkg.in/yaml.v3"
)
var releasesWidgetTemplate = mustParseTemplate("releases.html", "widget-base.html")
type releasesWidget struct {
	widgetBase     `yaml:",inline"`
	Releases       appReleaseList    `yaml:"-"`
	Repositories   []*releaseRequest `yaml:"repositories"`
	Token          string            `yaml:"token"`
	GitLabToken    string            `yaml:"gitlab-token"`
	Limit          int               `yaml:"limit"`
	CollapseAfter  int               `yaml:"collapse-after"`
	ShowSourceIcon bool              `yaml:"show-source-icon"`
}
func (widget *releasesWidget) initialize() error {
	widget.withTitle("Releases").withCacheDuration(2 * time.Hour)
	if widget.Limit <= 0 {
		widget.Limit = 10
	}
	if widget.CollapseAfter == 0 || widget.CollapseAfter < -1 {
		widget.CollapseAfter = 5
	}
	for i := range widget.Repositories {
		r := widget.Repositories[i]
		if r.source == releaseSourceGithub && widget.Token != "" {
			r.token = &widget.Token
		} else if r.source == releaseSourceGitlab && widget.GitLabToken != "" {
			r.token = &widget.GitLabToken
		}
	}
	return nil
}
func (widget *releasesWidget) update(ctx context.Context) {
	releases, err := fetchLatestReleases(widget.Repositories)
	if !widget.canContinueUpdateAfterHandlingErr(err) {
		return
	}
	if len(releases) > widget.Limit {
		releases = releases[:widget.Limit]
	}
	for i := range releases {
		releases[i].SourceIconURL = widget.Providers.assetResolver("icons/" + string(releases[i].Source) + ".svg")
	}
	widget.Releases = releases
}
func (widget *releasesWidget) Render() template.HTML {
	return widget.renderTemplate(widget, releasesWidgetTemplate)
}
type releaseSource string
const (
	releaseSourceCodeberg  releaseSource = "codeberg"
	releaseSourceGithub    releaseSource = "github"
	releaseSourceGitlab    releaseSource = "gitlab"
	releaseSourceDockerHub releaseSource = "dockerhub"
)
type appRelease struct {
	Source        releaseSource
	SourceIconURL string
	Name          string
	Version       string
	NotesUrl      string
	TimeReleased  time.Time
	Downvotes     int
}
type appReleaseList []appRelease
func (r appReleaseList) sortByNewest() appReleaseList {
	sort.Slice(r, func(i, j int) bool {
		return r[i].TimeReleased.After(r[j].TimeReleased)
	})
	return r
}
type releaseRequest struct {
	IncludePreleases bool   `yaml:"include-prereleases"`
	Repository       string `yaml:"repository"`
	source releaseSource
	token  *string
}
func (r *releaseRequest) UnmarshalYAML(node *yaml.Node) error {
	type releaseRequestAlias releaseRequest
	alias := (*releaseRequestAlias)(r)
	var repository string
	if err := node.Decode(&repository); err != nil {
		if err := node.Decode(alias); err != nil {
			return fmt.Errorf("could not umarshal repository into string or struct: %v", err)
		}
	}
	if r.Repository == "" {
		if repository == "" {
			return errors.New("repository is required")
		} else {
			r.Repository = repository
		}
	}
	parts := strings.SplitN(repository, ":", 2)
	if len(parts) == 1 {
		r.source = releaseSourceGithub
	} else if len(parts) == 2 {
		r.Repository = parts[1]
		switch parts[0] {
		case string(releaseSourceGithub):
			r.source = releaseSourceGithub
		case string(releaseSourceGitlab):
			r.source = releaseSourceGitlab
		case string(releaseSourceDockerHub):
			r.source = releaseSourceDockerHub
		case string(releaseSourceCodeberg):
			r.source = releaseSourceCodeberg
		default:
			return errors.New("invalid source")
		}
	}
	return nil
}
func fetchLatestReleases(requests []*releaseRequest) (appReleaseList, error) {
	job := newJob(fetchLatestReleaseTask, requests).withWorkers(20)
	results, errs, err := workerPoolDo(job)
	if err != nil {
		return nil, err
	}
	var failed int
	releases := make(appReleaseList, 0, len(requests))
	for i := range results {
		if errs[i] != nil {
			failed++
			slog.Error("Failed to fetch release", "source", requests[i].source, "repository", requests[i].Repository, "error", errs[i])
			continue
		}
		releases = append(releases, *results[i])
	}
	if failed == len(requests) {
		return nil, errNoContent
	}
	releases.sortByNewest()
	if failed > 0 {
		return releases, fmt.Errorf("%w: could not get %d releases", errPartialContent, failed)
	}
	return releases, nil
}
func fetchLatestReleaseTask(request *releaseRequest) (*appRelease, error) {
	switch request.source {
	case releaseSourceCodeberg:
		return fetchLatestCodebergRelease(request)
	case releaseSourceGithub:
		return fetchLatestGithubRelease(request)
	case releaseSourceGitlab:
		return fetchLatestGitLabRelease(request)
	case releaseSourceDockerHub:
		return fetchLatestDockerHubRelease(request)
	}
	return nil, errors.New("unsupported source")
}
type githubReleaseResponseJson struct {
	TagName     string `json:"tag_name"`
	PublishedAt string `json:"published_at"`
	HtmlUrl     string `json:"html_url"`
	Reactions   struct {
		Downvotes int `json:"-1"`
	} `json:"reactions"`
}
func fetchLatestGithubRelease(request *releaseRequest) (*appRelease, error) {
	var requestURL string
	if !request.IncludePreleases {
		requestURL = fmt.Sprintf("https://api.github.com/repos/%s/releases/latest", request.Repository)
	} else {
		requestURL = fmt.Sprintf("https://api.github.com/repos/%s/releases", request.Repository)
	}
	httpRequest, err := http.NewRequest("GET", requestURL, nil)
	if err != nil {
		return nil, err
	}
	if request.token != nil {
		httpRequest.Header.Add("Authorization", "Bearer "+(*request.token))
	}
	var response githubReleaseResponseJson
	if !request.IncludePreleases {
		response, err = decodeJsonFromRequest[githubReleaseResponseJson](defaultHTTPClient, httpRequest)
		if err != nil {
			return nil, err
		}
	} else {
		responses, err := decodeJsonFromRequest[[]githubReleaseResponseJson](defaultHTTPClient, httpRequest)
		if err != nil {
			return nil, err
		}
		if len(responses) == 0 {
			return nil, fmt.Errorf("no releases found for repository %s", request.Repository)
		}
		response = responses[0]
	}
	return &appRelease{
		Source:       releaseSourceGithub,
		Name:         request.Repository,
		Version:      normalizeVersionFormat(response.TagName),
		NotesUrl:     response.HtmlUrl,
		TimeReleased: parseRFC3339Time(response.PublishedAt),
		Downvotes:    response.Reactions.Downvotes,
	}, nil
}
type dockerHubRepositoryTagsResponse struct {
	Results []dockerHubRepositoryTagResponse `json:"results"`
}
type dockerHubRepositoryTagResponse struct {
	Name       string `json:"name"`
	LastPushed string `json:"tag_last_pushed"`
}
const dockerHubOfficialRepoTagURLFormat = "https://hub.docker.com/_/%s/tags?name=%s"
const dockerHubRepoTagURLFormat = "https://hub.docker.com/r/%s/tags?name=%s"
const dockerHubTagsURLFormat = "https://hub.docker.com/v2/namespaces/%s/repositories/%s/tags"
const dockerHubSpecificTagURLFormat = "https://hub.docker.com/v2/namespaces/%s/repositories/%s/tags/%s"
func fetchLatestDockerHubRelease(request *releaseRequest) (*appRelease, error) {
	nameParts := strings.Split(request.Repository, "/")
	if len(nameParts) > 2 {
		return nil, fmt.Errorf("invalid repository name: %s", request.Repository)
	} else if len(nameParts) == 1 {
		nameParts = []string{"library", nameParts[0]}
	}
	tagParts := strings.SplitN(nameParts[1], ":", 2)
	var requestURL string
	if len(tagParts) == 2 {
		requestURL = fmt.Sprintf(dockerHubSpecificTagURLFormat, nameParts[0], tagParts[0], tagParts[1])
	} else {
		requestURL = fmt.Sprintf(dockerHubTagsURLFormat, nameParts[0], nameParts[1])
	}
	httpRequest, err := http.NewRequest("GET", requestURL, nil)
	if err != nil {
		return nil, err
	}
	if request.token != nil {
		httpRequest.Header.Add("Authorization", "Bearer "+(*request.token))
	}
	var tag *dockerHubRepositoryTagResponse
	if len(tagParts) == 1 {
		response, err := decodeJsonFromRequest[dockerHubRepositoryTagsResponse](defaultHTTPClient, httpRequest)
		if err != nil {
			return nil, err
		}
		if len(response.Results) == 0 {
			return nil, fmt.Errorf("no tags found for repository: %s", request.Repository)
		}
		tag = &response.Results[0]
	} else {
		response, err := decodeJsonFromRequest[dockerHubRepositoryTagResponse](defaultHTTPClient, httpRequest)
		if err != nil {
			return nil, err
		}
		tag = &response
	}
	var repo string
	var displayName string
	var notesURL string
	if len(tagParts) == 1 {
		repo = nameParts[1]
	} else {
		repo = tagParts[0]
	}
	if nameParts[0] == "library" {
		displayName = repo
		notesURL = fmt.Sprintf(dockerHubOfficialRepoTagURLFormat, repo, tag.Name)
	} else {
		displayName = nameParts[0] + "/" + repo
		notesURL = fmt.Sprintf(dockerHubRepoTagURLFormat, displayName, tag.Name)
	}
	return &appRelease{
		Source:       releaseSourceDockerHub,
		NotesUrl:     notesURL,
		Name:         displayName,
		Version:      tag.Name,
		TimeReleased: parseRFC3339Time(tag.LastPushed),
	}, nil
}
type gitlabReleaseResponseJson struct {
	TagName    string `json:"tag_name"`
	ReleasedAt string `json:"released_at"`
	Links      struct {
		Self string `json:"self"`
	} `json:"_links"`
}
func fetchLatestGitLabRelease(request *releaseRequest) (*appRelease, error) {
	httpRequest, err := http.NewRequest(
		"GET",
		fmt.Sprintf(
			"https://gitlab.com/api/v4/projects/%s/releases/permalink/latest",
			url.QueryEscape(request.Repository),
		),
		nil,
	)
	if err != nil {
		return nil, err
	}
	if request.token != nil {
		httpRequest.Header.Add("PRIVATE-TOKEN", *request.token)
	}
	response, err := decodeJsonFromRequest[gitlabReleaseResponseJson](defaultHTTPClient, httpRequest)
	if err != nil {
		return nil, err
	}
	return &appRelease{
		Source:       releaseSourceGitlab,
		Name:         request.Repository,
		Version:      normalizeVersionFormat(response.TagName),
		NotesUrl:     response.Links.Self,
		TimeReleased: parseRFC3339Time(response.ReleasedAt),
	}, nil
}
type codebergReleaseResponseJson struct {
	TagName     string `json:"tag_name"`
	PublishedAt string `json:"published_at"`
	HtmlUrl     string `json:"html_url"`
}
func fetchLatestCodebergRelease(request *releaseRequest) (*appRelease, error) {
	httpRequest, err := http.NewRequest(
		"GET",
		fmt.Sprintf(
			"https://codeberg.org/api/v1/repos/%s/releases/latest",
			request.Repository,
		),
		nil,
	)
	if err != nil {
		return nil, err
	}
	response, err := decodeJsonFromRequest[codebergReleaseResponseJson](defaultHTTPClient, httpRequest)
	if err != nil {
		return nil, err
	}
	return &appRelease{
		Source:       releaseSourceCodeberg,
		Name:         request.Repository,
		Version:      normalizeVersionFormat(response.TagName),
		NotesUrl:     response.HtmlUrl,
		TimeReleased: parseRFC3339Time(response.PublishedAt),
	}, nil
}
</file>

<file path="internal/glance/widget-rss.go">
package glance
import (
	"context"
	"fmt"
	"html"
	"html/template"
	"io"
	"log/slog"
	"net/http"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"sync"
	"time"
	"github.com/mmcdole/gofeed"
	gofeedext "github.com/mmcdole/gofeed/extensions"
)
var (
	rssWidgetTemplate                 = mustParseTemplate("rss-list.html", "widget-base.html")
	rssWidgetDetailedListTemplate     = mustParseTemplate("rss-detailed-list.html", "widget-base.html")
	rssWidgetHorizontalCardsTemplate  = mustParseTemplate("rss-horizontal-cards.html", "widget-base.html")
	rssWidgetHorizontalCards2Template = mustParseTemplate("rss-horizontal-cards-2.html", "widget-base.html")
)
var feedParser = gofeed.NewParser()
type rssWidget struct {
	widgetBase       `yaml:",inline"`
	FeedRequests     []rssFeedRequest `yaml:"feeds"`
	Style            string           `yaml:"style"`
	ThumbnailHeight  float64          `yaml:"thumbnail-height"`
	CardHeight       float64          `yaml:"card-height"`
	Limit            int              `yaml:"limit"`
	CollapseAfter    int              `yaml:"collapse-after"`
	SingleLineTitles bool             `yaml:"single-line-titles"`
	PreserveOrder    bool             `yaml:"preserve-order"`
	Items          rssFeedItemList `yaml:"-"`
	NoItemsMessage string          `yaml:"-"`
	cachedFeedsMutex sync.Mutex
	cachedFeeds      map[string]*cachedRSSFeed `yaml:"-"`
}
func (widget *rssWidget) initialize() error {
	widget.withTitle("RSS Feed").withCacheDuration(2 * time.Hour)
	if widget.Limit <= 0 {
		widget.Limit = 25
	}
	if widget.CollapseAfter == 0 || widget.CollapseAfter < -1 {
		widget.CollapseAfter = 5
	}
	if widget.ThumbnailHeight < 0 {
		widget.ThumbnailHeight = 0
	}
	if widget.CardHeight < 0 {
		widget.CardHeight = 0
	}
	if widget.Style == "detailed-list" {
		for i := range widget.FeedRequests {
			widget.FeedRequests[i].IsDetailed = true
		}
	}
	widget.NoItemsMessage = "No items were returned from the feeds."
	widget.cachedFeeds = make(map[string]*cachedRSSFeed)
	return nil
}
func (widget *rssWidget) update(ctx context.Context) {
	items, err := widget.fetchItemsFromFeeds()
	if !widget.canContinueUpdateAfterHandlingErr(err) {
		return
	}
	if !widget.PreserveOrder {
		items.sortByNewest()
	}
	if len(items) > widget.Limit {
		items = items[:widget.Limit]
	}
	widget.Items = items
}
func (widget *rssWidget) Render() template.HTML {
	if widget.Style == "horizontal-cards" {
		return widget.renderTemplate(widget, rssWidgetHorizontalCardsTemplate)
	}
	if widget.Style == "horizontal-cards-2" {
		return widget.renderTemplate(widget, rssWidgetHorizontalCards2Template)
	}
	if widget.Style == "detailed-list" {
		return widget.renderTemplate(widget, rssWidgetDetailedListTemplate)
	}
	return widget.renderTemplate(widget, rssWidgetTemplate)
}
type cachedRSSFeed struct {
	etag         string
	lastModified string
	items        []rssFeedItem
}
type rssFeedItem struct {
	ChannelName string
	ChannelURL  string
	Title       string
	Link        string
	ImageURL    string
	Categories  []string
	Description string
	PublishedAt time.Time
}
type rssFeedRequest struct {
	URL             string            `yaml:"url"`
	Title           string            `yaml:"title"`
	HideCategories  bool              `yaml:"hide-categories"`
	HideDescription bool              `yaml:"hide-description"`
	Limit           int               `yaml:"limit"`
	ItemLinkPrefix  string            `yaml:"item-link-prefix"`
	Headers         map[string]string `yaml:"headers"`
	IsDetailed      bool              `yaml:"-"`
}
type rssFeedItemList []rssFeedItem
func (f rssFeedItemList) sortByNewest() rssFeedItemList {
	sort.Slice(f, func(i, j int) bool {
		return f[i].PublishedAt.After(f[j].PublishedAt)
	})
	return f
}
func (widget *rssWidget) fetchItemsFromFeeds() (rssFeedItemList, error) {
	requests := widget.FeedRequests
	job := newJob(widget.fetchItemsFromFeedTask, requests).withWorkers(30)
	feeds, errs, err := workerPoolDo(job)
	if err != nil {
		return nil, fmt.Errorf("%w: %v", errNoContent, err)
	}
	failed := 0
	entries := make(rssFeedItemList, 0, len(feeds)*10)
	seen := make(map[string]struct{})
	for i := range feeds {
		if errs[i] != nil {
			failed++
			slog.Error("Failed to get RSS feed", "url", requests[i].URL, "error", errs[i])
			continue
		}
		for _, item := range feeds[i] {
			if _, exists := seen[item.Link]; exists {
				continue
			}
			entries = append(entries, item)
			seen[item.Link] = struct{}{}
		}
	}
	if failed == len(requests) {
		return nil, errNoContent
	}
	if failed > 0 {
		return entries, fmt.Errorf("%w: missing %d RSS feeds", errPartialContent, failed)
	}
	return entries, nil
}
func (widget *rssWidget) fetchItemsFromFeedTask(request rssFeedRequest) ([]rssFeedItem, error) {
	req, err := http.NewRequest("GET", request.URL, nil)
	if err != nil {
		return nil, err
	}
	req.Header.Add("User-Agent", glanceUserAgentString)
	widget.cachedFeedsMutex.Lock()
	cache, isCached := widget.cachedFeeds[request.URL]
	if isCached {
		if cache.etag != "" {
			req.Header.Add("If-None-Match", cache.etag)
		}
		if cache.lastModified != "" {
			req.Header.Add("If-Modified-Since", cache.lastModified)
		}
	}
	widget.cachedFeedsMutex.Unlock()
	for key, value := range request.Headers {
		req.Header.Set(key, value)
	}
	resp, err := defaultHTTPClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if resp.StatusCode == http.StatusNotModified && isCached {
		return cache.items, nil
	}
	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("unexpected status code %d from %s", resp.StatusCode, request.URL)
	}
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	feed, err := feedParser.ParseString(string(body))
	if err != nil {
		return nil, err
	}
	if request.Limit > 0 && len(feed.Items) > request.Limit {
		feed.Items = feed.Items[:request.Limit]
	}
	items := make(rssFeedItemList, 0, len(feed.Items))
	for i := range feed.Items {
		item := feed.Items[i]
		rssItem := rssFeedItem{
			ChannelURL: feed.Link,
		}
		if request.ItemLinkPrefix != "" {
			rssItem.Link = request.ItemLinkPrefix + item.Link
		} else if strings.HasPrefix(item.Link, "http://") || strings.HasPrefix(item.Link, "https://") {
			rssItem.Link = item.Link
		} else {
			parsedUrl, err := url.Parse(feed.Link)
			if err != nil {
				parsedUrl, err = url.Parse(request.URL)
			}
			if err == nil {
				var link string
				if len(item.Link) > 0 && item.Link[0] == '/' {
					link = item.Link
				} else {
					link = "/" + item.Link
				}
				rssItem.Link = parsedUrl.Scheme + "://" + parsedUrl.Host + link
			}
		}
		if item.Title != "" {
			rssItem.Title = html.UnescapeString(item.Title)
		} else {
			rssItem.Title = shortenFeedDescriptionLen(item.Description, 100)
		}
		if request.IsDetailed {
			if !request.HideDescription && item.Description != "" && item.Title != "" {
				rssItem.Description = shortenFeedDescriptionLen(item.Description, 200)
			}
			if !request.HideCategories {
				var categories = make([]string, 0, 6)
				for _, category := range item.Categories {
					if len(categories) == 6 {
						break
					}
					if len(category) == 0 || len(category) > 30 {
						continue
					}
					categories = append(categories, category)
				}
				rssItem.Categories = categories
			}
		}
		if request.Title != "" {
			rssItem.ChannelName = request.Title
		} else {
			rssItem.ChannelName = feed.Title
		}
		if item.Image != nil {
			rssItem.ImageURL = item.Image.URL
		} else if url := findThumbnailInItemExtensions(item); url != "" {
			rssItem.ImageURL = url
		} else if feed.Image != nil {
			if len(feed.Image.URL) > 0 && feed.Image.URL[0] == '/' {
				rssItem.ImageURL = strings.TrimRight(feed.Link, "/") + feed.Image.URL
			} else {
				rssItem.ImageURL = feed.Image.URL
			}
		}
		if item.PublishedParsed != nil {
			rssItem.PublishedAt = *item.PublishedParsed
		} else {
			rssItem.PublishedAt = time.Now()
		}
		items = append(items, rssItem)
	}
	if resp.Header.Get("ETag") != "" || resp.Header.Get("Last-Modified") != "" {
		widget.cachedFeedsMutex.Lock()
		widget.cachedFeeds[request.URL] = &cachedRSSFeed{
			etag:         resp.Header.Get("ETag"),
			lastModified: resp.Header.Get("Last-Modified"),
			items:        items,
		}
		widget.cachedFeedsMutex.Unlock()
	}
	return items, nil
}
func findThumbnailInItemExtensions(item *gofeed.Item) string {
	media, ok := item.Extensions["media"]
	if !ok {
		return ""
	}
	return recursiveFindThumbnailInExtensions(media)
}
func recursiveFindThumbnailInExtensions(extensions map[string][]gofeedext.Extension) string {
	for _, exts := range extensions {
		for _, ext := range exts {
			if ext.Name == "thumbnail" || ext.Name == "image" {
				if url, ok := ext.Attrs["url"]; ok {
					return url
				}
			}
			if ext.Children != nil {
				if url := recursiveFindThumbnailInExtensions(ext.Children); url != "" {
					return url
				}
			}
		}
	}
	return ""
}
var htmlTagsWithAttributesPattern = regexp.MustCompile(`<\/?[a-zA-Z0-9-]+ *(?:[a-zA-Z-]+=(?:"|').*?(?:"|') ?)* *\/?>`)
func sanitizeFeedDescription(description string) string {
	if description == "" {
		return ""
	}
	description = strings.ReplaceAll(description, "\n", " ")
	description = htmlTagsWithAttributesPattern.ReplaceAllString(description, "")
	description = sequentialWhitespacePattern.ReplaceAllString(description, " ")
	description = strings.TrimSpace(description)
	description = html.UnescapeString(description)
	return description
}
func shortenFeedDescriptionLen(description string, maxLen int) string {
	description, _ = limitStringLength(description, 1000)
	description = sanitizeFeedDescription(description)
	description, limited := limitStringLength(description, maxLen)
	if limited {
		description += "…"
	}
	return description
}
</file>

<file path="internal/glance/widget-search.go">
package glance
import (
	"fmt"
	"html/template"
	"strings"
)
var searchWidgetTemplate = mustParseTemplate("search.html", "widget-base.html")
type SearchBang struct {
	Title    string
	Shortcut string
	URL      string
}
type searchWidget struct {
	widgetBase   `yaml:",inline"`
	cachedHTML   template.HTML `yaml:"-"`
	SearchEngine string        `yaml:"search-engine"`
	Bangs        []SearchBang  `yaml:"bangs"`
	NewTab       bool          `yaml:"new-tab"`
	Target       string        `yaml:"target"`
	Autofocus    bool          `yaml:"autofocus"`
	Placeholder  string        `yaml:"placeholder"`
}
func convertSearchUrl(url string) string {
	// Go's template is being stubborn and continues to escape the curlies in the
	// URL regardless of what the type of the variable is so this is my way around it
	return strings.ReplaceAll(url, "{QUERY}", "!QUERY!")
}
var searchEngines = map[string]string{
	"duckduckgo": "https://duckduckgo.com/?q={QUERY}",
	"google":     "https://www.google.com/search?q={QUERY}",
	"bing":       "https://www.bing.com/search?q={QUERY}",
	"perplexity": "https://www.perplexity.ai/search?q={QUERY}",
	"kagi": "https://kagi.com/search?q={QUERY}",
	"startpage": "https://www.startpage.com/search?q={QUERY}",
}
func (widget *searchWidget) initialize() error {
	widget.withTitle("Search").withError(nil)
	if widget.SearchEngine == "" {
		widget.SearchEngine = "duckduckgo"
	}
	if widget.Placeholder == "" {
		widget.Placeholder = "Type here to search…"
	}
	if url, ok := searchEngines[widget.SearchEngine]; ok {
		widget.SearchEngine = url
	}
	widget.SearchEngine = convertSearchUrl(widget.SearchEngine)
	for i := range widget.Bangs {
		if widget.Bangs[i].Shortcut == "" {
			return fmt.Errorf("search bang #%d has no shortcut", i+1)
		}
		if widget.Bangs[i].URL == "" {
			return fmt.Errorf("search bang #%d has no URL", i+1)
		}
		widget.Bangs[i].URL = convertSearchUrl(widget.Bangs[i].URL)
	}
	widget.cachedHTML = widget.renderTemplate(widget, searchWidgetTemplate)
	return nil
}
func (widget *searchWidget) Render() template.HTML {
	return widget.cachedHTML
}
</file>

<file path="internal/glance/widget-twitch-channels.go">
package glance
import (
	"context"
	"encoding/json"
	"fmt"
	"html/template"
	"log/slog"
	"net/http"
	"sort"
	"strings"
	"time"
)
var twitchChannelsWidgetTemplate = mustParseTemplate("twitch-channels.html", "widget-base.html")
type twitchChannelsWidget struct {
	widgetBase      `yaml:",inline"`
	ChannelsRequest []string        `yaml:"channels"`
	Channels        []twitchChannel `yaml:"-"`
	CollapseAfter   int             `yaml:"collapse-after"`
	SortBy          string          `yaml:"sort-by"`
}
func (widget *twitchChannelsWidget) initialize() error {
	widget.
		withTitle("Twitch Channels").
		withTitleURL("https://www.twitch.tv/directory/following").
		withCacheDuration(time.Minute * 10)
	if widget.CollapseAfter == 0 || widget.CollapseAfter < -1 {
		widget.CollapseAfter = 5
	}
	if widget.SortBy != "viewers" && widget.SortBy != "live" {
		widget.SortBy = "viewers"
	}
	return nil
}
func (widget *twitchChannelsWidget) update(ctx context.Context) {
	channels, err := fetchChannelsFromTwitch(widget.ChannelsRequest)
	if !widget.canContinueUpdateAfterHandlingErr(err) {
		return
	}
	if widget.SortBy == "viewers" {
		channels.sortByViewers()
	} else if widget.SortBy == "live" {
		channels.sortByLive()
	}
	widget.Channels = channels
}
func (widget *twitchChannelsWidget) Render() template.HTML {
	return widget.renderTemplate(widget, twitchChannelsWidgetTemplate)
}
type twitchChannel struct {
	Login        string
	Exists       bool
	Name         string
	StreamTitle  string
	AvatarUrl    string
	IsLive       bool
	LiveSince    time.Time
	Category     string
	CategorySlug string
	ViewersCount int
}
type twitchChannelList []twitchChannel
func (channels twitchChannelList) sortByViewers() {
	sort.Slice(channels, func(i, j int) bool {
		return channels[i].ViewersCount > channels[j].ViewersCount
	})
}
func (channels twitchChannelList) sortByLive() {
	sort.SliceStable(channels, func(i, j int) bool {
		return channels[i].IsLive && !channels[j].IsLive
	})
}
type twitchOperationResponse struct {
	Data       json.RawMessage
	Extensions struct {
		OperationName string `json:"operationName"`
	}
}
type twitchChannelShellOperationResponse struct {
	UserOrError struct {
		Type            string `json:"__typename"`
		DisplayName     string `json:"displayName"`
		ProfileImageUrl string `json:"profileImageURL"`
		Stream          *struct {
			ViewersCount int `json:"viewersCount"`
		}
	} `json:"userOrError"`
}
type twitchStreamMetadataOperationResponse struct {
	UserOrNull *struct {
		Stream *struct {
			StartedAt string `json:"createdAt"`
			Game      *struct {
				Slug string `json:"slug"`
				Name string `json:"name"`
			} `json:"game"`
		} `json:"stream"`
		LastBroadcast *struct {
			Title string `json:"title"`
		}
	} `json:"user"`
}
const twitchChannelStatusOperationRequestBody = `[
{"operationName":"ChannelShell","variables":{"login":"%s"},"extensions":{"persistedQuery":{"version":1,"sha256Hash":"580ab410bcd0c1ad194224957ae2241e5d252b2c5173d8e0cce9d32d5bb14efe"}}},
{"operationName":"StreamMetadata","variables":{"channelLogin":"%s"},"extensions":{"persistedQuery":{"version":1,"sha256Hash":"676ee2f834ede42eb4514cdb432b3134fefc12590080c9a2c9bb44a2a4a63266"}}}
]`
// TODO: rework
// The operations for multiple channels can all be sent in a single request
// rather than sending a separate request for each channel. Need to figure out
// what the limit is for max operations per request and batch operations in
// multiple requests if number of channels exceeds allowed limit.
func fetchChannelFromTwitchTask(channel string) (twitchChannel, error) {
	result := twitchChannel{
		Login: strings.ToLower(channel),
	}
	reader := strings.NewReader(fmt.Sprintf(twitchChannelStatusOperationRequestBody, channel, channel))
	request, _ := http.NewRequest("POST", twitchGqlEndpoint, reader)
	request.Header.Add("Client-ID", twitchGqlClientId)
	response, err := decodeJsonFromRequest[[]twitchOperationResponse](defaultHTTPClient, request)
	if err != nil {
		return result, err
	}
	if len(response) != 2 {
		return result, fmt.Errorf("expected 2 operation responses, got %d", len(response))
	}
	var channelShell twitchChannelShellOperationResponse
	var streamMetadata twitchStreamMetadataOperationResponse
	for i := range response {
		switch response[i].Extensions.OperationName {
		case "ChannelShell":
			if err = json.Unmarshal(response[i].Data, &channelShell); err != nil {
				return result, fmt.Errorf("unmarshalling channel shell: %w", err)
			}
		case "StreamMetadata":
			if err = json.Unmarshal(response[i].Data, &streamMetadata); err != nil {
				return result, fmt.Errorf("unmarshalling stream metadata: %w", err)
			}
		default:
			return result, fmt.Errorf("unknown operation name: %s", response[i].Extensions.OperationName)
		}
	}
	if channelShell.UserOrError.Type != "User" {
		result.Name = result.Login
		return result, nil
	}
	result.Exists = true
	result.Name = channelShell.UserOrError.DisplayName
	result.AvatarUrl = channelShell.UserOrError.ProfileImageUrl
	if channelShell.UserOrError.Stream != nil {
		result.IsLive = true
		result.ViewersCount = channelShell.UserOrError.Stream.ViewersCount
		if streamMetadata.UserOrNull != nil && streamMetadata.UserOrNull.Stream != nil {
			if streamMetadata.UserOrNull.LastBroadcast != nil {
				result.StreamTitle = streamMetadata.UserOrNull.LastBroadcast.Title
			}
			if streamMetadata.UserOrNull.Stream.Game != nil {
				result.Category = streamMetadata.UserOrNull.Stream.Game.Name
				result.CategorySlug = streamMetadata.UserOrNull.Stream.Game.Slug
			}
			startedAt, err := time.Parse("2006-01-02T15:04:05Z", streamMetadata.UserOrNull.Stream.StartedAt)
			if err == nil {
				result.LiveSince = startedAt
			} else {
				slog.Warn("Failed to parse Twitch stream started at", "error", err, "started_at", streamMetadata.UserOrNull.Stream.StartedAt)
			}
		}
	} else {
		// This prevents live channels with 0 viewers from being
		// incorrectly sorted lower than offline channels
		result.ViewersCount = -1
	}
	return result, nil
}
func fetchChannelsFromTwitch(channelLogins []string) (twitchChannelList, error) {
	result := make(twitchChannelList, 0, len(channelLogins))
	job := newJob(fetchChannelFromTwitchTask, channelLogins).withWorkers(10)
	channels, errs, err := workerPoolDo(job)
	if err != nil {
		return result, err
	}
	var failed int
	for i := range channels {
		if errs[i] != nil {
			failed++
			slog.Error("Failed to fetch Twitch channel", "channel", channelLogins[i], "error", errs[i])
			continue
		}
		result = append(result, channels[i])
	}
	if failed == len(channelLogins) {
		return result, errNoContent
	}
	if failed > 0 {
		return result, fmt.Errorf("%w: failed to fetch %d channels", errPartialContent, failed)
	}
	return result, nil
}
</file>

<file path="internal/glance/widget-videos.go">
package glance
import (
	"context"
	"fmt"
	"html/template"
	"log/slog"
	"net/http"
	"net/url"
	"sort"
	"strings"
	"time"
)
const videosWidgetPlaylistPrefix = "playlist:"
var (
	videosWidgetTemplate             = mustParseTemplate("videos.html", "widget-base.html", "video-card-contents.html")
	videosWidgetGridTemplate         = mustParseTemplate("videos-grid.html", "widget-base.html", "video-card-contents.html")
	videosWidgetVerticalListTemplate = mustParseTemplate("videos-vertical-list.html", "widget-base.html")
)
type videosWidget struct {
	widgetBase        `yaml:",inline"`
	Videos            videoList `yaml:"-"`
	VideoUrlTemplate  string    `yaml:"video-url-template"`
	Style             string    `yaml:"style"`
	CollapseAfter     int       `yaml:"collapse-after"`
	CollapseAfterRows int       `yaml:"collapse-after-rows"`
	Channels          []string  `yaml:"channels"`
	Playlists         []string  `yaml:"playlists"`
	Limit             int       `yaml:"limit"`
	IncludeShorts     bool      `yaml:"include-shorts"`
}
func (widget *videosWidget) initialize() error {
	widget.withTitle("Videos").withCacheDuration(time.Hour)
	if widget.Limit <= 0 {
		widget.Limit = 25
	}
	if widget.CollapseAfterRows == 0 || widget.CollapseAfterRows < -1 {
		widget.CollapseAfterRows = 4
	}
	if widget.CollapseAfter == 0 || widget.CollapseAfter < -1 {
		widget.CollapseAfter = 7
	}
	// A bit cheeky, but from a user's perspective it makes more sense when channels and
	// playlists are separate things rather than specifying a list of channels and some of
	// them awkwardly have a "playlist:" prefix
	if len(widget.Playlists) > 0 {
		initialLen := len(widget.Channels)
		widget.Channels = append(widget.Channels, make([]string, len(widget.Playlists))...)
		for i := range widget.Playlists {
			widget.Channels[initialLen+i] = videosWidgetPlaylistPrefix + widget.Playlists[i]
		}
	}
	return nil
}
func (widget *videosWidget) update(ctx context.Context) {
	videos, err := fetchYoutubeChannelUploads(widget.Channels, widget.VideoUrlTemplate, widget.IncludeShorts)
	if !widget.canContinueUpdateAfterHandlingErr(err) {
		return
	}
	if len(videos) > widget.Limit {
		videos = videos[:widget.Limit]
	}
	widget.Videos = videos
}
func (widget *videosWidget) Render() template.HTML {
	var template *template.Template
	switch widget.Style {
	case "grid-cards":
		template = videosWidgetGridTemplate
	case "vertical-list":
		template = videosWidgetVerticalListTemplate
	default:
		template = videosWidgetTemplate
	}
	return widget.renderTemplate(widget, template)
}
type youtubeFeedResponseXml struct {
	Channel     string `xml:"author>name"`
	ChannelLink string `xml:"author>uri"`
	Videos      []struct {
		Title     string `xml:"title"`
		Published string `xml:"published"`
		Link      struct {
			Href string `xml:"href,attr"`
		} `xml:"link"`
		Group struct {
			Thumbnail struct {
				Url string `xml:"url,attr"`
			} `xml:"http://search.yahoo.com/mrss/ thumbnail"`
		} `xml:"http://search.yahoo.com/mrss/ group"`
	} `xml:"entry"`
}
func parseYoutubeFeedTime(t string) time.Time {
	parsedTime, err := time.Parse("2006-01-02T15:04:05-07:00", t)
	if err != nil {
		return time.Now()
	}
	return parsedTime
}
type video struct {
	ThumbnailUrl string
	Title        string
	Url          string
	Author       string
	AuthorUrl    string
	TimePosted   time.Time
}
type videoList []video
func (v videoList) sortByNewest() videoList {
	sort.Slice(v, func(i, j int) bool {
		return v[i].TimePosted.After(v[j].TimePosted)
	})
	return v
}
func fetchYoutubeChannelUploads(channelOrPlaylistIDs []string, videoUrlTemplate string, includeShorts bool) (videoList, error) {
	requests := make([]*http.Request, 0, len(channelOrPlaylistIDs))
	for i := range channelOrPlaylistIDs {
		var feedUrl string
		if strings.HasPrefix(channelOrPlaylistIDs[i], videosWidgetPlaylistPrefix) {
			feedUrl = "https://www.youtube.com/feeds/videos.xml?playlist_id=" +
				strings.TrimPrefix(channelOrPlaylistIDs[i], videosWidgetPlaylistPrefix)
		} else if !includeShorts && strings.HasPrefix(channelOrPlaylistIDs[i], "UC") {
			playlistId := strings.Replace(channelOrPlaylistIDs[i], "UC", "UULF", 1)
			feedUrl = "https://www.youtube.com/feeds/videos.xml?playlist_id=" + playlistId
		} else {
			feedUrl = "https://www.youtube.com/feeds/videos.xml?channel_id=" + channelOrPlaylistIDs[i]
		}
		request, _ := http.NewRequest("GET", feedUrl, nil)
		requests = append(requests, request)
	}
	job := newJob(decodeXmlFromRequestTask[youtubeFeedResponseXml](defaultHTTPClient), requests).withWorkers(30)
	responses, errs, err := workerPoolDo(job)
	if err != nil {
		return nil, fmt.Errorf("%w: %v", errNoContent, err)
	}
	videos := make(videoList, 0, len(channelOrPlaylistIDs)*15)
	var failed int
	for i := range responses {
		if errs[i] != nil {
			failed++
			slog.Error("Failed to fetch youtube feed", "channel", channelOrPlaylistIDs[i], "error", errs[i])
			continue
		}
		response := responses[i]
		for j := range response.Videos {
			v := &response.Videos[j]
			var videoUrl string
			if videoUrlTemplate == "" {
				videoUrl = v.Link.Href
			} else {
				parsedUrl, err := url.Parse(v.Link.Href)
				if err == nil {
					videoUrl = strings.ReplaceAll(videoUrlTemplate, "{VIDEO-ID}", parsedUrl.Query().Get("v"))
				} else {
					videoUrl = "#"
				}
			}
			videos = append(videos, video{
				ThumbnailUrl: v.Group.Thumbnail.Url,
				Title:        v.Title,
				Url:          videoUrl,
				Author:       response.Channel,
				AuthorUrl:    response.ChannelLink + "/videos",
				TimePosted:   parseYoutubeFeedTime(v.Published),
			})
		}
	}
	if len(videos) == 0 {
		return nil, errNoContent
	}
	videos.sortByNewest()
	if failed > 0 {
		return videos, fmt.Errorf("%w: missing videos from %d channels", errPartialContent, failed)
	}
	return videos, nil
}
</file>

<file path="internal/glance/widget-weather.go">
package glance
import (
	"context"
	"errors"
	"fmt"
	"html/template"
	"math"
	"net/http"
	"net/url"
	"slices"
	"strings"
	"time"
	_ "time/tzdata"
)
var weatherWidgetTemplate = mustParseTemplate("weather.html", "widget-base.html")
type weatherWidget struct {
	widgetBase   `yaml:",inline"`
	Location     string                      `yaml:"location"`
	ShowAreaName bool                        `yaml:"show-area-name"`
	HideLocation bool                        `yaml:"hide-location"`
	HourFormat   string                      `yaml:"hour-format"`
	Units        string                      `yaml:"units"`
	Place        *openMeteoPlaceResponseJson `yaml:"-"`
	Weather      *weather                    `yaml:"-"`
	TimeLabels   [12]string                  `yaml:"-"`
}
var timeLabels12h = [12]string{"2am", "4am", "6am", "8am", "10am", "12pm", "2pm", "4pm", "6pm", "8pm", "10pm", "12am"}
var timeLabels24h = [12]string{"02:00", "04:00", "06:00", "08:00", "10:00", "12:00", "14:00", "16:00", "18:00", "20:00", "22:00", "00:00"}
func (widget *weatherWidget) initialize() error {
	widget.withTitle("Weather").withCacheOnTheHour()
	if widget.Location == "" {
		return fmt.Errorf("location is required")
	}
	if widget.HourFormat == "" || widget.HourFormat == "12h" {
		widget.TimeLabels = timeLabels12h
	} else if widget.HourFormat == "24h" {
		widget.TimeLabels = timeLabels24h
	} else {
		return errors.New("hour-format must be either 12h or 24h")
	}
	if widget.Units == "" {
		widget.Units = "metric"
	} else if widget.Units != "metric" && widget.Units != "imperial" {
		return errors.New("units must be either metric or imperial")
	}
	return nil
}
func (widget *weatherWidget) update(ctx context.Context) {
	if widget.Place == nil {
		place, err := fetchOpenMeteoPlaceFromName(widget.Location)
		if err != nil {
			widget.withError(err).scheduleEarlyUpdate()
			return
		}
		widget.Place = place
	}
	weather, err := fetchWeatherForOpenMeteoPlace(widget.Place, widget.Units)
	if !widget.canContinueUpdateAfterHandlingErr(err) {
		return
	}
	widget.Weather = weather
}
func (widget *weatherWidget) Render() template.HTML {
	return widget.renderTemplate(widget, weatherWidgetTemplate)
}
type weather struct {
	Temperature         int
	ApparentTemperature int
	WeatherCode         int
	CurrentColumn       int
	SunriseColumn       int
	SunsetColumn        int
	Columns             []weatherColumn
}
func (w *weather) WeatherCodeAsString() string {
	if weatherCode, ok := weatherCodeTable[w.WeatherCode]; ok {
		return weatherCode
	}
	return ""
}
type openMeteoPlacesResponseJson struct {
	Results []openMeteoPlaceResponseJson
}
type openMeteoPlaceResponseJson struct {
	Name      string
	Area      string `json:"admin1"`
	Latitude  float64
	Longitude float64
	Timezone  string
	Country   string
	location  *time.Location
}
type openMeteoWeatherResponseJson struct {
	Daily struct {
		Sunrise []int64 `json:"sunrise"`
		Sunset  []int64 `json:"sunset"`
	} `json:"daily"`
	Hourly struct {
		Temperature              []float64 `json:"temperature_2m"`
		PrecipitationProbability []int     `json:"precipitation_probability"`
	} `json:"hourly"`
	Current struct {
		Temperature         float64 `json:"temperature_2m"`
		ApparentTemperature float64 `json:"apparent_temperature"`
		WeatherCode         int     `json:"weather_code"`
	} `json:"current"`
}
type weatherColumn struct {
	Temperature      int
	Scale            float64
	HasPrecipitation bool
}
var commonCountryAbbreviations = map[string]string{
	"US":  "United States",
	"USA": "United States",
	"UK":  "United Kingdom",
}
func expandCountryAbbreviations(name string) string {
	if expanded, ok := commonCountryAbbreviations[strings.TrimSpace(name)]; ok {
		return expanded
	}
	return name
}
// Separates the location that Open Meteo accepts from the administrative area
// which can then be used to filter to the correct place after the list of places
// has been retrieved. Also expands abbreviations since Open Meteo does not accept
// country names like "US", "USA" and "UK"
func parsePlaceName(name string) (string, string) {
	parts := strings.Split(name, ",")
	if len(parts) == 1 {
		return name, ""
	}
	if len(parts) == 2 {
		return parts[0] + ", " + expandCountryAbbreviations(parts[1]), ""
	}
	return parts[0] + ", " + expandCountryAbbreviations(parts[2]), strings.TrimSpace(parts[1])
}
func fetchOpenMeteoPlaceFromName(location string) (*openMeteoPlaceResponseJson, error) {
	location, area := parsePlaceName(location)
	requestUrl := fmt.Sprintf("https://geocoding-api.open-meteo.com/v1/search?name=%s&count=20&language=en&format=json", url.QueryEscape(location))
	request, _ := http.NewRequest("GET", requestUrl, nil)
	responseJson, err := decodeJsonFromRequest[openMeteoPlacesResponseJson](defaultHTTPClient, request)
	if err != nil {
		return nil, fmt.Errorf("fetching places data: %v", err)
	}
	if len(responseJson.Results) == 0 {
		return nil, fmt.Errorf("no places found for %s", location)
	}
	var place *openMeteoPlaceResponseJson
	if area != "" {
		area = strings.ToLower(area)
		for i := range responseJson.Results {
			if strings.ToLower(responseJson.Results[i].Area) == area {
				place = &responseJson.Results[i]
				break
			}
		}
		if place == nil {
			return nil, fmt.Errorf("no place found for %s in %s", location, area)
		}
	} else {
		place = &responseJson.Results[0]
	}
	loc, err := time.LoadLocation(place.Timezone)
	if err != nil {
		return nil, fmt.Errorf("loading location: %v", err)
	}
	place.location = loc
	return place, nil
}
func fetchWeatherForOpenMeteoPlace(place *openMeteoPlaceResponseJson, units string) (*weather, error) {
	query := url.Values{}
	var temperatureUnit string
	if units == "imperial" {
		temperatureUnit = "fahrenheit"
	} else {
		temperatureUnit = "celsius"
	}
	query.Add("latitude", fmt.Sprintf("%f", place.Latitude))
	query.Add("longitude", fmt.Sprintf("%f", place.Longitude))
	query.Add("timeformat", "unixtime")
	query.Add("timezone", place.Timezone)
	query.Add("forecast_days", "1")
	query.Add("current", "temperature_2m,apparent_temperature,weather_code")
	query.Add("hourly", "temperature_2m,precipitation_probability")
	query.Add("daily", "sunrise,sunset")
	query.Add("temperature_unit", temperatureUnit)
	requestUrl := "https://api.open-meteo.com/v1/forecast?" + query.Encode()
	request, _ := http.NewRequest("GET", requestUrl, nil)
	responseJson, err := decodeJsonFromRequest[openMeteoWeatherResponseJson](defaultHTTPClient, request)
	if err != nil {
		return nil, fmt.Errorf("%w: %v", errNoContent, err)
	}
	now := time.Now().In(place.location)
	bars := make([]weatherColumn, 0, 24)
	currentBar := now.Hour() / 2
	sunriseBar := (time.Unix(int64(responseJson.Daily.Sunrise[0]), 0).In(place.location).Hour()) / 2
	sunsetBar := (time.Unix(int64(responseJson.Daily.Sunset[0]), 0).In(place.location).Hour() - 1) / 2
	if sunsetBar < 0 {
		sunsetBar = 0
	}
	if len(responseJson.Hourly.Temperature) == 24 {
		temperatures := make([]int, 12)
		precipitations := make([]bool, 12)
		t := responseJson.Hourly.Temperature
		p := responseJson.Hourly.PrecipitationProbability
		for i := 0; i < 24; i += 2 {
			if i/2 == currentBar {
				temperatures[i/2] = int(responseJson.Current.Temperature)
			} else {
				temperatures[i/2] = int(math.Round((t[i] + t[i+1]) / 2))
			}
			precipitations[i/2] = (p[i]+p[i+1])/2 > 75
		}
		minT := slices.Min(temperatures)
		maxT := slices.Max(temperatures)
		temperaturesRange := float64(maxT - minT)
		for i := 0; i < 12; i++ {
			bars = append(bars, weatherColumn{
				Temperature:      temperatures[i],
				HasPrecipitation: precipitations[i],
			})
			if temperaturesRange > 0 {
				bars[i].Scale = float64(temperatures[i]-minT) / temperaturesRange
			} else {
				bars[i].Scale = 1
			}
		}
	}
	return &weather{
		Temperature:         int(responseJson.Current.Temperature),
		ApparentTemperature: int(responseJson.Current.ApparentTemperature),
		WeatherCode:         responseJson.Current.WeatherCode,
		CurrentColumn:       currentBar,
		SunriseColumn:       sunriseBar,
		SunsetColumn:        sunsetBar,
		Columns:             bars,
	}, nil
}
var weatherCodeTable = map[int]string{
	0:  "Clear Sky",
	1:  "Mainly Clear",
	2:  "Partly Cloudy",
	3:  "Overcast",
	45: "Fog",
	48: "Rime Fog",
	51: "Drizzle",
	53: "Drizzle",
	55: "Drizzle",
	56: "Drizzle",
	57: "Drizzle",
	61: "Rain",
	63: "Moderate Rain",
	65: "Heavy Rain",
	66: "Freezing Rain",
	67: "Freezing Rain",
	71: "Snow",
	73: "Moderate Snow",
	75: "Heavy Snow",
	77: "Snow Grains",
	80: "Rain",
	81: "Moderate Rain",
	82: "Heavy Rain",
	85: "Snow",
	86: "Snow",
	95: "Thunderstorm",
	96: "Thunderstorm",
	99: "Thunderstorm",
}
</file>

<file path="main.go">
package main
import (
	"os"
	"github.com/limpdev/banter/internal/glance"
)
func main() {
	os.Exit(glance.Main())
}
</file>

<file path="pkg/sysinfo/sysinfo.go">
package sysinfo
import (
	"fmt"
	"math"
	"os"
	"runtime"
	"sort"
	"strconv"
	"time"
	"github.com/shirou/gopsutil/v4/cpu"
	"github.com/shirou/gopsutil/v4/disk"
	"github.com/shirou/gopsutil/v4/host"
	"github.com/shirou/gopsutil/v4/load"
	"github.com/shirou/gopsutil/v4/mem"
	"github.com/shirou/gopsutil/v4/sensors"
)
type timestampJSON struct {
	time.Time
}
func (t timestampJSON) MarshalJSON() ([]byte, error) {
	return []byte(strconv.FormatInt(t.Unix(), 10)), nil
}
func (t *timestampJSON) UnmarshalJSON(data []byte) error {
	i, err := strconv.ParseInt(string(data), 10, 64)
	if err != nil {
		return err
	}
	t.Time = time.Unix(i, 0)
	return nil
}
type SystemInfo struct {
	HostInfoIsAvailable bool          `json:"host_info_is_available"`
	BootTime            timestampJSON `json:"boot_time"`
	Hostname            string        `json:"hostname"`
	Platform            string        `json:"platform"`
	CPU struct {
		LoadIsAvailable bool  `json:"load_is_available"`
		Load1Percent    uint8 `json:"load1_percent"`
		Load15Percent   uint8 `json:"load15_percent"`
		TemperatureIsAvailable bool  `json:"temperature_is_available"`
		TemperatureC           uint8 `json:"temperature_c"`
	} `json:"cpu"`
	Memory struct {
		IsAvailable bool   `json:"memory_is_available"`
		TotalMB     uint64 `json:"total_mb"`
		UsedMB      uint64 `json:"used_mb"`
		UsedPercent uint8  `json:"used_percent"`
		SwapIsAvailable bool   `json:"swap_is_available"`
		SwapTotalMB     uint64 `json:"swap_total_mb"`
		SwapUsedMB      uint64 `json:"swap_used_mb"`
		SwapUsedPercent uint8  `json:"swap_used_percent"`
	} `json:"memory"`
	Mountpoints []MountpointInfo `json:"mountpoints"`
}
type MountpointInfo struct {
	Path        string `json:"path"`
	Name        string `json:"name"`
	TotalMB     uint64 `json:"total_mb"`
	UsedMB      uint64 `json:"used_mb"`
	UsedPercent uint8  `json:"used_percent"`
}
type SystemInfoRequest struct {
	CPUTempSensor            string                       `yaml:"cpu-temp-sensor"`
	HideMountpointsByDefault bool                         `yaml:"hide-mountpoints-by-default"`
	Mountpoints              map[string]MointpointRequest `yaml:"mountpoints"`
}
type MointpointRequest struct {
	Name string `yaml:"name"`
	Hide *bool  `yaml:"hide"`
}
// Currently caches hostname indefinitely which isn't ideal
// Potential issue with caching boot time as it may not initially get reported correctly:
// https://github.com/shirou/gopsutil/issues/842#issuecomment-1908972344
type cacheableHostInfo struct {
	available bool
	hostname  string
	platform  string
	bootTime  timestampJSON
}
var cachedHostInfo cacheableHostInfo
func getHostInfo() (cacheableHostInfo, error) {
	var err error
	info := cacheableHostInfo{}
	info.hostname, err = os.Hostname()
	if err != nil {
		return info, err
	}
	info.platform, _, _, err = host.PlatformInformation()
	if err != nil {
		return info, err
	}
	bootTime, err := host.BootTime()
	if err != nil {
		return info, err
	}
	info.bootTime = timestampJSON{time.Unix(int64(bootTime), 0)}
	info.available = true
	return info, nil
}
func Collect(req *SystemInfoRequest) (*SystemInfo, []error) {
	if req == nil {
		req = &SystemInfoRequest{}
	}
	var errs []error
	addErr := func(err error) {
		errs = append(errs, err)
	}
	info := &SystemInfo{
		Mountpoints: []MountpointInfo{},
	}
	applyCachedHostInfo := func() {
		info.HostInfoIsAvailable = true
		info.BootTime = cachedHostInfo.bootTime
		info.Hostname = cachedHostInfo.hostname
		info.Platform = cachedHostInfo.platform
	}
	if cachedHostInfo.available {
		applyCachedHostInfo()
	} else {
		hostInfo, err := getHostInfo()
		if err == nil {
			cachedHostInfo = hostInfo
			applyCachedHostInfo()
		} else {
			addErr(fmt.Errorf("getting host info: %v", err))
		}
	}
	coreCount, err := cpu.Counts(true)
	if err == nil {
		loadAvg, err := load.Avg()
		if err == nil {
			info.CPU.LoadIsAvailable = true
			if runtime.GOOS == "windows" {
				// The numbers returned here seem unreliable on Windows. Even with the CPU pegged
				// at close to 50% for multiple minutes, load1 is sometimes way under or way over
				// with no clear pattern. Dividing by core count gives numbers that are way too
				// low so that's likely not necessary as it is with unix.
				info.CPU.Load1Percent = uint8(math.Min(loadAvg.Load1*100, 100))
				info.CPU.Load15Percent = uint8(math.Min(loadAvg.Load15*100, 100))
			} else {
				info.CPU.Load1Percent = uint8(math.Min((loadAvg.Load1/float64(coreCount))*100, 100))
				info.CPU.Load15Percent = uint8(math.Min((loadAvg.Load15/float64(coreCount))*100, 100))
			}
		} else {
			addErr(fmt.Errorf("getting load avg: %v", err))
		}
	} else {
		addErr(fmt.Errorf("getting core count: %v", err))
	}
	memory, err := mem.VirtualMemory()
	if err == nil {
		info.Memory.IsAvailable = true
		info.Memory.TotalMB = memory.Total / 1024 / 1024
		info.Memory.UsedMB = memory.Used / 1024 / 1024
		info.Memory.UsedPercent = uint8(math.Min(memory.UsedPercent, 100))
	} else {
		addErr(fmt.Errorf("getting memory info: %v", err))
	}
	swapMemory, err := mem.SwapMemory()
	if err == nil {
		info.Memory.SwapIsAvailable = true
		info.Memory.SwapTotalMB = swapMemory.Total / 1024 / 1024
		info.Memory.SwapUsedMB = swapMemory.Used / 1024 / 1024
		info.Memory.SwapUsedPercent = uint8(math.Min(swapMemory.UsedPercent, 100))
	} else {
		addErr(fmt.Errorf("getting swap memory info: %v", err))
	}
	// currently disabled on Windows because it requires elevated privilidges, otherwise
	// keeps returning a single sensor with key "ACPI\\ThermalZone\\TZ00_0" which
	// doesn't seem to be the CPU sensor or correspond to anything useful when
	// compared against the temperatures Libre Hardware Monitor reports.
	// Also disabled on the bsd's because it's not implemented by go-psutil for them
	if runtime.GOOS != "windows" && runtime.GOOS != "openbsd" && runtime.GOOS != "netbsd" && runtime.GOOS != "freebsd" {
		sensorReadings, err := sensors.SensorsTemperatures()
		_, errIsWarning := err.(*sensors.Warnings)
		if err == nil || errIsWarning {
			if req.CPUTempSensor != "" {
				for i := range sensorReadings {
					if sensorReadings[i].SensorKey == req.CPUTempSensor {
						info.CPU.TemperatureIsAvailable = true
						info.CPU.TemperatureC = uint8(sensorReadings[i].Temperature)
						break
					}
				}
				if !info.CPU.TemperatureIsAvailable {
					addErr(fmt.Errorf("CPU temperature sensor %s not found", req.CPUTempSensor))
				}
			} else if cpuTempSensor := inferCPUTempSensor(sensorReadings); cpuTempSensor != nil {
				info.CPU.TemperatureIsAvailable = true
				info.CPU.TemperatureC = uint8(cpuTempSensor.Temperature)
			}
		} else {
			addErr(fmt.Errorf("getting sensor readings: %v", err))
		}
	}
	addedMountpoints := map[string]struct{}{}
	addMountpointInfo := func(requestedPath string, mpReq MointpointRequest) {
		if _, exists := addedMountpoints[requestedPath]; exists {
			return
		}
		isHidden := req.HideMountpointsByDefault
		if mpReq.Hide != nil {
			isHidden = *mpReq.Hide
		}
		if isHidden {
			return
		}
		usage, err := disk.Usage(requestedPath)
		if err == nil {
			mpInfo := MountpointInfo{
				Path:        requestedPath,
				Name:        mpReq.Name,
				TotalMB:     usage.Total / 1024 / 1024,
				UsedMB:      usage.Used / 1024 / 1024,
				UsedPercent: uint8(math.Min(usage.UsedPercent, 100)),
			}
			info.Mountpoints = append(info.Mountpoints, mpInfo)
			addedMountpoints[requestedPath] = struct{}{}
		} else {
			addErr(fmt.Errorf("getting filesystem usage for %s: %v", requestedPath, err))
		}
	}
	if !req.HideMountpointsByDefault {
		filesystems, err := disk.Partitions(false)
		if err == nil {
			for _, fs := range filesystems {
				addMountpointInfo(fs.Mountpoint, req.Mountpoints[fs.Mountpoint])
			}
		} else {
			addErr(fmt.Errorf("getting filesystems: %v", err))
		}
	}
	for mountpoint, mpReq := range req.Mountpoints {
		addMountpointInfo(mountpoint, mpReq)
	}
	sort.Slice(info.Mountpoints, func(a, b int) bool {
		return info.Mountpoints[a].UsedPercent > info.Mountpoints[b].UsedPercent
	})
	return info, errs
}
func inferCPUTempSensor(sensors []sensors.TemperatureStat) *sensors.TemperatureStat {
	for i := range sensors {
		switch sensors[i].SensorKey {
		case
			"coretemp_package_id_0", // intel / linux
			"coretemp",              // intel / linux
			"k10temp",               // amd / linux
			"zenpower",              // amd / linux
			"cpu_thermal":           // raspberry pi / linux
			return &sensors[i]
		}
	}
	return nil
}
</file>

<file path="docs/glance.yml">
pages:
  - name: Home
    # Optionally, if you only have a single page you can hide the desktop navigation for a cleaner look
    # hide-desktop-navigation: true
    columns:
      - size: small
        widgets:
          - type: calendar
            first-day-of-week: monday
          - type: rss
            limit: 10
            collapse-after: 3
            cache: 12h
            feeds:
              - url: https://selfh.st/rss/
                title: selfh.st
                limit: 4
              - url: https://ciechanow.ski/atom.xml
              - url: https://www.joshwcomeau.com/rss.xml
                title: Josh Comeau
              - url: https://samwho.dev/rss.xml
              - url: https://ishadeed.com/feed.xml
                title: Ahmad Shadeed
          - type: twitch-channels
            channels:
              - theprimeagen
              - j_blow
              - giantwaffle
              - cohhcarnage
              - christitustech
              - EJ_SA
      - size: full
        widgets:
          - type: group
            widgets:
              - type: hacker-news
              - type: lobsters
          - type: videos
            channels:
              - UCXuqSBlHAE6Xw-yeJA0Tunw # Linus Tech Tips
              - UCR-DXc1voovS8nhAvccRZhg # Jeff Geerling
              - UCsBjURrPoezykLs9EqgamOA # Fireship
              - UCBJycsmduvYEL83R_U4JriQ # Marques Brownlee
              - UCHnyfMqiRRG1u-2MsSQLbXA # Veritasium
          - type: group
            widgets:
              - type: reddit
                subreddit: technology
                show-thumbnails: true
              - type: reddit
                subreddit: selfhosted
                show-thumbnails: true
      - size: small
        widgets:
          - type: weather
            location: London, United Kingdom
            units: metric # alternatively "imperial"
            hour-format: 12h # alternatively "24h"
            # Optionally hide the location from being displayed in the widget
            # hide-location: true
          - type: markets
            markets:
              - symbol: SPY
                name: S&P 500
              - symbol: BTC-USD
                name: Bitcoin
              - symbol: NVDA
                name: NVIDIA
              - symbol: AAPL
                name: Apple
              - symbol: MSFT
                name: Microsoft
          - type: releases
            cache: 1d
            # Without authentication the Github API allows for up to 60 requests per hour. You can create a
            # read-only token from your Github account settings and use it here to increase the limit.
            # token: ...
            repositories:
              - glanceapp/glance
              - go-gitea/gitea
              - immich-app/immich
              - syncthing/syncthing
  # Add more pages here:
  # - name: Your page name
  #   columns:
  #     - size: small
  #       widgets:
  #         # Add widgets here
  #     - size: full
  #       widgets:
  #         # Add widgets here
  #     - size: small
  #       widgets:
  #         # Add widgets here
</file>

<file path="internal/glance/cli.go">
package glance
import (
	"flag"
	"fmt"
	"os"
	"strings"
	"github.com/shirou/gopsutil/v4/disk"
	"github.com/shirou/gopsutil/v4/sensors"
)
type cliIntent uint8
const (
	cliIntentVersionPrint cliIntent = iota
	cliIntentServe
	cliIntentConfigValidate
	cliIntentConfigPrint
	cliIntentDiagnose
	cliIntentSensorsPrint
	cliIntentMountpointInfo
	cliIntentSecretMake
	cliIntentPasswordHash
)
type cliOptions struct {
	intent     cliIntent
	configPath string
	args       []string
}
func parseCliOptions() (*cliOptions, error) {
	var args []string
	args = os.Args[1:]
	if len(args) == 1 && (args[0] == "--version" || args[0] == "-v" || args[0] == "version") {
		return &cliOptions{
			intent: cliIntentVersionPrint,
		}, nil
	}
	flags := flag.NewFlagSet("", flag.ExitOnError)
	flags.Usage = func() {
		fmt.Println("Usage: glance [options] command")
		fmt.Println("\nOptions:")
		flags.PrintDefaults()
		fmt.Println("\nCommands:")
		fmt.Println("  config:validate       Validate the config file")
		fmt.Println("  config:print          Print the parsed config file with embedded includes")
		fmt.Println("  password:hash <pwd>   Hash a password")
		fmt.Println("  secret:make           Generate a random secret key")
		fmt.Println("  sensors:print         List all sensors")
		fmt.Println("  mountpoint:info       Print information about a given mountpoint path")
		fmt.Println("  diagnose              Run diagnostic checks")
	}
	configPath := flags.String("config", "glance.yml", "Set config path")
	err := flags.Parse(os.Args[1:])
	if err != nil {
		return nil, err
	}
	var intent cliIntent
	args = flags.Args()
	unknownCommandErr := fmt.Errorf("unknown command: %s", strings.Join(args, " "))
	if len(args) == 0 {
		intent = cliIntentServe
	} else if len(args) == 1 {
		if args[0] == "config:validate" {
			intent = cliIntentConfigValidate
		} else if args[0] == "config:print" {
			intent = cliIntentConfigPrint
		} else if args[0] == "sensors:print" {
			intent = cliIntentSensorsPrint
		} else if args[0] == "diagnose" {
			intent = cliIntentDiagnose
		} else if args[0] == "secret:make" {
			intent = cliIntentSecretMake
		} else {
			return nil, unknownCommandErr
		}
	} else if len(args) == 2 {
		if args[0] == "password:hash" {
			intent = cliIntentPasswordHash
		} else {
			return nil, unknownCommandErr
		}
	} else if len(args) == 2 {
		if args[0] == "mountpoint:info" {
			intent = cliIntentMountpointInfo
		} else {
			return nil, unknownCommandErr
		}
	} else {
		return nil, unknownCommandErr
	}
	return &cliOptions{
		intent:     intent,
		configPath: *configPath,
		args:       args,
	}, nil
}
func cliSensorsPrint() int {
	tempSensors, err := sensors.SensorsTemperatures()
	if err != nil {
		if warns, ok := err.(*sensors.Warnings); ok {
			fmt.Printf("Could not retrieve information for some sensors (%v):\n", err)
			for _, w := range warns.List {
				fmt.Printf(" - %v\n", w)
			}
			fmt.Println()
		} else {
			fmt.Printf("Failed to retrieve sensor information: %v\n", err)
			return 1
		}
	}
	if len(tempSensors) == 0 {
		fmt.Println("No sensors found")
		return 0
	}
	fmt.Println("Sensors found:")
	for _, sensor := range tempSensors {
		fmt.Printf(" %s: %.1f°C\n", sensor.SensorKey, sensor.Temperature)
	}
	return 0
}
func cliMountpointInfo(requestedPath string) int {
	usage, err := disk.Usage(requestedPath)
	if err != nil {
		fmt.Printf("Failed to retrieve info for path %s: %v\n", requestedPath, err)
		if warns, ok := err.(*disk.Warnings); ok {
			for _, w := range warns.List {
				fmt.Printf(" - %v\n", w)
			}
		}
		return 1
	}
	fmt.Println("Path:", usage.Path)
	fmt.Println("FS type:", ternary(usage.Fstype == "", "unknown", usage.Fstype))
	fmt.Printf("Used percent: %.1f%%\n", usage.UsedPercent)
	return 0
}
</file>

<file path="internal/glance/embed.go">
package glance
import (
	"bytes"
	"crypto/md5"
	"embed"
	"encoding/hex"
	"errors"
	"fmt"
	"io"
	"io/fs"
	"log"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
	"time"
)
//go:embed static
var _staticFS embed.FS
//go:embed templates
var _templateFS embed.FS
var staticFS, _ = fs.Sub(_staticFS, "static")
var templateFS, _ = fs.Sub(_templateFS, "templates")
func readAllFromStaticFS(path string) ([]byte, error) {
	// For some reason fs.FS only works with forward slashes, so in case we're
	// running on Windows or pass paths with backslashes we need to replace them.
	path = strings.ReplaceAll(path, "\\", "/")
	file, err := staticFS.Open(path)
	if err != nil {
		return nil, err
	}
	return io.ReadAll(file)
}
var staticFSHash = func() string {
	hash, err := computeFSHash(staticFS)
	if err != nil {
		log.Printf("Could not compute static assets cache key: %v", err)
		return strconv.FormatInt(time.Now().Unix(), 10)
	}
	return hash
}()
func computeFSHash(files fs.FS) (string, error) {
	hash := md5.New()
	err := fs.WalkDir(files, ".", func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if d.IsDir() {
			return nil
		}
		file, err := files.Open(path)
		if err != nil {
			return err
		}
		if _, err := io.Copy(hash, file); err != nil {
			return err
		}
		return nil
	})
	if err != nil {
		return "", err
	}
	return hex.EncodeToString(hash.Sum(nil))[:10], nil
}
var cssImportPattern = regexp.MustCompile(`(?m)^@import "(.*?)";$`)
var cssSingleLineCommentPattern = regexp.MustCompile(`(?m)^\s*\/\*.*?\*\/$`)
// Yes, we bundle at runtime, give comptime pls
var bundledCSSContents = func() []byte {
	const mainFilePath = "css/main.css"
	var recursiveParseImports func(path string, depth int) ([]byte, error)
	recursiveParseImports = func(path string, depth int) ([]byte, error) {
		if depth > 20 {
			return nil, errors.New("maximum import depth reached, is one of your imports circular?")
		}
		mainFileContents, err := readAllFromStaticFS(path)
		if err != nil {
			return nil, err
		}
		// Normalize line endings, otherwise the \r's make the regex not match
		mainFileContents = bytes.ReplaceAll(mainFileContents, []byte("\r\n"), []byte("\n"))
		mainFileDir := filepath.Dir(path)
		var importLastErr error
		parsed := cssImportPattern.ReplaceAllFunc(mainFileContents, func(match []byte) []byte {
			if importLastErr != nil {
				return nil
			}
			matches := cssImportPattern.FindSubmatch(match)
			if len(matches) != 2 {
				importLastErr = fmt.Errorf(
					"import didn't return expected number of capture groups: %s, expected 2, got %d",
					match, len(matches),
				)
				return nil
			}
			importFilePath := filepath.Join(mainFileDir, string(matches[1]))
			importContents, err := recursiveParseImports(importFilePath, depth+1)
			if err != nil {
				importLastErr = err
				return nil
			}
			return importContents
		})
		if importLastErr != nil {
			return nil, importLastErr
		}
		return parsed, nil
	}
	contents, err := recursiveParseImports(mainFilePath, 0)
	if err != nil {
		panic(fmt.Sprintf("building CSS bundle: %v", err))
	}
	// We could strip a bunch more unnecessary characters, but the biggest
	// win comes from removing the whitespace at the beginning of lines
	// since that's at least 4 bytes per property, which yielded a ~20% reduction.
	contents = cssSingleLineCommentPattern.ReplaceAll(contents, nil)
	contents = whitespaceAtBeginningOfLinePattern.ReplaceAll(contents, nil)
	contents = bytes.ReplaceAll(contents, []byte("\n"), []byte(""))
	return contents
}()
</file>

<file path="internal/glance/main.go">
package glance
import (
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"golang.org/x/crypto/bcrypt"
)
var buildVersion = "dev"
func Main() int {
	options, err := parseCliOptions()
	if err != nil {
		fmt.Println(err)
		return 1
	}
	switch options.intent {
	case cliIntentVersionPrint:
		fmt.Println(buildVersion)
	case cliIntentServe:
		// remove in v0.10.0
		if serveUpdateNoticeIfConfigLocationNotMigrated(options.configPath) {
			return 1
		}
		if err := serveApp(options.configPath); err != nil {
			fmt.Println(err)
			return 1
		}
	case cliIntentConfigValidate:
		contents, _, err := parseYAMLIncludes(options.configPath)
		if err != nil {
			fmt.Printf("Could not parse config file: %v\n", err)
			return 1
		}
		if _, err := newConfigFromYAML(contents); err != nil {
			fmt.Printf("Config file is invalid: %v\n", err)
			return 1
		}
	case cliIntentConfigPrint:
		contents, _, err := parseYAMLIncludes(options.configPath)
		if err != nil {
			fmt.Printf("Could not parse config file: %v\n", err)
			return 1
		}
		fmt.Println(string(contents))
	case cliIntentSensorsPrint:
		return cliSensorsPrint()
	case cliIntentMountpointInfo:
		return cliMountpointInfo(options.args[1])
	case cliIntentDiagnose:
		runDiagnostic()
	case cliIntentSecretMake:
		key, err := makeAuthSecretKey(AUTH_SECRET_KEY_LENGTH)
		if err != nil {
			fmt.Printf("Failed to make secret key: %v\n", err)
			return 1
		}
		fmt.Println(key)
	case cliIntentPasswordHash:
		password := options.args[1]
		if password == "" {
			fmt.Println("Password cannot be empty")
			return 1
		}
		if len(password) < 6 {
			fmt.Println("Password must be at least 6 characters long")
			return 1
		}
		hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
		if err != nil {
			fmt.Printf("Failed to hash password: %v\n", err)
			return 1
		}
		fmt.Println(string(hashedPassword))
	}
	return 0
}
func serveApp(configPath string) error {
	// TODO: refactor if this gets any more complex, the current implementation is
	// difficult to reason about due to all of the callbacks and simultaneous operations,
	// use a single goroutine and a channel to initiate synchronous changes to the server
	exitChannel := make(chan struct{})
	hadValidConfigOnStartup := false
	var stopServer func() error
	onChange := func(newContents []byte) {
		if stopServer != nil {
			log.Println("Config file changed, reloading...")
		}
		config, err := newConfigFromYAML(newContents)
		if err != nil {
			log.Printf("Config has errors: %v", err)
			if !hadValidConfigOnStartup {
				close(exitChannel)
			}
			return
		}
		app, err := newApplication(config)
		if err != nil {
			log.Printf("Failed to create application: %v", err)
			if !hadValidConfigOnStartup {
				close(exitChannel)
			}
			return
		}
		if !hadValidConfigOnStartup {
			hadValidConfigOnStartup = true
		}
		if stopServer != nil {
			if err := stopServer(); err != nil {
				log.Printf("Error while trying to stop server: %v", err)
			}
		}
		go func() {
			var startServer func() error
			startServer, stopServer = app.server()
			if err := startServer(); err != nil {
				log.Printf("Failed to start server: %v", err)
			}
		}()
	}
	onErr := func(err error) {
		log.Printf("Error watching config files: %v", err)
	}
	configContents, configIncludes, err := parseYAMLIncludes(configPath)
	if err != nil {
		return fmt.Errorf("parsing config: %w", err)
	}
	stopWatching, err := configFilesWatcher(configPath, configContents, configIncludes, onChange, onErr)
	if err == nil {
		defer stopWatching()
	} else {
		log.Printf("Error starting file watcher, config file changes will require a manual restart. (%v)", err)
		config, err := newConfigFromYAML(configContents)
		if err != nil {
			return fmt.Errorf("validating config file: %w", err)
		}
		app, err := newApplication(config)
		if err != nil {
			return fmt.Errorf("creating application: %w", err)
		}
		startServer, _ := app.server()
		if err := startServer(); err != nil {
			return fmt.Errorf("starting server: %w", err)
		}
	}
	<-exitChannel
	return nil
}
func serveUpdateNoticeIfConfigLocationNotMigrated(configPath string) bool {
	if !isRunningInsideDockerContainer() {
		return false
	}
	if _, err := os.Stat(configPath); err == nil {
		return false
	}
	// glance.yml wasn't mounted to begin with or was incorrectly mounted as a directory
	if stat, err := os.Stat("glance.yml"); err != nil || stat.IsDir() {
		return false
	}
	templateFile, _ := templateFS.Open("v0.7-update-notice-page.html")
	bodyContents, _ := io.ReadAll(templateFile)
	fmt.Println("!!! WARNING !!!")
	fmt.Println("The default location of glance.yml in the Docker image has changed starting from v0.7.0.")
	fmt.Println("Please see https://github.com/glanceapp/glance/blob/main/docs/v0.7.0-upgrade.md for more information.")
	mux := http.NewServeMux()
	mux.Handle("/static/", http.StripPrefix("/static/", http.FileServer(http.FS(staticFS))))
	mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusServiceUnavailable)
		w.Header().Set("Content-Type", "text/html")
		w.Write([]byte(bodyContents))
	})
	server := http.Server{
		Addr:    ":8080",
		Handler: mux,
	}
	server.ListenAndServe()
	return true
}
</file>

<file path="internal/glance/templates/bookmarks.html">
{{ template "widget-base.html" . }}
{{ define "widget-content" }}
<div class="dynamic-columns list-gap-24 list-with-separator">
    {{- range .Groups }}
    <div class="bookmarks-group"{{ if .Color }} style="--bookmarks-group-color: {{ .Color.String | safeCSS }}"{{ end }}>
        {{- if ne .Title "" }}
        <div class="bookmarks-group-title size-h3 margin-bottom-3">{{ .Title }}</div>
        {{- end }}
        <ul class="list list-gap-2">
        {{- range .Links }}
        <li>
            <div class="flex items-center gap-10">
                {{- if ne "" .Icon.URL }}
                <div class="bookmarks-icon-container">
                    <img class="bookmarks-icon{{ if .Icon.AutoInvert }} flat-icon{{ end }}" src="{{ .Icon.URL }}" alt="" loading="lazy">
                </div>
                {{- end }}
                <a href="{{ .URL | safeURL }}" class="bookmarks-link {{ if .HideArrow }}bookmarks-link-no-arrow {{ end }}color-highlight size-h4" {{ if .Target }}target="{{ .Target }}"{{ end }} rel="noreferrer">{{ .Title }}</a>
            </div>
            {{- if .Description }}
            <div class="margin-bottom-5">{{ .Description }}</div>
            {{- end }}
        </li>
        {{- end }}
        </ul>
    </div>
    {{- end }}
</div>
{{ end }}
</file>

<file path="internal/glance/templates/docker-containers.html">
{{ template "widget-base.html" . }}
{{- define "widget-content" }}
<ul class="dynamic-columns list-gap-20 list-with-separator">
    {{- range .Containers }}
    <li class="docker-container flex items-center gap-15">
        <div class="shrink-0" data-popover-type="html" data-popover-position="above" data-popover-offset="0.25" data-popover-margin="0.1rem" data-popover-max-width="400px" aria-hidden="true">
            <img class="docker-container-icon{{ if .Icon.AutoInvert }} flat-icon{{ end }}" src="{{ .Icon.URL }}" alt="" loading="lazy">
            <div data-popover-html>
                <div class="color-highlight text-truncate block">{{ .Image }}</div>
                <div>{{ .StateText }}</div>
                {{- if .Children }}
                <ul class="list list-gap-4 margin-top-10">
                    {{- range .Children }}
                    <li class="flex gap-7 items-center">
                        <div class="margin-bottom-3">{{ template "state-icon" .StateIcon }}</div>
                        <div class="color-highlight">{{ .Name }} <span class="size-h5 color-base">{{ .StateText }}</span></div>
                    </li>
                    {{- end }}
                </ul>
                {{- end }}
            </div>
        </div>
        <div class="min-width-0 grow">
            {{- if .URL }}
            <a href="{{ .URL | safeURL }}" class="color-highlight size-title-dynamic block text-truncate" {{ if not .SameTab }}target="_blank"{{ end }} rel="noreferrer">{{ .Name }}</a>
            {{- else }}
            <div class="color-highlight text-truncate size-title-dynamic">{{ .Name }}</div>
            {{- end }}
            {{- if .Description }}
            <div class="text-truncate">{{ .Description }}</div>
            {{- end }}
        </div>
        <div class="margin-left-auto shrink-0" data-popover-type="text" data-popover-position="above" data-popover-text="{{ .State }}" aria-label="{{ .State }}">
        {{ template "state-icon" .StateIcon }}
        </div>
        <div class="visually-hidden" aria-label="{{ .StateText }}"></div>
    </li>
    {{- else }}
    <div class="text-center">No containers available to show.</div>
    {{- end }}
</ul>
{{- end }}
{{- define "state-icon" }}
{{- if eq . "ok" }}
<svg class="docker-container-status-icon" fill="var(--color-positive)" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" aria-hidden="true">
    <path fill-rule="evenodd" d="M10 18a8 8 0 1 0 0-16 8 8 0 0 0 0 16Zm3.857-9.809a.75.75 0 0 0-1.214-.882l-3.483 4.79-1.88-1.88a.75.75 0 1 0-1.06 1.061l2.5 2.5a.75.75 0 0 0 1.137-.089l4-5.5Z" clip-rule="evenodd" />
</svg>
{{- else if eq . "warn" }}
<svg class="docker-container-status-icon" fill="var(--color-negative)" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" aria-hidden="true">
    <path fill-rule="evenodd" d="M8.485 2.495c.673-1.167 2.357-1.167 3.03 0l6.28 10.875c.673 1.167-.17 2.625-1.516 2.625H3.72c-1.347 0-2.189-1.458-1.515-2.625L8.485 2.495ZM10 5a.75.75 0 0 1 .75.75v3.5a.75.75 0 0 1-1.5 0v-3.5A.75.75 0 0 1 10 5Zm0 9a1 1 0 1 0 0-2 1 1 0 0 0 0 2Z" clip-rule="evenodd" />
</svg>
{{- else if eq . "paused" }}
<svg class="docker-container-status-icon" fill="var(--color-text-base)" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" aria-hidden="true">
    <path fill-rule="evenodd" d="M2 10a8 8 0 1 1 16 0 8 8 0 0 1-16 0Zm5-2.25A.75.75 0 0 1 7.75 7h.5a.75.75 0 0 1 .75.75v4.5a.75.75 0 0 1-.75.75h-.5a.75.75 0 0 1-.75-.75v-4.5Zm4 0a.75.75 0 0 1 .75-.75h.5a.75.75 0 0 1 .75.75v4.5a.75.75 0 0 1-.75.75h-.5a.75.75 0 0 1-.75-.75v-4.5Z" clip-rule="evenodd" />
</svg>
{{- else }}
<svg class="docker-container-status-icon" fill="var(--color-text-base)" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" aria-hidden="true">
    <path fill-rule="evenodd" d="M18 10a8 8 0 1 1-16 0 8 8 0 0 1 16 0ZM8.94 6.94a.75.75 0 1 1-1.061-1.061 3 3 0 1 1 2.871 5.026v.345a.75.75 0 0 1-1.5 0v-.5c0-.72.57-1.172 1.081-1.287A1.5 1.5 0 1 0 8.94 6.94ZM10 15a1 1 0 1 0 0-2 1 1 0 0 0 0 2Z" clip-rule="evenodd" />
</svg>
{{- end }}
{{- end }}
</file>

<file path="internal/glance/templates/forum-posts.html">
{{ template "widget-base.html" . }}
{{- define "widget-content" }}
<ul class="list list-gap-14 collapsible-container" data-collapse-after="{{ .CollapseAfter }}">
    {{- range .Posts }}
    <li>
        <div class="flex gap-10 row-reverse-on-mobile thumbnail-parent">
            {{- if $.ShowThumbnails }}
            {{- if .IsCrosspost }}
            <svg class="forum-post-list-thumbnail hide-on-mobile" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="-9 -8 40 40" stroke-width="1.5" stroke="var(--color-text-subdue)">
                <path stroke-linecap="round" stroke-linejoin="round" d="M7.5 21 3 16.5m0 0L7.5 12M3 16.5h13.5m0-13.5L21 7.5m0 0L16.5 12M21 7.5H7.5" />
            </svg>
            {{- else if .ThumbnailUrl }}
            <img class="forum-post-list-thumbnail thumbnail" src="{{ .ThumbnailUrl }}" alt="" loading="lazy">
            {{- else if .TargetUrl }}
            <svg class="forum-post-list-thumbnail hide-on-mobile" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="-9 -8 40 40" stroke-width="1.5" stroke="var(--color-text-subdue)">
                <path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 0 1 1.242 7.244l-4.5 4.5a4.5 4.5 0 0 1-6.364-6.364l1.757-1.757m13.35-.622 1.757-1.757a4.5 4.5 0 0 0-6.364-6.364l-4.5 4.5a4.5 4.5 0 0 0 1.242 7.244" />
            </svg>
            {{- else }}
            <svg class="forum-post-list-thumbnail hide-on-mobile" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="-9 -8 40 40" stroke-width="1.5" stroke="var(--color-text-subdue)">
                <path stroke-linecap="round" stroke-linejoin="round" d="M7.5 8.25h9m-9 3H12m-9.75 1.51c0 1.6 1.123 2.994 2.707 3.227 1.129.166 2.27.293 3.423.379.35.026.67.21.865.501L12 21l2.755-4.133a1.14 1.14 0 0 1 .865-.501 48.172 48.172 0 0 0 3.423-.379c1.584-.233 2.707-1.626 2.707-3.228V6.741c0-1.602-1.123-2.995-2.707-3.228A48.394 48.394 0 0 0 12 3c-2.392 0-4.744.175-7.043.513C3.373 3.746 2.25 5.14 2.25 6.741v6.018Z" />
            </svg>
            {{- end }}
            {{- end }}
            <div class="grow min-width-0">
                <a href="{{ .DiscussionUrl | safeURL }}" class="size-title-dynamic color-primary-if-not-visited" target="_blank" rel="noreferrer">{{ .Title }}</a>
                {{- if .Tags }}
                <div class="inline-block forum-post-tags-container">
                    <ul class="attachments">
                    {{- range .Tags }}
                    <li>{{ . }}</li>
                    {{- end }}
                    </ul>
                </div>
                {{- end }}
                <ul class="list-horizontal-text flex-nowrap text-compact">
                    <li {{ dynamicRelativeTimeAttrs .TimePosted }}></li>
                    <li class="shrink-0">{{ .Score | formatApproxNumber }} points</li>
                    <li class="shrink-0{{ if .TargetUrl | safeURL }} forum-post-autohide{{ end }}">{{ .CommentCount | formatApproxNumber }} comments</li>
                    {{- if .TargetUrl }}
                    <li class="min-width-0"><a class="visited-indicator text-truncate block" href="{{ .TargetUrl }}" target="_blank" rel="noreferrer">{{ .TargetUrlDomain }}</a></li>
                    {{- end }}
                </ul>
            </div>
        </div>
    </li>
    {{- end }}
</ul>
{{- end }}
</file>

<file path="internal/glance/templates/group.html">
{{ template "widget-base.html" . }}
{{ define "widget-content-classes" }}widget-content-frameless{{ end }}
{{ define "widget-content" }}
<div x-data="{ currentTab: 0 }">
    <div class="widget-group-header">
        <div class="widget-header gap-20" role="tablist">
            {{- range $i, $widget := .Widgets }}
            <button class="widget-group-title{{ if eq $i 0 }} widget-group-title-current{{ end }}"
                :class="{ 'widget-group-title-current': currentTab === {{ $i }} }" @click="currentTab = {{ $i }}" {{ if
                ne "" .TitleURL }} data-title-url="{{ .TitleURL }}" {{ end }}
                aria-selected="{{ if eq $i 0 }}true{{ else }}false{{ end }}"
                :aria-selected="currentTab === {{ $i }} ? 'true' : 'false'" arial-level="2" role="tab"
                aria-controls="widget-{{ $.GetID }}-tabpanel-{{ $i }}" id="widget-{{ $.GetID }}-tab-{{ $i }}">
                {{ $widget.Title }}
            </button>
            {{- end }}
        </div>
    </div>
    <div class="widget-group-contents">
        {{- range $i, $widget := .Widgets }}
        <div class="widget-group-content{{ if eq $i 0 }} widget-group-content-current{{ end }}"
            :class="{ 'widget-group-content-current': currentTab === {{ $i }} }" x-show="currentTab === {{ $i }}"
            id="widget-{{ $.GetID }}-tabpanel-{{ $i }}" role="tabpanel"
            aria-labelledby="widget-{{ $.GetID }}-tab-{{ $i }}"
            aria-hidden="{{ if eq $i 0 }}false{{ else }}true{{ end }}"
            :aria-hidden="currentTab === {{ $i }} ? 'false' : 'true'">
            {{- .Render -}}
        </div>
        {{- end }}
    </div>
</div>
{{ end }}
</file>

<file path="internal/glance/templates/monitor.html">
{{ template "widget-base.html" . }}
{{ define "widget-content" }}
{{ if not (and .ShowFailingOnly (not .HasFailing)) }}
<ul class="dynamic-columns list-gap-20 list-with-separator">
    {{ range .Sites }}
    {{ if and $.ShowFailingOnly (eq .StatusStyle "ok" ) }} {{ continue }} {{ end }}
    <div class="monitor-site flex items-center gap-15">
        {{ template "site" . }}
    </div>
    {{ end }}
</ul>
{{ else }}
<div class="flex items-center justify-center gap-10 padding-block-5">
    <p>All sites are online</p>
    <svg class="shrink-0" style="width: 1.7rem;" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="var(--color-positive)">
        <path fill-rule="evenodd" d="M2.25 12c0-5.385 4.365-9.75 9.75-9.75s9.75 4.365 9.75 9.75-4.365 9.75-9.75 9.75S2.25 17.385 2.25 12Zm13.36-1.814a.75.75 0 1 0-1.22-.872l-3.236 4.53L9.53 12.22a.75.75 0 0 0-1.06 1.06l2.25 2.25a.75.75 0 0 0 1.14-.094l3.75-5.25Z" clip-rule="evenodd" />
    </svg>
</div>
{{ end }}
{{ end }}
{{ define "site" }}
{{ if .Icon.URL }}
<img class="monitor-site-icon{{ if .Icon.AutoInvert }} flat-icon{{ end }}" src="{{ .Icon.URL }}" alt="" loading="lazy">
{{ end }}
<div class="grow min-width-0">
    <a class="size-h3 color-highlight text-truncate block" href="{{ .URL | safeURL }}" {{ if not .SameTab }}target="_blank"{{ end }} rel="noreferrer">{{ .Title }}</a>
    <ul class="list-horizontal-text">
        {{ if not .Status.Error }}
        <li title="{{ .Status.Code }}">{{ .StatusText }}</li>
        <li>{{ .Status.ResponseTime.Milliseconds | formatNumber }}ms</li>
        {{ else if .Status.TimedOut }}
        <li class="color-negative">Timed Out</li>
        {{ else }}
        <li class="color-negative" title="{{ .Status.Error }}">ERROR</li>
        {{ end }}
    </ul>
</div>
{{ if eq .StatusStyle "ok" }}
<div class="monitor-site-status-icon">
    <svg fill="var(--color-positive)" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20">
        <path fill-rule="evenodd" d="M10 18a8 8 0 1 0 0-16 8 8 0 0 0 0 16Zm3.857-9.809a.75.75 0 0 0-1.214-.882l-3.483 4.79-1.88-1.88a.75.75 0 1 0-1.06 1.061l2.5 2.5a.75.75 0 0 0 1.137-.089l4-5.5Z" clip-rule="evenodd" />
    </svg>
</div>
{{ else }}
<div class="monitor-site-status-icon">
    <svg fill="var(--color-negative)" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20">
        <path fill-rule="evenodd" d="M8.485 2.495c.673-1.167 2.357-1.167 3.03 0l6.28 10.875c.673 1.167-.17 2.625-1.516 2.625H3.72c-1.347 0-2.189-1.458-1.515-2.625L8.485 2.495ZM10 5a.75.75 0 0 1 .75.75v3.5a.75.75 0 0 1-1.5 0v-3.5A.75.75 0 0 1 10 5Zm0 9a1 1 0 1 0 0-2 1 1 0 0 0 0 2Z" clip-rule="evenodd" />
    </svg>
</div>
{{ end }}
{{ end }}
</file>

<file path="internal/glance/templates/videos-vertical-list.html">
{{ template "widget-base.html" . }}
{{- define "widget-content" }}
<ul class="list list-gap-14 collapsible-container" data-collapse-after="{{ .CollapseAfter }}">
    {{- range .Videos }}
    <li class="flex thumbnail-parent gap-10 items-center">
        <img class="video-horizontal-list-thumbnail thumbnail" loading="lazy" src="{{ .ThumbnailUrl }}" alt="">
        <div class="min-width-0">
            <a class="block text-truncate color-primary-if-not-visited" href="{{ .Url | safeURL }}" target="_blank" rel="noreferrer">{{ .Title }}</a>
            <ul class="list-horizontal-text flex-nowrap">
                <li class="shrink-0" {{ dynamicRelativeTimeAttrs .TimePosted }}></li>
                <li class="min-width-0">
                    <a class="block text-truncate" href="{{ .AuthorUrl }}" target="_blank" rel="noreferrer">{{ .Author }}</a>
                </li>
            </ul>
        </div>
    </li>
    {{- end }}
</ul>
{{- end }}
</file>

<file path="internal/glance/widget-monitor.go">
package glance
import (
	"context"
	"errors"
	"html/template"
	"net/http"
	"slices"
	"strconv"
	"time"
)
var (
	monitorWidgetTemplate        = mustParseTemplate("monitor.html", "widget-base.html")
	monitorWidgetCompactTemplate = mustParseTemplate("monitor-compact.html", "widget-base.html")
)
type monitorWidget struct {
	widgetBase `yaml:",inline"`
	Sites      []struct {
		*SiteStatusRequest `yaml:",inline"`
		Status             *siteStatus     `yaml:"-"`
		URL                string          `yaml:"-"`
		ErrorURL           string          `yaml:"error-url"`
		Title              string          `yaml:"title"`
		Icon               customIconField `yaml:"icon"`
		SameTab            bool            `yaml:"same-tab"`
		StatusText         string          `yaml:"-"`
		StatusStyle        string          `yaml:"-"`
		AltStatusCodes     []int           `yaml:"alt-status-codes"`
	} `yaml:"sites"`
	Style           string `yaml:"style"`
	ShowFailingOnly bool   `yaml:"show-failing-only"`
	HasFailing      bool   `yaml:"-"`
}
func (widget *monitorWidget) initialize() error {
	widget.withTitle("Monitor").withCacheDuration(5 * time.Minute)
	return nil
}
func (widget *monitorWidget) setProviders(providers *widgetProviders) {
	widget.widgetBase.setProviders(providers)
	if providers != nil && providers.hub != nil {
		go func() {
			dur := widget.cacheDuration
			if dur <= 0 {
				dur = 5 * time.Minute
			}
			ticker := time.NewTicker(dur)
			defer ticker.Stop()
			for range ticker.C {
				widget.update(context.Background())
				providers.hub.broadcastHTML(string(widget.Render()))
			}
		}()
	}
}
func (widget *monitorWidget) update(ctx context.Context) {
	requests := make([]*SiteStatusRequest, len(widget.Sites))
	for i := range widget.Sites {
		requests[i] = widget.Sites[i].SiteStatusRequest
	}
	statuses, err := fetchStatusForSites(requests)
	if !widget.canContinueUpdateAfterHandlingErr(err) {
		return
	}
	widget.HasFailing = false
	for i := range widget.Sites {
		site := &widget.Sites[i]
		status := &statuses[i]
		site.Status = status
		if !slices.Contains(site.AltStatusCodes, status.Code) && (status.Code >= 400 || status.Error != nil) {
			widget.HasFailing = true
		}
		if status.Error != nil && site.ErrorURL != "" {
			site.URL = site.ErrorURL
		} else {
			site.URL = site.DefaultURL
		}
		site.StatusText = statusCodeToText(status.Code, site.AltStatusCodes)
		site.StatusStyle = statusCodeToStyle(status.Code, site.AltStatusCodes)
	}
}
func (widget *monitorWidget) Render() template.HTML {
	if widget.Style == "compact" {
		return widget.renderTemplate(widget, monitorWidgetCompactTemplate)
	}
	return widget.renderTemplate(widget, monitorWidgetTemplate)
}
func statusCodeToText(status int, altStatusCodes []int) string {
	if status == 200 || slices.Contains(altStatusCodes, status) {
		return "OK"
	}
	if status == 404 {
		return "Not Found"
	}
	if status == 403 {
		return "Forbidden"
	}
	if status == 401 {
		return "Unauthorized"
	}
	if status >= 500 {
		return "Server Error"
	}
	if status >= 400 {
		return "Client Error"
	}
	return strconv.Itoa(status)
}
func statusCodeToStyle(status int, altStatusCodes []int) string {
	if status == 200 || slices.Contains(altStatusCodes, status) {
		return "ok"
	}
	return "error"
}
type SiteStatusRequest struct {
	DefaultURL    string        `yaml:"url"`
	CheckURL      string        `yaml:"check-url"`
	AllowInsecure bool          `yaml:"allow-insecure"`
	Timeout       durationField `yaml:"timeout"`
	BasicAuth     struct {
		Username string `yaml:"username"`
		Password string `yaml:"password"`
	} `yaml:"basic-auth"`
}
type siteStatus struct {
	Code         int
	TimedOut     bool
	ResponseTime time.Duration
	Error        error
}
func fetchSiteStatusTask(statusRequest *SiteStatusRequest) (siteStatus, error) {
	var url string
	if statusRequest.CheckURL != "" {
		url = statusRequest.CheckURL
	} else {
		url = statusRequest.DefaultURL
	}
	timeout := ternary(statusRequest.Timeout > 0, time.Duration(statusRequest.Timeout), 3*time.Second)
	ctx, cancel := context.WithTimeout(context.Background(), timeout)
	defer cancel()
	request, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)
	if err != nil {
		return siteStatus{
			Error: err,
		}, nil
	}
	if statusRequest.BasicAuth.Username != "" || statusRequest.BasicAuth.Password != "" {
		request.SetBasicAuth(statusRequest.BasicAuth.Username, statusRequest.BasicAuth.Password)
	}
	requestSentAt := time.Now()
	var response *http.Response
	if !statusRequest.AllowInsecure {
		response, err = defaultHTTPClient.Do(request)
	} else {
		response, err = defaultInsecureHTTPClient.Do(request)
	}
	status := siteStatus{ResponseTime: time.Since(requestSentAt)}
	if err != nil {
		if errors.Is(err, context.DeadlineExceeded) {
			status.TimedOut = true
		}
		status.Error = err
		return status, nil
	}
	defer response.Body.Close()
	status.Code = response.StatusCode
	return status, nil
}
func fetchStatusForSites(requests []*SiteStatusRequest) ([]siteStatus, error) {
	job := newJob(fetchSiteStatusTask, requests).withWorkers(20)
	results, _, err := workerPoolDo(job)
	if err != nil {
		return nil, err
	}
	return results, nil
}
</file>

<file path="internal/glance/widget-todo.go">
package glance
import (
	"html/template"
)
var todoWidgetTemplate = mustParseTemplate("todo.html", "widget-base.html")
type todoWidget struct {
	widgetBase `yaml:",inline"`
	cachedHTML template.HTML `yaml:"-"`
	TodoID     string        `yaml:"id"`
}
func (widget *todoWidget) initialize() error {
	widget.withTitle("To-do").withError(nil)
	widget.cachedHTML = widget.renderTemplate(widget, todoWidgetTemplate)
	return nil
}
func (widget *todoWidget) Render() template.HTML {
	return widget.cachedHTML
}
</file>

<file path="internal/glance/widget-utils.go">
package glance
import (
	"context"
	"crypto/tls"
	"encoding/json"
	"encoding/xml"
	"errors"
	"fmt"
	"io"
	"math/rand/v2"
	"net/http"
	"strconv"
	"sync"
	"sync/atomic"
	"time"
)
var (
	errNoContent      = errors.New("failed to retrieve any content")
	errPartialContent = errors.New("failed to retrieve some of the content")
)
const defaultClientTimeout = 5 * time.Second
var defaultHTTPClient = &http.Client{
	Transport: &http.Transport{
		MaxIdleConnsPerHost: 10,
		Proxy:               http.ProxyFromEnvironment,
	},
	Timeout: defaultClientTimeout,
}
var defaultInsecureHTTPClient = &http.Client{
	Timeout: defaultClientTimeout,
	Transport: &http.Transport{
		TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
		Proxy:           http.ProxyFromEnvironment,
	},
}
type requestDoer interface {
	Do(*http.Request) (*http.Response, error)
}
var glanceUserAgentString = "Glance/" + buildVersion + " +https://github.com/glanceapp/glance"
var userAgentPersistentVersion atomic.Int32
func getBrowserUserAgentHeader() string {
	if rand.IntN(2000) == 0 {
		userAgentPersistentVersion.Store(rand.Int32N(5))
	}
	version := strconv.Itoa(130 + int(userAgentPersistentVersion.Load()))
	return "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:" + version + ".0) Gecko/20100101 Firefox/" + version + ".0"
}
func setBrowserUserAgentHeader(request *http.Request) {
	request.Header.Set("User-Agent", getBrowserUserAgentHeader())
}
func decodeJsonFromRequest[T any](client requestDoer, request *http.Request) (T, error) {
	var result T
	response, err := client.Do(request)
	if err != nil {
		return result, err
	}
	defer response.Body.Close()
	body, err := io.ReadAll(response.Body)
	if err != nil {
		return result, err
	}
	if response.StatusCode != http.StatusOK {
		truncatedBody, _ := limitStringLength(string(body), 256)
		return result, fmt.Errorf(
			"unexpected status code %d from %s, response: %s",
			response.StatusCode,
			request.URL,
			truncatedBody,
		)
	}
	err = json.Unmarshal(body, &result)
	if err != nil {
		return result, err
	}
	return result, nil
}
func decodeJsonFromRequestTask[T any](client requestDoer) func(*http.Request) (T, error) {
	return func(request *http.Request) (T, error) {
		return decodeJsonFromRequest[T](client, request)
	}
}
// TODO: tidy up, these are a copy of the above but with a line changed
func decodeXmlFromRequest[T any](client requestDoer, request *http.Request) (T, error) {
	var result T
	response, err := client.Do(request)
	if err != nil {
		return result, err
	}
	defer response.Body.Close()
	body, err := io.ReadAll(response.Body)
	if err != nil {
		return result, err
	}
	if response.StatusCode != http.StatusOK {
		truncatedBody, _ := limitStringLength(string(body), 256)
		return result, fmt.Errorf(
			"unexpected status code %d for %s, response: %s",
			response.StatusCode,
			request.URL,
			truncatedBody,
		)
	}
	err = xml.Unmarshal(body, &result)
	if err != nil {
		return result, err
	}
	return result, nil
}
func decodeXmlFromRequestTask[T any](client requestDoer) func(*http.Request) (T, error) {
	return func(request *http.Request) (T, error) {
		return decodeXmlFromRequest[T](client, request)
	}
}
type workerPoolTask[I any, O any] struct {
	index  int
	input  I
	output O
	err    error
}
type workerPoolJob[I any, O any] struct {
	data    []I
	workers int
	task    func(I) (O, error)
	ctx     context.Context
}
const defaultNumWorkers = 10
func (job *workerPoolJob[I, O]) withWorkers(workers int) *workerPoolJob[I, O] {
	if workers == 0 {
		job.workers = defaultNumWorkers
	} else {
		job.workers = min(workers, len(job.data))
	}
	return job
}
// func (job *workerPoolJob[I, O]) withContext(ctx context.Context) *workerPoolJob[I, O] {
// 	if ctx != nil {
// 		job.ctx = ctx
// 	}
// 	return job
// }
func newJob[I any, O any](task func(I) (O, error), data []I) *workerPoolJob[I, O] {
	return &workerPoolJob[I, O]{
		workers: defaultNumWorkers,
		task:    task,
		data:    data,
		ctx:     context.Background(),
	}
}
func workerPoolDo[I any, O any](job *workerPoolJob[I, O]) ([]O, []error, error) {
	results := make([]O, len(job.data))
	errs := make([]error, len(job.data))
	if len(job.data) == 0 {
		return results, errs, nil
	}
	if len(job.data) == 1 {
		results[0], errs[0] = job.task(job.data[0])
		return results, errs, nil
	}
	tasksQueue := make(chan *workerPoolTask[I, O])
	resultsQueue := make(chan *workerPoolTask[I, O])
	var wg sync.WaitGroup
	for range job.workers {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for t := range tasksQueue {
				t.output, t.err = job.task(t.input)
				resultsQueue <- t
			}
		}()
	}
	var err error
	go func() {
	loop:
		for i := range job.data {
			select {
			default:
				tasksQueue <- &workerPoolTask[I, O]{
					index: i,
					input: job.data[i],
				}
			case <-job.ctx.Done():
				err = job.ctx.Err()
				break loop
			}
		}
		close(tasksQueue)
		wg.Wait()
		close(resultsQueue)
	}()
	for task := range resultsQueue {
		errs[task.index] = task.err
		results[task.index] = task.output
	}
	return results, errs, err
}
</file>

<file path="taskfile.yml">
# yaml-language-server: $schema=https://taskfile.dev/schema.json
version: "3"
# ---------------------------------------------------------------------------
# System-aware variables — resolved at runtime, not at parse time.
# ---------------------------------------------------------------------------
vars:
  # ── Binary name ──────────────────────────────────────────────────────────
  APP_NAME: "app"
  # ── OS / Arch detection ──────────────────────────────────────────────────
  GOOS:
    sh: go env GOOS
  GOARCH:
    sh: go env GOARCH
  # Binary extension on Windows
  EXT:
    sh: |
      if [ "$(go env GOOS)" = "windows" ]; then echo ".exe"; else echo ""; fi
  # ── Output paths ─────────────────────────────────────────────────────────
  BIN_DIR: "./bin"
  DIST_DIR: "./dist"
  BINARY: "{{.BIN_DIR}}/{{.APP_NAME}}{{.EXT}}"
  # ── Common ldflags ───────────────────────────────────────────────────────
  PKG_PREFIX: "{{.MODULE}}/internal/version"
  LDFLAGS: >-
    -s -w
    -X '{{.PKG_PREFIX}}.Commit={{.GIT_COMMIT}}'
  # ── Go tooling ───────────────────────────────────────────────────────────
  GO_CMD: "go"
  GOFLAGS: ""
  # ── Test config ──────────────────────────────────────────────────────────
  TEST_FLAGS: "-race -timeout 120s"
  COVERAGE_OUT: "./coverage.out"
  COVERAGE_HTML: "./coverage.html"
  # ── Module / package ─────────────────────────────────────────────────────
  MODULE:
    sh: go list -m 2>/dev/null || echo "unknown"
  GIT_COMMIT:
    sh: git rev-parse --short HEAD 2>/dev/null || echo "unknown"
  #  CUSTOM VARIABLES
  SUMEXT: "**/*.go,**/*.html,**/*.css,**/*.yml"
  IGNOREXT: ".secrets"
env:
  CGO_ENABLED: "0" # safe default; override per-task if needed
  GOFLAGS: "{{.GOFLAGS}}"
# ---------------------------------------------------------------------------
# Tasks
# ---------------------------------------------------------------------------
tasks:
  opts:
    desc: "Show available tasks"
    silent: true
    cmds:
      - task --list
  build:
    desc: "Build for the current OS/arch ({{.GOOS}}/{{.GOARCH}})"
    vars:
      BINARY: "{{.BIN_DIR}}/{{.APP_NAME}}{{.EXT}}"
    cmds:
      - mkdir -p {{.BIN_DIR}}
      - >-
        {{.GO_CMD}} build
        -trimpath
        -ldflags "{{.LDFLAGS}}"
        -o {{.BINARY}}
        ./...
    generates:
      - "{{.BINARY}}"
    sources:
      - "**/*.go"
      - "go.mod"
      - "go.sum"
  build:darwin:
    desc: "Cross-compile → darwin/arm64 (Apple Silicon)"
    env:
      GOOS: darwin
      GOARCH: arm64
      CGO_ENABLED: "0"
    cmds:
      - mkdir -p {{.DIST_DIR}}
      - >-
        {{.GO_CMD}} build
        -trimpath
        -ldflags "{{.LDFLAGS}}"
        -o {{.DIST_DIR}}/{{.APP_NAME}}-darwin-arm64
        ./...
  build:windows:
    desc: "Cross-compile → windows/amd64"
    env:
      GOOS: windows
      GOARCH: amd64
      CGO_ENABLED: "0"
    cmds:
      - mkdir -p {{.DIST_DIR}}
      - >-
        {{.GO_CMD}} build
        -trimpath
        -ldflags "{{.LDFLAGS}}"
        -o {{.DIST_DIR}}/{{.APP_NAME}}-windows-amd64.exe
        ./...
  build:all:
    desc: "Cross-compile for all supported platforms → dist/"
    deps:
      - build:darwin
      - build:windows
    cmds:
      - echo "✅  All platform binaries written to {{.DIST_DIR}}/"
  run:
    desc: "Build & run (pass args with -- <args>)"
    deps: [build]
    cmds:
      - "{{.BINARY}} {{.CLI_ARGS}}"
  # ── Lint / vet ────────────────────────────────────────────────────────────
  vet:
    desc: "Run go vet"
    cmds:
      - "{{.GO_CMD}} vet ./..."
  lint:
    desc: "Run golangci-lint (installs if missing)"
    cmds:
      - |
        if ! command -v golangci-lint &>/dev/null; then
          echo "⬇️  Installing golangci-lint {{.GOLANGCI_VERSION}} …"
          go install github.com/golangci/golangci-lint/cmd/golangci-lint@{{.GOLANGCI_VERSION}}
        fi
      - golangci-lint run ./...
  lint:fix:
    desc: "Run golangci-lint with auto-fix"
    cmds:
      - golangci-lint run --fix ./...
  # ── Format ───────────────────────────────────────────────────────────────
  fmt:
    desc: "Format all Go source files"
    cmds:
      - "{{.GO_CMD}} fmt ./..."
      - |
        if command -v goimports &>/dev/null; then
          goimports -w .
        fi
  fmt:check:
    desc: "Check formatting (non-zero exit if changes needed)"
    cmds:
      - |
        unformatted=$(gofmt -l .)
        if [ -n "$unformatted" ]; then
          echo "❌  Unformatted files:"
          echo "$unformatted"
          exit 1
        fi
        echo "✅  All files formatted"
  # ── Module management ─────────────────────────────────────────────────────
  tidy:
    desc: "go mod tidy"
    cmds:
      - "{{.GO_CMD}} mod tidy"
  deps:upgrade:
    desc: "Upgrade all direct dependencies to latest"
    cmds:
      - "{{.GO_CMD}} get -u ./..."
      - "{{.GO_CMD}} mod tidy"
  deps:verify:
    desc: "Verify module checksums"
    cmds:
      - "{{.GO_CMD}} mod verify"
  # ── CUSTOM ─────────────────────────────────────────────────────────
  sum:
    desc: "Runs repomix with scoped output"
    silent: true
    cmds:
      - repomix --output "{{.APP_NAME}}.xml" --include "{{.SUMEXT}}" --ignore "{{.IGNOREXT}}"
</file>

<file path="internal/glance/static/css/widgets.css">
@import "widget-bookmarks.css";
@import "widget-calendar.css";
@import "widget-clock.css";
@import "widget-dns-stats.css";
@import "widget-docker-containers.css";
@import "widget-group.css";
@import "widget-markets.css";
@import "widget-monitor.css";
@import "widget-reddit.css";
@import "widget-releases.css";
@import "widget-rss.css";
@import "widget-search.css";
@import "widget-server-stats.css";
@import "widget-twitch.css";
@import "widget-videos.css";
@import "widget-weather.css";
@import "widget-todo.css";
@import "forum-posts.css";
.widget-error-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    position: relative;
    margin-bottom: 1.8rem;
    z-index: 1;
}
.widget-error-header::before {
    content: '';
    position: absolute;
    inset: calc(0rem - (var(--widget-content-vertical-padding) / 2)) calc(0rem - (var(--widget-content-horizontal-padding) / 2));
    background: var(--color-negative);
    opacity: 0.05;
    border-radius: var(--border-radius);
    z-index: -1;
}
.widget-error-icon {
    width: 2.4rem;
    height: 2.4rem;
    flex-shrink: 0;
    stroke: var(--color-negative);
    opacity: 0.6;
}
.head-widgets {
    margin-bottom: var(--widget-gap);
}
.widget-content {
    container-type: inline-size;
    container-name: widget;
}
.widget-content:not(.widget-content-frameless) {
    padding: var(--widget-content-padding);
}
.widget-content:not(.widget-content-frameless), .widget-content-frame {
    background: var(--color-widget-background);
    border-radius: var(--border-radius);
    border: 1px solid var(--color-widget-content-border);
    box-shadow: 0px 3px 0px 0px hsl(var(--bghs), calc(var(--scheme) (var(--scheme) var(--bgl)) - 0.5%));
}
.widget-header {
    padding: 0 calc(var(--widget-content-horizontal-padding) + 1px);
    font-size: var(--font-size-h4);
    margin-bottom: 0.9rem;
    display: flex;
    align-items: center;
    gap: 1rem;
}
.widget-beta-icon {
    width: 1.6rem;
    height: 1.6rem;
    flex-shrink: 0;
    transition: transform .45s, opacity .45s, stroke .45s;
    opacity: 0.7;
}
.widget-beta-icon:hover, .widget-header .popover-active > .widget-beta-icon {
    fill: var(--color-text-highlight);
    transform: translateY(-10%) scale(1.3);
    opacity: 1;
}
.widget + .widget {
    margin-top: var(--widget-gap);
}
</file>

<file path="internal/glance/templates.go">
package glance
import (
	"fmt"
	"html/template"
	"math"
	"strconv"
	"golang.org/x/text/language"
	"golang.org/x/text/message"
)
var intl = message.NewPrinter(language.English)
var globalTemplateFunctions = template.FuncMap{
	"formatApproxNumber": formatApproxNumber,
	"formatNumber":       intl.Sprint,
	"safeCSS": func(str string) template.CSS {
		return template.CSS(str)
	},
	"safeURL": func(str string) template.URL {
		return template.URL(str)
	},
	"safeHTML": func(str string) template.HTML {
		return template.HTML(str)
	},
	"absInt": func(i int) int {
		return int(math.Abs(float64(i)))
	},
	"formatPrice": func(price float64) string {
		return intl.Sprintf("%.2f", price)
	},
	"formatPriceWithPrecision": func(precision int, price float64) string {
		return intl.Sprintf("%."+strconv.Itoa(precision)+"f", price)
	},
	"dynamicRelativeTimeAttrs": dynamicRelativeTimeAttrs,
	"formatServerMegabytes": func(mb uint64) template.HTML {
		var value string
		var label string
		if mb < 1_000 {
			value = strconv.FormatUint(mb, 10)
			label = "MB"
		} else if mb < 1_000_000 {
			if mb < 10_000 {
				value = fmt.Sprintf("%.1f", float64(mb)/1_000)
			} else {
				value = strconv.FormatUint(mb/1_000, 10)
			}
			label = "GB"
		} else {
			value = fmt.Sprintf("%.1f", float64(mb)/1_000_000)
			label = "TB"
		}
		return template.HTML(value + ` <span class="color-base size-h5">` + label + `</span>`)
	},
}
func mustParseTemplate(primary string, dependencies ...string) *template.Template {
	t, err := template.New(primary).
		Funcs(globalTemplateFunctions).
		ParseFS(templateFS, append([]string{primary}, dependencies...)...)
	if err != nil {
		panic(err)
	}
	return t
}
func formatApproxNumber(count int) string {
	if count < 1_000 {
		return strconv.Itoa(count)
	}
	if count < 10_000 {
		return strconv.FormatFloat(float64(count)/1_000, 'f', 1, 64) + "k"
	}
	if count < 1_000_000 {
		return strconv.Itoa(count/1_000) + "k"
	}
	return strconv.FormatFloat(float64(count)/1_000_000, 'f', 1, 64) + "m"
}
func dynamicRelativeTimeAttrs(t interface{ Unix() int64 }) template.HTMLAttr {
	return template.HTMLAttr(`data-dynamic-relative-time="` + strconv.FormatInt(t.Unix(), 10) + `"`)
}
</file>

<file path="internal/glance/templates/widget-base.html">
<div id="widget-{{ .GetID }}" class="widget widget-type-{{ .GetType }}{{ if .CSSClass }} {{ .CSSClass }}{{ end }}"
    hx-get="/api/widgets/{{ .GetID }}/render" {{ .GetHTMXTrigger }} hx-swap="outerHTML">
    {{- if not .HideHeader }}
    <div class="widget-header">
        {{- if ne "" .TitleURL }}
        <h2><a href="{{ .TitleURL | safeURL }}" target="_blank" rel="noreferrer" class="uppercase">{{ .Title }}</a></h2>
        {{- else }}
        <h2 class="uppercase">{{ .Title }}</h2>
        {{- end }}
        {{- if .IsWIP }}
        <div data-popover-type="html" data-popover-position="above">
            <div data-popover-html>
                <p class="size-h5">WORK IN PROGRESS</p>
                <p class="margin-block-10 color-paragraph">This widget is still in development, certain features may not
                    work as expected or may change drastically.</p>
                <a class="color-primary visited-indicator" href="https://github.com/glanceapp/glance/issues"
                    target="_blank" rel="noreferrer">Report issue</a>
            </div>
            <svg class="widget-beta-icon cursor-help" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"
                fill="currentColor">
                <path fill-rule="evenodd"
                    d="M19 5.5a4.5 4.5 0 0 1-4.791 4.49c-.873-.055-1.808.128-2.368.8l-6.024 7.23a2.724 2.724 0 1 1-3.837-3.837L9.21 8.16c.672-.56.855-1.495.8-2.368a4.5 4.5 0 0 1 5.873-4.575c.324.105.39.51.15.752L13.34 4.66a.455.455 0 0 0-.11.494 3.01 3.01 0 0 0 1.617 1.617c.17.07.363.02.493-.111l2.692-2.692c.241-.241.647-.174.752.15.14.435.216.9.216 1.382ZM4 17a1 1 0 1 0 0-2 1 1 0 0 0 0 2Z"
                    clip-rule="evenodd" />
            </svg>
        </div>
        {{- end }}
        {{- if and .Error .ContentAvailable }}
        <div class="notice-icon notice-icon-major" title="{{ .Error }}"></div>
        {{- else if .Notice }}
        <div class="notice-icon notice-icon-minor" title="{{ .Notice }}"></div>
        {{- end }}
    </div>
    {{- end }}
    <div class="widget-content{{ if .ContentAvailable }} {{ block " widget-content-classes" . }}{{ end }}{{ end }}">
        {{- if .ContentAvailable }}
        {{ block "widget-content" . }}{{ end }}
        {{- else }}
        <div class="widget-error-header">
            <div class="color-negative size-h3">ERROR</div>
            <svg class="widget-error-icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"
                stroke-width="1.5">
                <path stroke-linecap="round" stroke-linejoin="round"
                    d="M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126ZM12 15.75h.007v.008H12v-.008Z" />
            </svg>
        </div>
        <p class="break-all">{{ if .Error }}{{ .Error }}{{ else }}No error information provided{{ end }}</p>
        {{- end}}
    </div>
</div>
</file>

<file path="internal/glance/theme.go">
package glance
import (
	"fmt"
	"html/template"
	"net/http"
	"time"
)
var (
	themeStyleTemplate         = mustParseTemplate("theme-style.gotmpl")
	themePresetPreviewTemplate = mustParseTemplate("theme-preset-preview.html")
)
func (a *application) handleThemeChangeRequest(w http.ResponseWriter, r *http.Request) {
	themeKey := r.PathValue("key")
	properties, exists := a.Config.Theme.Presets.Get(themeKey)
	if !exists && themeKey != "default" {
		w.WriteHeader(http.StatusNotFound)
		return
	}
	if themeKey == "default" {
		properties = &a.Config.Theme.themeProperties
	}
	http.SetCookie(w, &http.Cookie{
		Name:     "theme",
		Value:    themeKey,
		Path:     a.Config.Server.BaseURL + "/",
		SameSite: http.SameSiteLaxMode,
		Expires:  time.Now().Add(2 * 365 * 24 * time.Hour),
	})
	w.Header().Set("Content-Type", "text/css")
	w.Header().Set("X-Scheme", ternary(properties.Light, "light", "dark"))
	w.Write([]byte(properties.CSS))
}
type themeProperties struct {
	BackgroundColor          *hslColorField `yaml:"background-color"`
	PrimaryColor             *hslColorField `yaml:"primary-color"`
	PositiveColor            *hslColorField `yaml:"positive-color"`
	NegativeColor            *hslColorField `yaml:"negative-color"`
	Light                    bool           `yaml:"light"`
	ContrastMultiplier       float32        `yaml:"contrast-multiplier"`
	TextSaturationMultiplier float32        `yaml:"text-saturation-multiplier"`
	Key                  string        `yaml:"-"`
	CSS                  template.CSS  `yaml:"-"`
	PreviewHTML          template.HTML `yaml:"-"`
	BackgroundColorAsHex string        `yaml:"-"`
}
func (t *themeProperties) init() error {
	css, err := executeTemplateToString(themeStyleTemplate, t)
	if err != nil {
		return fmt.Errorf("compiling theme style: %v", err)
	}
	t.CSS = template.CSS(whitespaceAtBeginningOfLinePattern.ReplaceAllString(css, ""))
	previewHTML, err := executeTemplateToString(themePresetPreviewTemplate, t)
	if err != nil {
		return fmt.Errorf("compiling theme preview: %v", err)
	}
	t.PreviewHTML = template.HTML(previewHTML)
	if t.BackgroundColor != nil {
		t.BackgroundColorAsHex = t.BackgroundColor.ToHex()
	} else {
		t.BackgroundColorAsHex = "#151519"
	}
	return nil
}
func (t1 *themeProperties) SameAs(t2 *themeProperties) bool {
	if t1 == nil && t2 == nil {
		return true
	}
	if t1 == nil || t2 == nil {
		return false
	}
	if t1.Light != t2.Light {
		return false
	}
	if t1.ContrastMultiplier != t2.ContrastMultiplier {
		return false
	}
	if t1.TextSaturationMultiplier != t2.TextSaturationMultiplier {
		return false
	}
	if !t1.BackgroundColor.SameAs(t2.BackgroundColor) {
		return false
	}
	if !t1.PrimaryColor.SameAs(t2.PrimaryColor) {
		return false
	}
	if !t1.PositiveColor.SameAs(t2.PositiveColor) {
		return false
	}
	if !t1.NegativeColor.SameAs(t2.NegativeColor) {
		return false
	}
	return true
}
</file>

<file path="internal/glance/utils.go">
package glance
import (
	"bytes"
	"fmt"
	"html/template"
	"math"
	"net/http"
	"net/url"
	"os"
	"regexp"
	"slices"
	"strings"
	"time"
)
var sequentialWhitespacePattern = regexp.MustCompile(`\s+`)
var whitespaceAtBeginningOfLinePattern = regexp.MustCompile(`(?m)^\s+`)
func percentChange(current, previous float64) float64 {
	if previous == 0 {
		if current == 0 {
			return 0 // 0% change if both are 0
		}
		return 100 // 100% increase if going from 0 to something
	}
	return (current/previous - 1) * 100
}
func extractDomainFromUrl(u string) string {
	if u == "" {
		return ""
	}
	parsed, err := url.Parse(u)
	if err != nil {
		return ""
	}
	return strings.TrimPrefix(strings.ToLower(parsed.Host), "www.")
}
func svgPolylineCoordsFromYValues(width float64, height float64, values []float64) string {
	if len(values) < 2 {
		return ""
	}
	verticalPadding := height * 0.02
	height -= verticalPadding * 2
	coordinates := make([]string, len(values))
	distanceBetweenPoints := width / float64(len(values)-1)
	min := slices.Min(values)
	max := slices.Max(values)
	for i := range values {
		coordinates[i] = fmt.Sprintf(
			"%.2f,%.2f",
			float64(i)*distanceBetweenPoints,
			((max-values[i])/(max-min))*height+verticalPadding,
		)
	}
	return strings.Join(coordinates, " ")
}
func maybeCopySliceWithoutZeroValues[T int | float64](values []T) []T {
	if len(values) == 0 {
		return values
	}
	for i := range values {
		if values[i] != 0 {
			continue
		}
		c := make([]T, 0, len(values)-1)
		for i := range values {
			if values[i] != 0 {
				c = append(c, values[i])
			}
		}
		return c
	}
	return values
}
var urlSchemePattern = regexp.MustCompile(`^[a-z]+:\/\/`)
func stripURLScheme(url string) string {
	return urlSchemePattern.ReplaceAllString(url, "")
}
func isRunningInsideDockerContainer() bool {
	_, err := os.Stat("/.dockerenv")
	return err == nil
}
func prefixStringLines(prefix string, s string) string {
	lines := strings.Split(s, "\n")
	for i, line := range lines {
		lines[i] = prefix + line
	}
	return strings.Join(lines, "\n")
}
func limitStringLength(s string, max int) (string, bool) {
	asRunes := []rune(s)
	if len(asRunes) > max {
		return string(asRunes[:max]), true
	}
	return s, false
}
func parseRFC3339Time(t string) time.Time {
	parsed, err := time.Parse(time.RFC3339, t)
	if err != nil {
		return time.Now()
	}
	return parsed
}
func normalizeVersionFormat(version string) string {
	version = strings.ToLower(strings.TrimSpace(version))
	if len(version) > 0 && version[0] != 'v' {
		return "v" + version
	}
	return version
}
func titleToSlug(s string) string {
	s = strings.ToLower(s)
	s = sequentialWhitespacePattern.ReplaceAllString(s, "-")
	s = strings.Trim(s, "-")
	return s
}
func fileServerWithCache(fs http.FileSystem, cacheDuration time.Duration) http.Handler {
	server := http.FileServer(fs)
	cacheControlValue := fmt.Sprintf("public, max-age=%d", int(cacheDuration.Seconds()))
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// TODO: fix always setting cache control even if the file doesn't exist
		w.Header().Set("Cache-Control", cacheControlValue)
		server.ServeHTTP(w, r)
	})
}
func executeTemplateToString(t *template.Template, data any) (string, error) {
	var b bytes.Buffer
	err := t.Execute(&b, data)
	if err != nil {
		return "", fmt.Errorf("executing template: %w", err)
	}
	return b.String(), nil
}
func stringToBool(s string) bool {
	return s == "true" || s == "yes"
}
func itemAtIndexOrDefault[T any](items []T, index int, def T) T {
	if index >= len(items) {
		return def
	}
	return items[index]
}
func ternary[T any](condition bool, a, b T) T {
	if condition {
		return a
	}
	return b
}
// Having compile time errors about unused variables is cool and all, but I don't want to
// have to constantly comment out my code while I'm working on it and testing things out
func ItsUsedTrustMeBro(...any) {}
func hslToHex(h, s, l float64) string {
	s /= 100.0
	l /= 100.0
	var r, g, b float64
	if s == 0 {
		r, g, b = l, l, l
	} else {
		hueToRgb := func(p, q, t float64) float64 {
			if t < 0 {
				t += 1
			}
			if t > 1 {
				t -= 1
			}
			if t < 1.0/6.0 {
				return p + (q-p)*6.0*t
			}
			if t < 1.0/2.0 {
				return q
			}
			if t < 2.0/3.0 {
				return p + (q-p)*(2.0/3.0-t)*6.0
			}
			return p
		}
		q := 0.0
		if l < 0.5 {
			q = l * (1 + s)
		} else {
			q = l + s - l*s
		}
		p := 2*l - q
		h /= 360.0
		r = hueToRgb(p, q, h+1.0/3.0)
		g = hueToRgb(p, q, h)
		b = hueToRgb(p, q, h-1.0/3.0)
	}
	ir := int(math.Round(r * 255.0))
	ig := int(math.Round(g * 255.0))
	ib := int(math.Round(b * 255.0))
	ir = int(math.Max(0, math.Min(255, float64(ir))))
	ig = int(math.Max(0, math.Min(255, float64(ig))))
	ib = int(math.Max(0, math.Min(255, float64(ib))))
	return fmt.Sprintf("#%02x%02x%02x", ir, ig, ib)
}
</file>

<file path="internal/glance/widget-server-stats.go">
package glance
import (
	"context"
	"html/template"
	"log/slog"
	"net/http"
	"strconv"
	"strings"
	"sync"
	"time"
	"github.com/limpdev/banter/pkg/sysinfo"
)
var serverStatsWidgetTemplate = mustParseTemplate("server-stats.html", "widget-base.html")
type serverStatsWidget struct {
	widgetBase `yaml:",inline"`
	Servers    []serverStatsRequest `yaml:"servers"`
}
func (widget *serverStatsWidget) initialize() error {
	widget.withTitle("Server Stats").withCacheDuration(15 * time.Second)
	widget.widgetBase.WIP = true
	if len(widget.Servers) == 0 {
		widget.Servers = []serverStatsRequest{{Type: "local"}}
	}
	for i := range widget.Servers {
		widget.Servers[i].URL = strings.TrimRight(widget.Servers[i].URL, "/")
		if widget.Servers[i].Timeout == 0 {
			widget.Servers[i].Timeout = durationField(3 * time.Second)
		}
	}
	return nil
}
func (widget *serverStatsWidget) setProviders(providers *widgetProviders) {
	widget.widgetBase.setProviders(providers)
	if providers != nil && providers.hub != nil {
		go func() {
			dur := widget.cacheDuration
			if dur <= 0 {
				dur = 15 * time.Second
			}
			ticker := time.NewTicker(dur)
			defer ticker.Stop()
			for range ticker.C {
				widget.update(context.Background())
				providers.hub.broadcastHTML(string(widget.Render()))
			}
		}()
	}
}
func (widget *serverStatsWidget) update(context.Context) {
	// Refactor later, most of it may change depending on feedback
	var wg sync.WaitGroup
	for i := range widget.Servers {
		serv := &widget.Servers[i]
		if serv.Type == "local" {
			info, errs := sysinfo.Collect(serv.SystemInfoRequest)
			if len(errs) > 0 {
				for i := range errs {
					slog.Warn("Getting system info: " + errs[i].Error())
				}
			}
			serv.IsReachable = true
			serv.Info = info
		} else {
			wg.Add(1)
			go func() {
				defer wg.Done()
				info, err := fetchRemoteServerInfo(serv)
				if err != nil {
					slog.Warn("Getting remote system info: " + err.Error())
					serv.IsReachable = false
					serv.Info = &sysinfo.SystemInfo{
						Hostname: "Unnamed server #" + strconv.Itoa(i+1),
					}
				} else {
					serv.IsReachable = true
					serv.Info = info
				}
			}()
		}
	}
	wg.Wait()
	widget.withError(nil).scheduleNextUpdate()
}
func (widget *serverStatsWidget) Render() template.HTML {
	return widget.renderTemplate(widget, serverStatsWidgetTemplate)
}
type serverStatsRequest struct {
	*sysinfo.SystemInfoRequest `yaml:",inline"`
	Info                       *sysinfo.SystemInfo `yaml:"-"`
	IsReachable                bool                `yaml:"-"`
	StatusText                 string              `yaml:"-"`
	Name                       string              `yaml:"name"`
	HideSwap                   bool                `yaml:"hide-swap"`
	Type                       string              `yaml:"type"`
	URL                        string              `yaml:"url"`
	Token                      string              `yaml:"token"`
	Timeout                    durationField       `yaml:"timeout"`
	// Support for other agents
	// Provider                   string              `yaml:"provider"`
}
func fetchRemoteServerInfo(infoReq *serverStatsRequest) (*sysinfo.SystemInfo, error) {
	ctx, cancel := context.WithTimeout(context.Background(), time.Duration(infoReq.Timeout))
	defer cancel()
	request, _ := http.NewRequestWithContext(ctx, "GET", infoReq.URL+"/api/sysinfo/all", nil)
	if infoReq.Token != "" {
		request.Header.Set("Authorization", "Bearer "+infoReq.Token)
	}
	info, err := decodeJsonFromRequest[*sysinfo.SystemInfo](defaultHTTPClient, request)
	if err != nil {
		return nil, err
	}
	return info, nil
}
</file>

<file path="internal/glance/diagnose.go">
package glance
import (
	"context"
	"fmt"
	"io"
	"net"
	"net/http"
	"runtime"
	"strings"
	"sync"
	"time"
)
const httpTestRequestTimeout = 15 * time.Second
var diagnosticSteps = []diagnosticStep{
	{
		name: "resolve cloudflare.com through Cloudflare DoH",
		fn: func() (string, error) {
			return testHttpRequestWithHeaders("GET", "https://1.1.1.1/dns-query?name=cloudflare.com", map[string]string{
				"accept": "application/dns-json",
			}, 200)
		},
	},
	{
		name: "resolve cloudflare.com through Google DoH",
		fn: func() (string, error) {
			return testHttpRequest("GET", "https://8.8.8.8/resolve?name=cloudflare.com", 200)
		},
	},
	{
		name: "resolve github.com",
		fn: func() (string, error) {
			return testDNSResolution("github.com")
		},
	},
	{
		name: "resolve reddit.com",
		fn: func() (string, error) {
			return testDNSResolution("reddit.com")
		},
	},
	{
		name: "resolve twitch.tv",
		fn: func() (string, error) {
			return testDNSResolution("twitch.tv")
		},
	},
	{
		name: "fetch data from YouTube RSS feed",
		fn: func() (string, error) {
			return testHttpRequest("GET", "https://www.youtube.com/feeds/videos.xml?channel_id=UCZU9T1ceaOgwfLRq7OKFU4Q", 200)
		},
	},
	{
		name: "fetch data from Twitch.tv GQL",
		fn: func() (string, error) {
			// this should always return 0 bytes, we're mainly looking for a 200 status code
			return testHttpRequest("OPTIONS", "https://gql.twitch.tv/gql", 200)
		},
	},
	{
		name: "fetch data from GitHub API",
		fn: func() (string, error) {
			return testHttpRequest("GET", "https://api.github.com", 200)
		},
	},
	{
		name: "fetch data from Open-Meteo API",
		fn: func() (string, error) {
			return testHttpRequest("GET", "https://geocoding-api.open-meteo.com/v1/search?name=London", 200)
		},
	},
	{
		name: "fetch data from Reddit API",
		fn: func() (string, error) {
			return testHttpRequestWithHeaders("GET", "https://www.reddit.com/search.json", map[string]string{
				"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:137.0) Gecko/20100101 Firefox/137.0",
			}, 200)
		},
	},
	{
		name: "fetch data from Yahoo finance API",
		fn: func() (string, error) {
			return testHttpRequestWithHeaders("GET", "https://query1.finance.yahoo.com/v8/finance/chart/NVDA", map[string]string{
				"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:137.0) Gecko/20100101 Firefox/137.0",
			}, 200)
		},
	},
	{
		name: "fetch data from Hacker News Firebase API",
		fn: func() (string, error) {
			return testHttpRequest("GET", "https://hacker-news.firebaseio.com/v0/topstories.json", 200)
		},
	},
	{
		name: "fetch data from Docker Hub API",
		fn: func() (string, error) {
			return testHttpRequest("GET", "https://hub.docker.com/v2/namespaces/library/repositories/ubuntu/tags/latest", 200)
		},
	},
}
func runDiagnostic() {
	fmt.Println("```")
	fmt.Println("Glance version: " + buildVersion)
	fmt.Println("Go version: " + runtime.Version())
	fmt.Printf("Platform: %s / %s / %d CPUs\n", runtime.GOOS, runtime.GOARCH, runtime.NumCPU())
	fmt.Println("In Docker container: " + ternary(isRunningInsideDockerContainer(), "yes", "no"))
	fmt.Printf("\nChecking network connectivity, this may take up to %d seconds...\n\n", int(httpTestRequestTimeout.Seconds()))
	var wg sync.WaitGroup
	for i := range diagnosticSteps {
		step := &diagnosticSteps[i]
		wg.Add(1)
		go func() {
			defer wg.Done()
			start := time.Now()
			step.extraInfo, step.err = step.fn()
			step.elapsed = time.Since(start)
		}()
	}
	wg.Wait()
	for _, step := range diagnosticSteps {
		var extraInfo string
		if step.extraInfo != "" {
			extraInfo = "| " + step.extraInfo + " "
		}
		fmt.Printf(
			"%s %s %s| %dms\n",
			ternary(step.err == nil, "✓ Can", "✗ Can't"),
			step.name,
			extraInfo,
			step.elapsed.Milliseconds(),
		)
		if step.err != nil {
			fmt.Printf("└╴ error: %v\n", step.err)
		}
	}
	fmt.Println("```")
}
type diagnosticStep struct {
	name      string
	fn        func() (string, error)
	extraInfo string
	err       error
	elapsed   time.Duration
}
func testHttpRequest(method, url string, expectedStatusCode int) (string, error) {
	return testHttpRequestWithHeaders(method, url, nil, expectedStatusCode)
}
func testHttpRequestWithHeaders(method, url string, headers map[string]string, expectedStatusCode int) (string, error) {
	ctx, cancel := context.WithTimeout(context.Background(), httpTestRequestTimeout)
	defer cancel()
	request, _ := http.NewRequestWithContext(ctx, method, url, nil)
	for key, value := range headers {
		request.Header.Add(key, value)
	}
	response, err := defaultHTTPClient.Do(request)
	if err != nil {
		return "", err
	}
	defer response.Body.Close()
	body, err := io.ReadAll(response.Body)
	if err != nil {
		return "", err
	}
	printableBody := strings.ReplaceAll(string(body), "\n", "")
	if len(printableBody) > 50 {
		printableBody = printableBody[:50] + "..."
	}
	if len(printableBody) > 0 {
		printableBody = ", " + printableBody
	}
	extraInfo := fmt.Sprintf("%d bytes%s", len(body), printableBody)
	if response.StatusCode != expectedStatusCode {
		return extraInfo, fmt.Errorf("expected status code %d, got %d", expectedStatusCode, response.StatusCode)
	}
	return extraInfo, nil
}
func testDNSResolution(domain string) (string, error) {
	ips, err := net.LookupIP(domain)
	var ipStrings []string
	if err == nil {
		for i := range ips {
			ipStrings = append(ipStrings, ips[i].String())
		}
	}
	return strings.Join(ipStrings, ", "), err
}
</file>

<file path="internal/glance/config-fields.go">
package glance
import (
	"crypto/tls"
	"fmt"
	"html/template"
	"net/http"
	"net/url"
	"regexp"
	"strconv"
	"strings"
	"time"
	"gopkg.in/yaml.v3"
)
var hslColorFieldPattern = regexp.MustCompile(`^(?:hsla?\()?([\d\.]+)(?: |,)+([\d\.]+)%?(?: |,)+([\d\.]+)%?\)?$`)
const (
	hslHueMax        = 360
	hslSaturationMax = 100
	hslLightnessMax  = 100
)
type hslColorField struct {
	H float64
	S float64
	L float64
}
func (c *hslColorField) String() string {
	return fmt.Sprintf("hsl(%.1f, %.1f%%, %.1f%%)", c.H, c.S, c.L)
}
func (c *hslColorField) ToHex() string {
	return hslToHex(c.H, c.S, c.L)
}
func (c1 *hslColorField) SameAs(c2 *hslColorField) bool {
	if c1 == nil && c2 == nil {
		return true
	}
	if c1 == nil || c2 == nil {
		return false
	}
	return c1.H == c2.H && c1.S == c2.S && c1.L == c2.L
}
func (c *hslColorField) UnmarshalYAML(node *yaml.Node) error {
	var value string
	if err := node.Decode(&value); err != nil {
		return err
	}
	matches := hslColorFieldPattern.FindStringSubmatch(value)
	if len(matches) != 4 {
		return fmt.Errorf("invalid HSL color format: %s", value)
	}
	hue, err := strconv.ParseFloat(matches[1], 64)
	if err != nil {
		return err
	}
	if hue > hslHueMax {
		return fmt.Errorf("HSL hue must be between 0 and %d", hslHueMax)
	}
	saturation, err := strconv.ParseFloat(matches[2], 64)
	if err != nil {
		return err
	}
	if saturation > hslSaturationMax {
		return fmt.Errorf("HSL saturation must be between 0 and %d", hslSaturationMax)
	}
	lightness, err := strconv.ParseFloat(matches[3], 64)
	if err != nil {
		return err
	}
	if lightness > hslLightnessMax {
		return fmt.Errorf("HSL lightness must be between 0 and %d", hslLightnessMax)
	}
	c.H = hue
	c.S = saturation
	c.L = lightness
	return nil
}
var durationFieldPattern = regexp.MustCompile(`^(\d+)(s|m|h|d)$`)
type durationField time.Duration
func (d *durationField) UnmarshalYAML(node *yaml.Node) error {
	var value string
	if err := node.Decode(&value); err != nil {
		return err
	}
	matches := durationFieldPattern.FindStringSubmatch(value)
	if len(matches) != 3 {
		return fmt.Errorf("invalid duration format: %s", value)
	}
	duration, err := strconv.Atoi(matches[1])
	if err != nil {
		return err
	}
	switch matches[2] {
	case "s":
		*d = durationField(time.Duration(duration) * time.Second)
	case "m":
		*d = durationField(time.Duration(duration) * time.Minute)
	case "h":
		*d = durationField(time.Duration(duration) * time.Hour)
	case "d":
		*d = durationField(time.Duration(duration) * 24 * time.Hour)
	}
	return nil
}
type customIconField struct {
	URL        template.URL
	AutoInvert bool
}
func newCustomIconField(value string) customIconField {
	const autoInvertPrefix = "auto-invert "
	field := customIconField{}
	if strings.HasPrefix(value, autoInvertPrefix) {
		field.AutoInvert = true
		value = strings.TrimPrefix(value, autoInvertPrefix)
	}
	prefix, icon, found := strings.Cut(value, ":")
	if !found {
		field.URL = template.URL(value)
		return field
	}
	basename, ext, found := strings.Cut(icon, ".")
	if !found {
		ext = "svg"
		basename = icon
	}
	if ext != "svg" && ext != "png" {
		ext = "svg"
	}
	switch prefix {
	case "si":
		field.AutoInvert = true
		field.URL = template.URL("https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/" + basename + ".svg")
	case "di":
		field.URL = template.URL("https://cdn.jsdelivr.net/gh/homarr-labs/dashboard-icons/" + ext + "/" + basename + "." + ext)
	case "mdi":
		field.AutoInvert = true
		field.URL = template.URL("https://cdn.jsdelivr.net/npm/@mdi/svg@latest/svg/" + basename + ".svg")
	case "sh":
		field.URL = template.URL("https://cdn.jsdelivr.net/gh/selfhst/icons/" + ext + "/" + basename + "." + ext)
	default:
		field.URL = template.URL(value)
	}
	return field
}
func (i *customIconField) UnmarshalYAML(node *yaml.Node) error {
	var value string
	if err := node.Decode(&value); err != nil {
		return err
	}
	*i = newCustomIconField(value)
	return nil
}
type proxyOptionsField struct {
	URL           string        `yaml:"url"`
	AllowInsecure bool          `yaml:"allow-insecure"`
	Timeout       durationField `yaml:"timeout"`
	client        *http.Client  `yaml:"-"`
}
func (p *proxyOptionsField) UnmarshalYAML(node *yaml.Node) error {
	type proxyOptionsFieldAlias proxyOptionsField
	alias := (*proxyOptionsFieldAlias)(p)
	var proxyURL string
	if err := node.Decode(&proxyURL); err != nil {
		if err := node.Decode(alias); err != nil {
			return err
		}
	}
	if proxyURL == "" && p.URL == "" {
		return nil
	}
	if p.URL != "" {
		proxyURL = p.URL
	}
	parsedUrl, err := url.Parse(proxyURL)
	if err != nil {
		return fmt.Errorf("parsing proxy URL: %v", err)
	}
	var timeout = defaultClientTimeout
	if p.Timeout > 0 {
		timeout = time.Duration(p.Timeout)
	}
	p.client = &http.Client{
		Timeout: timeout,
		Transport: &http.Transport{
			Proxy:           http.ProxyURL(parsedUrl),
			TLSClientConfig: &tls.Config{InsecureSkipVerify: p.AllowInsecure},
		},
	}
	return nil
}
type queryParametersField map[string][]string
func (q *queryParametersField) UnmarshalYAML(node *yaml.Node) error {
	var decoded map[string]any
	if err := node.Decode(&decoded); err != nil {
		return err
	}
	*q = make(queryParametersField)
	// TODO: refactor the duplication in the switch cases if any more types get added
	for key, value := range decoded {
		switch v := value.(type) {
		case string:
			(*q)[key] = []string{v}
		case int, int8, int16, int32, int64, float32, float64:
			(*q)[key] = []string{fmt.Sprintf("%v", v)}
		case bool:
			(*q)[key] = []string{fmt.Sprintf("%t", v)}
		case []string:
			(*q)[key] = append((*q)[key], v...)
		case []any:
			for _, item := range v {
				switch item := item.(type) {
				case string:
					(*q)[key] = append((*q)[key], item)
				case int, int8, int16, int32, int64, float32, float64:
					(*q)[key] = append((*q)[key], fmt.Sprintf("%v", item))
				case bool:
					(*q)[key] = append((*q)[key], fmt.Sprintf("%t", item))
				default:
					return fmt.Errorf("invalid query parameter value type: %T", item)
				}
			}
		default:
			return fmt.Errorf("invalid query parameter value type: %T", value)
		}
	}
	return nil
}
func (q *queryParametersField) toQueryString() string {
	query := url.Values{}
	for key, values := range *q {
		for _, value := range values {
			query.Add(key, value)
		}
	}
	return query.Encode()
}
</file>

<file path="internal/glance/static/css/mobile.css">
@media (max-width: 1190px) {
    .header-container {
        display: none;
    }
    .page-column-small .size-title-dynamic {
        font-size: var(--font-size-h3);
    }
    .page-column-small {
        width: 100%;
        flex-shrink: 1;
    }
    .page-column {
        display: none;
        animation: columnEntrance .0s cubic-bezier(0.25, 1, 0.5, 1) backwards;
    }
    .page-columns-transitioned .page-column {
        animation-duration: .3s;
    }
    @keyframes columnEntrance {
        from {
            opacity: 0;
            transform: scaleX(0.95);
        }
    }
    .mobile-navigation-offset {
        height: var(--mobile-navigation-height);
        flex-shrink: 0;
    }
    .mobile-navigation {
        display: block;
        position: fixed;
        bottom: 0;
        transform: translateY(calc(100% - var(--mobile-navigation-height)));
        left: var(--content-bounds-padding);
        right: var(--content-bounds-padding);
        z-index: 11;
        background-color: var(--color-widget-background);
        border: 1px solid var(--color-widget-content-border);
        border-bottom: 0;
        border-radius: var(--border-radius) var(--border-radius) 0 0;
        transition: transform .3s;
    }
    .mobile-navigation-actions > * {
        padding-block: 1.1rem;
        padding-inline: var(--content-bounds-padding);
        cursor: pointer;
        transition: background-color 50ms;
    }
    .mobile-navigation-actions > *:active {
        background-color: var(--color-widget-background-highlight);
    }
    .mobile-navigation:has(.mobile-navigation-page-links-input:checked) .hamburger-icon {
        --spacing: 7px;
        color: var(--color-primary);
        height: 2px;
    }
    .mobile-navigation:has(.mobile-navigation-page-links-input:checked) {
        transform: translateY(0);
    }
    .mobile-navigation-page-links {
        border-top: 1px solid var(--color-widget-content-border);
        border-bottom: 1px solid var(--color-widget-content-border);
        padding: 20px var(--content-bounds-padding);
        display: flex;
        align-items: center;
        overflow-x: auto;
        scrollbar-width: thin;
        gap: 2.5rem;
    }
    .mobile-navigation-icons {
        display: flex;
        justify-content: space-around;
        align-items: center;
    }
    body:has(.mobile-navigation-input[value="0"]:checked) .page-columns > :nth-child(1),
    body:has(.mobile-navigation-input[value="1"]:checked) .page-columns > :nth-child(2),
    body:has(.mobile-navigation-input[value="2"]:checked) .page-columns > :nth-child(3) {
        display: block;
    }
    .mobile-navigation-label {
        display: flex;
        flex: 1;
        max-width: 50px;
        height: var(--mobile-navigation-height);
        justify-content: center;
        align-items: center;
        cursor: pointer;
        font-size: 15px;
        line-height: var(--mobile-navigation-height);
    }
    .mobile-navigation-pill {
        display: block;
        background: var(--color-text-base);
        height: 10px;
        width: 10px;
        border-radius: 10px;
        transition: width .3s, background-color .3s;
    }
    .mobile-navigation-label:hover > .mobile-navigation-pill {
        background-color: var(--color-text-highlight);
    }
    .mobile-navigation-label:hover {
        color: var(--color-text-highlight);
    }
    .mobile-navigation-input:checked + .mobile-navigation-pill {
        background: var(--color-primary);
        width: 30px;
    }
    .mobile-navigation-input, .mobile-navigation-page-links-input {
        display: none;
    }
    .hamburger-icon {
        --spacing: 4px;
        width: 1em;
        height: 1px;
        background-color: currentColor;
        transition: color .3s, box-shadow .3s;
        box-shadow: 0 calc(var(--spacing) * -1) 0 0 currentColor, 0 var(--spacing) 0 0 currentColor;
    }
    .expand-toggle-button.container-expanded {
        bottom: var(--mobile-navigation-height);
    }
    .cards-grid + .expand-toggle-button.container-expanded {
        /* hides content that peeks through the rounded borders of the mobile navigation */
        box-shadow: 0 var(--border-radius) 0 0 var(--color-background);
    }
    .weather-column-rain::before {
        background-size: 7px 7px;
    }
    .ios .search-input {
        /* so that iOS Safari does not zoom the page when the input is focused */
        font-size: 16px;
    }
}
@media (max-width: 1190px) and (display-mode: standalone) {
    :root {
        --safe-area-inset-bottom: env(safe-area-inset-bottom, 0);
    }
    .ios .body-content {
        height: 100dvh;
    }
    .expand-toggle-button.container-expanded {
        bottom: calc(var(--mobile-navigation-height) + var(--safe-area-inset-bottom));
    }
    .mobile-navigation {
        transform: translateY(calc(100% - var(--mobile-navigation-height) - var(--safe-area-inset-bottom)));
        padding-bottom: var(--safe-area-inset-bottom);
    }
    .mobile-navigation-icons {
        padding-bottom: var(--safe-area-inset-bottom);
        transition: padding-bottom .3s;
    }
    .mobile-navigation-offset {
        height: calc(var(--mobile-navigation-height) + var(--safe-area-inset-bottom));
    }
    .mobile-navigation-icons:has(.mobile-navigation-page-links-input:checked) {
        padding-bottom: 0;
    }
}
@media (display-mode: standalone) {
    body {
        padding-top: env(safe-area-inset-top, 0);
    }
}
@media (max-width: 550px) {
    :root {
        font-size: 9.4px;
        --widget-gap: 15px;
        --widget-content-vertical-padding: 10px;
        --widget-content-horizontal-padding: 10px;
        --content-bounds-padding: 10px;
    }
    .dynamic-columns:has(> :nth-child(1)) { --columns-per-row: 1; }
    .row-reverse-on-mobile {
        flex-direction: row-reverse;
    }
    .hide-on-mobile, .thumbnail-container:has(> .hide-on-mobile) {
        display: none
    }
    .mobile-reachability-header {
        display: block;
        font-size: 3rem;
        padding: 10vh 1rem;
        text-align: center;
        color: var(--color-text-highlight);
        animation: pageColumnsEntrance .3s cubic-bezier(0.25, 1, 0.5, 1) backwards;
    }
    .rss-detailed-thumbnail > * {
        height: 6rem;
    }
    .rss-detailed-description {
        line-clamp: 3;
        -webkit-line-clamp: 3;
    }
}
</file>

<file path="internal/glance/static/css/utils.css">
.masonry {
    display: flex;
    gap: var(--widget-gap);
}
.masonry-column {
    flex: 1;
    display: flex;
    flex-direction: column;
}
.widget-small-content-bounds {
    max-width: 350px;
    margin: 0 auto;
}
.visually-hidden {
    clip-path: inset(50%);
    height: 1px;
    overflow: hidden;
    position: absolute;
    white-space: nowrap;
    width: 1px;
}
.list-horizontal-text {
    display: flex;
    list-style: none;
    flex-wrap: wrap;
    align-items: center;
}
.list-horizontal-text > *:not(:last-child)::after {
    content: '•' / "";
    color: var(--color-text-subdue);
    margin: 0 0.4rem;
    position: relative;
    top: 0.1rem;
}
.summary {
    width: 100%;
    cursor: pointer;
    word-spacing: -0.18em;
    user-select: none;
    list-style: none;
    position: relative;
    display: flex;
    z-index: 1;
}
.summary::-webkit-details-marker {
    display: none;
}
.details[open] .summary {
    margin-bottom: .8rem;
}
.summary::before {
    content: "";
    position: absolute;
    inset: -.3rem -.8rem;
    border-radius: var(--border-radius);
    background-color: var(--color-widget-background-highlight);
    opacity: 0;
    transition: opacity 0.2s;
    z-index: -1;
}
.details[open] .summary::before, .summary:hover::before {
    opacity: 1;
}
.details:not([open]) .list-with-transition {
    display: none;
}
.summary::after {
    content: "◀" / "";
    font-size: 1.2em;
    position: absolute;
    top: 0;
    bottom: 0;
    line-height: 1.3em;
    right: 0;
    transition: rotate .5s cubic-bezier(0.22, 1, 0.36, 1);
}
details[open] .summary::after {
    rotate: -90deg;
}
/* TODO: refactor, otherwise I hope I never have to change dynamic columns again */
.dynamic-columns {
    --list-half-gap: 0.5rem;
    gap: var(--widget-content-vertical-padding) var(--widget-content-horizontal-padding);
    display: grid;
    grid-template-columns: repeat(var(--columns-per-row), 1fr);
}
.dynamic-columns > * {
    padding-left: var(--widget-content-horizontal-padding);
    border-left: 1px solid var(--color-separator);
    min-width: 0;
}
.dynamic-columns > *:first-child {
    padding-top: 0;
    border-top: none;
    border-left: none;
}
.dynamic-columns:has(> :nth-child(1)) { --columns-per-row: 1; }
.dynamic-columns:has(> :nth-child(2)) { --columns-per-row: 2; }
.dynamic-columns:has(> :nth-child(3)) { --columns-per-row: 3; }
.dynamic-columns:has(> :nth-child(4)) { --columns-per-row: 4; }
.dynamic-columns:has(> :nth-child(5)) { --columns-per-row: 5; }
@container widget (max-width: 599px) {
    .dynamic-columns { gap: 0; }
    .dynamic-columns:has(> :nth-child(1)) { --columns-per-row: 1; }
    .dynamic-columns > * {
        border-left: none;
        padding-left: 0;
    }
    .dynamic-columns > *:not(:first-child) {
        margin-top: calc(var(--list-half-gap) * 2);
    }
    .dynamic-columns.list-with-separator > *:not(:first-child) {
        margin-top: var(--list-half-gap);
        border-top: 1px solid var(--color-separator);
        padding-top: var(--list-half-gap);
    }
}
@container widget (min-width: 600px) and (max-width: 849px) {
    .dynamic-columns:has(> :nth-child(2)) { --columns-per-row: 2; }
    .dynamic-columns > :nth-child(2n-1) {
        border-left: none;
        padding-left: 0;
    }
}
@container widget (min-width: 850px) and (max-width: 1249px) {
    .dynamic-columns:has(> :nth-child(3)) { --columns-per-row: 3; }
    .dynamic-columns > :nth-child(3n+1) {
        border-left: none;
        padding-left: 0;
    }
}
@container widget (min-width: 1250px) and (max-width: 1499px) {
    .dynamic-columns:has(> :nth-child(4)) { --columns-per-row: 4; }
    .dynamic-columns > :nth-child(4n+1) {
        border-left: none;
        padding-left: 0;
    }
}
@container widget (min-width: 1500px) {
    .dynamic-columns:has(> :nth-child(5)) { --columns-per-row: 5; }
    .dynamic-columns > :nth-child(5n+1) {
        border-left: none;
        padding-left: 0;
    }
}
.cards-vertical {
    flex-direction: column;
}
.cards-horizontal {
    --cards-per-row: 6.5;
}
.cards-horizontal, .cards-vertical {
    --cards-gap: calc(var(--widget-content-vertical-padding) * 0.7);
    display: flex;
    gap: var(--cards-gap);
}
.card {
    display: flex;
    flex-direction: column;
}
.cards-horizontal .card {
    flex-shrink: 0;
    width: calc(100% / var(--cards-per-row) - var(--cards-gap) * (var(--cards-per-row) - 1) / var(--cards-per-row));
}
.cards-grid .card {
    min-width: 0;
}
.cards-horizontal {
    overflow-x: auto;
    scrollbar-width: thin;
    padding-bottom: 1rem;
}
.cards-grid {
    --cards-per-row: 6;
    display: grid;
    grid-template-columns: repeat(var(--cards-per-row), 1fr);
    gap: calc(var(--widget-content-vertical-padding) * 0.7);
}
@container widget (max-width: 1300px) { .cards-horizontal { --cards-per-row: 5.5; } }
@container widget (max-width: 1100px) { .cards-horizontal { --cards-per-row: 4.5; } }
@container widget (max-width: 850px) { .cards-horizontal { --cards-per-row: 3.5; } }
@container widget (max-width: 750px) { .cards-horizontal { --cards-per-row: 3.5; } }
@container widget (max-width: 650px) { .cards-horizontal { --cards-per-row: 2.5; } }
@container widget (max-width: 450px) { .cards-horizontal { --cards-per-row: 2.3; } }
@container widget (max-width: 1300px) { .cards-grid { --cards-per-row: 5; } }
@container widget (max-width: 1100px) { .cards-grid { --cards-per-row: 4; } }
@container widget (max-width: 850px) { .cards-grid { --cards-per-row: 3; } }
@container widget (max-width: 750px) { .cards-grid { --cards-per-row: 3; } }
@container widget (max-width: 650px) { .cards-grid { --cards-per-row: 2; } }
.text-truncate,
.single-line-titles .title
{
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}
.single-line-titles .title {
    display: block;
}
.text-truncate-2-lines, .text-truncate-3-lines {
    overflow: hidden;
    text-overflow: ellipsis;
    display: -webkit-box;
    -webkit-box-orient: vertical;
}
.text-truncate-3-lines { line-clamp: 3; -webkit-line-clamp: 3; }
.text-truncate-2-lines { line-clamp: 2; -webkit-line-clamp: 2; }
.visited-indicator:not(.text-truncate)::after,
.visited-indicator.text-truncate::before {
    content: '↗' / "";
    margin-left: 0.5em;
    display: inline-block;
    position: relative;
    top: 0.15em;
    color: var(--color-text-base);
}
.visited-indicator.text-truncate {
    direction: rtl;
    text-align: left;
}
.visited-indicator:not(:visited)::before, .visited-indicator:not(:visited)::after {
    color: var(--color-primary);
}
.page-columns-transitioned .list-with-transition > * { animation: collapsibleItemReveal .25s backwards; }
.list-with-transition > *:nth-child(2) { animation-delay: 30ms; }
.list-with-transition > *:nth-child(3) { animation-delay: 60ms; }
.list-with-transition > *:nth-child(4) { animation-delay: 90ms; }
.list-with-transition > *:nth-child(5) { animation-delay: 120ms; }
.list-with-transition > *:nth-child(6) { animation-delay: 150ms; }
.list-with-transition > *:nth-child(7) { animation-delay: 180ms; }
.list-with-transition > *:nth-child(8) { animation-delay: 210ms; }
.list > *:not(:first-child) {
    margin-top: calc(var(--list-half-gap) * 2);
}
.list.list-with-separator > *:not(:first-child) {
    margin-top: var(--list-half-gap);
    border-top: 1px solid var(--color-separator);
    padding-top: var(--list-half-gap);
}
.collapsible-container:not(.container-expanded) > .collapsible-item {
    display: none;
}
.collapsible-item {
    animation: collapsibleItemReveal .25s backwards;
}
@keyframes collapsibleItemReveal {
    from {
        opacity: 0;
        transform: translateY(10px);
    }
}
.expand-toggle-button {
    font: inherit;
    border: 0;
    cursor: pointer;
    display: block;
    width: 100%;
    text-align: left;
    color: var(--color-text-base);
    text-transform: uppercase;
    font-size: var(--font-size-h4);
    padding: var(--widget-content-vertical-padding) 0;
    background: var(--color-widget-background);
}
.expand-toggle-button.container-expanded {
    position: sticky;
    /* -1px to hide 1px gap on chrome */
    bottom: -1px;
}
.expand-toggle-button-icon {
    display: inline-block;
    margin-left: 1rem;
    position: relative;
    top: -.2rem;
}
.expand-toggle-button-icon::before {
    content: '' / "";
    font-size: 0.8rem;
    transform: rotate(90deg);
    line-height: 1;
    display: inline-block;
    transition: transform 0.3s;
}
.expand-toggle-button.container-expanded .expand-toggle-button-icon::before {
    transform: rotate(-90deg);
}
.cards-grid.collapsible-container + .expand-toggle-button {
    text-align: center;
    margin-top: 0.5rem;
    background-color: var(--color-background);
}
.widget-content:has(.expand-toggle-button:last-child) {
    padding-bottom: 0;
}
.carousel-container {
    position: relative;
}
.carousel-container::before, .carousel-container::after {
    content: '';
    position: absolute;
    width: 2rem;
    top: 0;
    bottom: 1rem;
    z-index: 10;
    opacity: 0;
    pointer-events: none;
    transition-duration: 0.2s;
}
.carousel-container::before {
    background: linear-gradient(to right, var(--color-background), transparent);
}
.carousel-container::after {
    right: 0;
    background: linear-gradient(to left, var(--color-background), transparent);
}
.carousel-container.show-left-cutoff::before, .carousel-container.show-right-cutoff::after {
    opacity: 1;
}
.attachments {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
}
:root:not([data-scheme=light]) .flat-icon {
    filter: invert(1);
}
.attachments > * {
    border-radius: var(--border-radius);
    padding: 0.1rem 0.5rem;
    font-size: var(--font-size-h6);
    background-color: var(--color-separator);
}
.progress-bar {
    border: 1px solid var(--color-progress-border);
    border-radius: var(--border-radius);
    display: flex;
    flex-direction: column;
    gap: 2px;
    padding: 2px;
    height: 1.5rem;
    /* naughty, but oh so beautiful */
    margin-inline: -3px;
}
.progress-bar-combined {
    height: 3rem;
}
.popover-active > .progress-bar {
    transition: border-color .3s;
    border-color: var(--color-text-subdue);
}
.progress-value {
    --half-border-radius: calc(var(--border-radius) / 2);
    border-radius: 0 var(--half-border-radius) var(--half-border-radius) 0;
    background: var(--color-progress-value);
    width: calc(var(--percent) * 1%);
    min-width: 1px;
    flex: 1;
}
.progress-value:first-child {
    border-top-left-radius: var(--half-border-radius);
}
.progress-value:last-child {
    border-bottom-left-radius: var(--half-border-radius);
}
.progress-value-notice {
    background: linear-gradient(to right, var(--color-progress-value) 65%, var(--color-negative));
}
.value-separator {
    min-width: 2rem;
    margin-inline: 0.8rem;
    flex: 1;
    height: calc(1em * 1.1);
    border-bottom: 1px dotted var(--color-text-subdue);
}
.thumbnail {
    filter: grayscale(0.2) contrast(0.9);
    opacity: 0.8;
    transition: filter 0.2s, opacity .2s;
}
.thumbnail-container {
    flex-shrink: 0;
    border: 1px solid var(--color-separator);
    border-radius: var(--border-radius);
}
.thumbnail-container > * {
    border-radius: var(--border-radius);
    object-fit: cover;
}
.thumbnail-parent:hover .thumbnail {
    opacity: 1;
    filter: none;
}
.hide-scrollbars {
    scrollbar-width: none;
}
/* Hide on Safari and Chrome */
.hide-scrollbars::-webkit-scrollbar {
    display: none;
}
.ui-icon {
    width: 2.3rem;
    height: 2.3rem;
    display: block;
    flex-shrink: 0;
}
.size-h1 { font-size: var(--font-size-h1); }
.size-h2 { font-size: var(--font-size-h2); }
.size-h3 { font-size: var(--font-size-h3); }
.size-h4 { font-size: var(--font-size-h4); }
.size-base { font-size: var(--font-size-base); }
.size-h5 { font-size: var(--font-size-h5); }
.size-h6 { font-size: var(--font-size-h6); }
.color-highlight { color: var(--color-text-highlight); }
.color-paragraph { color: var(--color-text-paragraph); }
.color-base { color: var(--color-text-base); }
.color-subdue { color: var(--color-text-subdue); }
.color-negative { color: var(--color-negative); }
.color-positive { color: var(--color-positive); }
.color-primary { color: var(--color-primary); }
.color-primary-if-not-visited:not(:visited) {
    color: var(--color-primary);
}
.drag-and-drop-container {
    position: relative;
}
.drag-and-drop-decoy {
    outline: 1px dashed var(--color-primary);
    opacity: 0.25;
    border-radius: var(--border-radius);
}
.drag-and-drop-draggable {
    position: absolute;
    cursor: grabbing !important;
}
.drag-and-drop-draggable:empty {
    display: none;
}
.drag-and-drop-draggable * {
    cursor: grabbing !important;
}
.auto-scaling-textarea-container {
    position: relative;
}
.auto-scaling-textarea {
    position: absolute;
    inset: 0;
    background: none;
    border: none;
    font: inherit;
    resize: none;
    color: inherit;
    overflow: hidden;
}
.auto-scaling-textarea:focus {
    outline: none;
}
.auto-scaling-textarea-mimic {
    white-space: pre-wrap;
    min-height: 1lh;
    user-select: none;
    word-wrap: break-word;
    font: inherit;
    visibility: hidden;
}
.cursor-help { cursor: help; }
.rounded { border-radius: var(--border-radius); }
.break-all { word-break: break-all; }
.text-left { text-align: left; }
.text-right { text-align: right; }
.text-center { text-align: center; }
.text-elevate { margin-top: -0.2em; }
.text-compact { word-spacing: -0.18em; }
.text-very-compact { word-spacing: -0.35em; }
.rtl { direction: rtl; }
.shrink { flex-shrink: 1; }
.shrink-0 { flex-shrink: 0; }
.min-width-0 { min-width: 0; }
.max-width-100 { max-width: 100%; }
.block { display: block; }
.inline-block { display: inline-block; }
.overflow-hidden { overflow: hidden; }
.relative { position: relative; }
.flex { display: flex; }
.flex-1 { flex: 1; }
.flex-wrap { flex-wrap: wrap; }
.flex-nowrap { flex-wrap: nowrap; }
.justify-between { justify-content: space-between; }
.justify-stretch { justify-content: stretch; }
.justify-evenly { justify-content: space-evenly; }
.justify-center { justify-content: center; }
.justify-end { justify-content: end; }
.uppercase { text-transform: uppercase; }
.grow { flex-grow: 1; }
.flex-column { flex-direction: column; }
.items-center { align-items: center; }
.self-center { align-self: center; }
.items-start { align-items: start; }
.items-end { align-items: end; }
.gap-5 { gap: 0.5rem; }
.gap-7 { gap: 0.7rem; }
.gap-10 { gap: 1rem; }
.gap-12 { gap: 1.2rem; }
.gap-15 { gap: 1.5rem; }
.gap-20 { gap: 2rem; }
.gap-25 { gap: 2.5rem; }
.gap-35 { gap: 3.5rem; }
.gap-45 { gap: 4.5rem; }
.gap-55 { gap: 5.5rem; }
.margin-left-auto { margin-left: auto; }
.margin-top-3 { margin-top: 0.3rem; }
.margin-top-5 { margin-top: 0.5rem; }
.margin-top-7 { margin-top: 0.7rem; }
.margin-top-10 { margin-top: 1rem; }
.margin-top-15 { margin-top: 1.5rem; }
.margin-top-20 { margin-top: 2rem; }
.margin-top-25 { margin-top: 2.5rem; }
.margin-top-35 { margin-top: 3.5rem; }
.margin-top-40 { margin-top: 4rem; }
.margin-top-auto { margin-top: auto; }
.margin-block-3 { margin-block: 0.3rem; }
.margin-block-5 { margin-block: 0.5rem; }
.margin-block-7 { margin-block: 0.7rem; }
.margin-block-8 { margin-block: 0.8rem; }
.margin-block-10 { margin-block: 1rem; }
.margin-block-15 { margin-block: 1.5rem; }
.margin-bottom-3 { margin-bottom: 0.3rem; }
.margin-bottom-5 { margin-bottom: 0.5rem; }
.margin-bottom-7 { margin-bottom: 0.7rem; }
.margin-bottom-10 { margin-bottom: 1rem; }
.margin-bottom-15 { margin-bottom: 1.5rem; }
.margin-bottom-auto { margin-bottom: auto; }
.margin-bottom-widget { margin-bottom: var(--widget-content-vertical-padding); }
.padding-widget { padding: var(--widget-content-padding); }
.padding-block-widget { padding-block: var(--widget-content-vertical-padding); }
.padding-inline-widget { padding-inline: var(--widget-content-horizontal-padding); }
.pointer-events-none { pointer-events: none; }
.select-none { user-select: none; }
.padding-block-5 { padding-block: 0.5rem; }
.scale-half { transform: scale(0.5); }
.list { --list-half-gap: 0rem; }
.list-gap-2 { --list-half-gap: 0.1rem; }
.list-gap-4 { --list-half-gap: 0.2rem; }
.list-gap-8 { --list-half-gap: 0.4rem; }
.list-gap-10 { --list-half-gap: 0.5rem; }
.list-gap-14 { --list-half-gap: 0.7rem; }
.list-gap-20 { --list-half-gap: 1rem; }
.list-gap-24 { --list-half-gap: 1.2rem; }
.list-gap-34 { --list-half-gap: 1.7rem; }
@media (max-width: 1190px) {
    .size-base-on-mobile { font-size: var(--font-size-base); }
}
</file>

<file path="internal/glance/widget.go">
package glance
import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"html/template"
	"log/slog"
	"math"
	"net/http"
	"sync/atomic"
	"time"
	"gopkg.in/yaml.v3"
)
var widgetIDCounter atomic.Uint64
func newWidget(widgetType string) (widget, error) {
	if widgetType == "" {
		return nil, errors.New("widget 'type' property is empty or not specified")
	}
	var w widget
	switch widgetType {
	case "calendar":
		w = &calendarWidget{}
	case "calendar-legacy":
		w = &oldCalendarWidget{}
	case "clock":
		w = &clockWidget{}
	case "weather":
		w = &weatherWidget{}
	case "bookmarks":
		w = &bookmarksWidget{}
	case "iframe":
		w = &iframeWidget{}
	case "html":
		w = &htmlWidget{}
	case "hacker-news":
		w = &hackerNewsWidget{}
	case "releases":
		w = &releasesWidget{}
	case "videos":
		w = &videosWidget{}
	case "markets", "stocks":
		w = &marketsWidget{}
	case "reddit":
		w = &redditWidget{}
	case "rss":
		w = &rssWidget{}
	case "monitor":
		w = &monitorWidget{}
	case "twitch-top-games":
		w = &twitchGamesWidget{}
	case "twitch-channels":
		w = &twitchChannelsWidget{}
	case "lobsters":
		w = &lobstersWidget{}
	case "change-detection":
		w = &changeDetectionWidget{}
	case "repository":
		w = &repositoryWidget{}
	case "search":
		w = &searchWidget{}
	case "extension":
		w = &extensionWidget{}
	case "group":
		w = &groupWidget{}
	case "dns-stats":
		w = &dnsStatsWidget{}
	case "split-column":
		w = &splitColumnWidget{}
	case "custom-api":
		w = &customAPIWidget{}
	case "docker-containers":
		w = &dockerContainersWidget{}
	case "server-stats":
		w = &serverStatsWidget{}
	case "to-do":
		w = &todoWidget{}
	default:
		return nil, fmt.Errorf("unknown widget type: %s", widgetType)
	}
	w.setID(widgetIDCounter.Add(1))
	return w, nil
}
type widgets []widget
func (w *widgets) UnmarshalYAML(node *yaml.Node) error {
	var nodes []yaml.Node
	if err := node.Decode(&nodes); err != nil {
		return err
	}
	for _, node := range nodes {
		meta := struct {
			Type string `yaml:"type"`
		}{}
		if err := node.Decode(&meta); err != nil {
			return err
		}
		widget, err := newWidget(meta.Type)
		if err != nil {
			return fmt.Errorf("line %d: %w", node.Line, err)
		}
		if err = node.Decode(widget); err != nil {
			return err
		}
		*w = append(*w, widget)
	}
	return nil
}
type widget interface {
	// These need to be exported because they get called in templates
	Render() template.HTML
	GetType() string
	GetID() uint64
	GetHTMXTrigger() template.HTMLAttr
	initialize() error
	requiresUpdate(*time.Time) bool
	setProviders(*widgetProviders)
	update(context.Context)
	setID(uint64)
	handleRequest(w http.ResponseWriter, r *http.Request)
	setHideHeader(bool)
}
type cacheType int
const (
	cacheTypeInfinite cacheType = iota
	cacheTypeDuration
	cacheTypeOnTheHour
)
type widgetBase struct {
	ID                  uint64           `yaml:"-"`
	Providers           *widgetProviders `yaml:"-"`
	Type                string           `yaml:"type"`
	Title               string           `yaml:"title"`
	TitleURL            string           `yaml:"title-url"`
	HideHeader          bool             `yaml:"hide-header"`
	CSSClass            string           `yaml:"css-class"`
	CustomCacheDuration durationField    `yaml:"cache"`
	ContentAvailable    bool             `yaml:"-"`
	WIP                 bool             `yaml:"-"`
	Error               error            `yaml:"-"`
	Notice              error            `yaml:"-"`
	templateBuffer      bytes.Buffer     `yaml:"-"`
	cacheDuration       time.Duration    `yaml:"-"`
	cacheType           cacheType        `yaml:"-"`
	nextUpdate          time.Time        `yaml:"-"`
	updateRetriedTimes  int              `yaml:"-"`
}
type widgetProviders struct {
	assetResolver func(string) string
	hub           *hub
}
func (w *widgetBase) requiresUpdate(now *time.Time) bool {
	if w.cacheType == cacheTypeInfinite {
		return false
	}
	if w.nextUpdate.IsZero() {
		return true
	}
	return now.After(w.nextUpdate)
}
func (w *widgetBase) IsWIP() bool {
	return w.WIP
}
func (w *widgetBase) update(ctx context.Context) {
}
func (w *widgetBase) GetID() uint64 {
	return w.ID
}
func (w *widgetBase) setID(id uint64) {
	w.ID = id
}
func (w *widgetBase) setHideHeader(value bool) {
	w.HideHeader = value
}
func (widget *widgetBase) handleRequest(w http.ResponseWriter, r *http.Request) {
	http.Error(w, "not implemented", http.StatusNotImplemented)
}
func (w *widgetBase) GetType() string {
	return w.Type
}
func (w *widgetBase) GetHTMXTrigger() template.HTMLAttr {
	if w.cacheType == cacheTypeDuration && w.cacheDuration > 0 {
		return template.HTMLAttr(fmt.Sprintf(`hx-trigger="every %ds"`, int(w.cacheDuration.Seconds())))
	} else if w.cacheType == cacheTypeOnTheHour {
		return template.HTMLAttr(`hx-trigger="every 1h"`)
	}
	return ""
}
func (w *widgetBase) setProviders(providers *widgetProviders) {
	w.Providers = providers
}
func (w *widgetBase) renderTemplate(data any, t *template.Template) template.HTML {
	w.templateBuffer.Reset()
	err := t.Execute(&w.templateBuffer, data)
	if err != nil {
		w.ContentAvailable = false
		w.Error = err
		slog.Error("Failed to render template", "error", err)
		// need to immediately re-render with the error,
		// otherwise risk breaking the page since the widget
		// will likely be partially rendered with tags not closed.
		w.templateBuffer.Reset()
		err2 := t.Execute(&w.templateBuffer, data)
		if err2 != nil {
			slog.Error("Failed to render error within widget", "error", err2, "initial_error", err)
			w.templateBuffer.Reset()
			// TODO: add some kind of a generic widget error template when the widget
			// failed to render, and we also failed to re-render the widget with the error
		}
	}
	return template.HTML(w.templateBuffer.String())
}
func (w *widgetBase) withTitle(title string) *widgetBase {
	if w.Title == "" {
		w.Title = title
	}
	return w
}
func (w *widgetBase) withTitleURL(titleURL string) *widgetBase {
	if w.TitleURL == "" {
		w.TitleURL = titleURL
	}
	return w
}
func (w *widgetBase) withCacheDuration(duration time.Duration) *widgetBase {
	w.cacheType = cacheTypeDuration
	if duration == -1 || w.CustomCacheDuration == 0 {
		w.cacheDuration = duration
	} else {
		w.cacheDuration = time.Duration(w.CustomCacheDuration)
	}
	return w
}
func (w *widgetBase) withCacheOnTheHour() *widgetBase {
	w.cacheType = cacheTypeOnTheHour
	return w
}
func (w *widgetBase) withNotice(err error) *widgetBase {
	w.Notice = err
	return w
}
func (w *widgetBase) withError(err error) *widgetBase {
	if err == nil && !w.ContentAvailable {
		w.ContentAvailable = true
	}
	w.Error = err
	return w
}
func (w *widgetBase) canContinueUpdateAfterHandlingErr(err error) bool {
	// TODO: needs covering more edge cases.
	// if there's partial content and we update early there's a chance
	// the early update returns even less content than the initial update.
	// need some kind of mechanism that tells us whether we should update early
	// or not depending on the number of things that failed during the initial
	// and subsequent update and how they failed - ie whether it was server
	// error (like gateway timeout, do retry early) or client error (like
	// hitting a rate limit, don't retry early). will require reworking a
	// good amount of code in the feed package and probably having a custom
	// error type that holds more information because screw wrapping errors.
	// alternatively have a resource cache and only refetch the failed resources,
	// then rebuild the widget.
	if err != nil {
		w.scheduleEarlyUpdate()
		if !errors.Is(err, errPartialContent) {
			w.withError(err)
			w.withNotice(nil)
			return false
		}
		w.withError(nil)
		w.withNotice(err)
		return true
	}
	w.withNotice(nil)
	w.withError(nil)
	w.scheduleNextUpdate()
	return true
}
func (w *widgetBase) getNextUpdateTime() time.Time {
	now := time.Now()
	if w.cacheType == cacheTypeDuration {
		return now.Add(w.cacheDuration)
	}
	if w.cacheType == cacheTypeOnTheHour {
		return now.Add(time.Duration(
			((60-now.Minute())*60)-now.Second(),
		) * time.Second)
	}
	return time.Time{}
}
func (w *widgetBase) scheduleNextUpdate() *widgetBase {
	w.nextUpdate = w.getNextUpdateTime()
	w.updateRetriedTimes = 0
	return w
}
func (w *widgetBase) scheduleEarlyUpdate() *widgetBase {
	w.updateRetriedTimes++
	if w.updateRetriedTimes > 5 {
		w.updateRetriedTimes = 5
	}
	nextEarlyUpdate := time.Now().Add(time.Duration(math.Pow(float64(w.updateRetriedTimes), 2)) * time.Minute)
	nextUsualUpdate := w.getNextUpdateTime()
	if nextEarlyUpdate.After(nextUsualUpdate) {
		w.nextUpdate = nextUsualUpdate
	} else {
		w.nextUpdate = nextEarlyUpdate
	}
	return w
}
</file>

<file path="internal/glance/config.go">
package glance
import (
	"bytes"
	"errors"
	"fmt"
	"html/template"
	"iter"
	"log"
	"maps"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"sync"
	"time"
	"github.com/fsnotify/fsnotify"
	"gopkg.in/yaml.v3"
)
const CONFIG_INCLUDE_RECURSION_DEPTH_LIMIT = 20
const (
	configVarTypeEnv         = "env"
	configVarTypeSecret      = "secret"
	configVarTypeFileFromEnv = "readFileFromEnv"
)
type config struct {
	Server struct {
		Host       string `yaml:"host"`
		Port       uint16 `yaml:"port"`
		Proxied    bool   `yaml:"proxied"`
		AssetsPath string `yaml:"assets-path"`
		BaseURL    string `yaml:"base-url"`
	} `yaml:"server"`
	Auth struct {
		SecretKey string           `yaml:"secret-key"`
		Users     map[string]*user `yaml:"users"`
	} `yaml:"auth"`
	Document struct {
		Head template.HTML `yaml:"head"`
	} `yaml:"document"`
	Theme struct {
		themeProperties `yaml:",inline"`
		CustomCSSFile   string `yaml:"custom-css-file"`
		DisablePicker bool                                     `yaml:"disable-picker"`
		Presets       orderedYAMLMap[string, *themeProperties] `yaml:"presets"`
	} `yaml:"theme"`
	Branding struct {
		HideFooter         bool          `yaml:"hide-footer"`
		CustomFooter       template.HTML `yaml:"custom-footer"`
		LogoText           string        `yaml:"logo-text"`
		LogoURL            string        `yaml:"logo-url"`
		FaviconURL         string        `yaml:"favicon-url"`
		FaviconType        string        `yaml:"-"`
		AppName            string        `yaml:"app-name"`
		AppIconURL         string        `yaml:"app-icon-url"`
		AppBackgroundColor string        `yaml:"app-background-color"`
	} `yaml:"branding"`
	Pages []page `yaml:"pages"`
}
type user struct {
	Password           string `yaml:"password"`
	PasswordHashString string `yaml:"password-hash"`
	PasswordHash       []byte `yaml:"-"`
}
type page struct {
	Title                  string  `yaml:"name"`
	Slug                   string  `yaml:"slug"`
	Width                  string  `yaml:"width"`
	DesktopNavigationWidth string  `yaml:"desktop-navigation-width"`
	ShowMobileHeader       bool    `yaml:"show-mobile-header"`
	HideDesktopNavigation  bool    `yaml:"hide-desktop-navigation"`
	CenterVertically       bool    `yaml:"center-vertically"`
	HeadWidgets            widgets `yaml:"head-widgets"`
	Columns                []struct {
		Size    string  `yaml:"size"`
		Widgets widgets `yaml:"widgets"`
	} `yaml:"columns"`
	PrimaryColumnIndex int8       `yaml:"-"`
	mu                 sync.Mutex `yaml:"-"`
}
func newConfigFromYAML(contents []byte) (*config, error) {
	contents, err := parseConfigVariables(contents)
	if err != nil {
		return nil, err
	}
	config := &config{}
	config.Server.Port = 8080
	err = yaml.Unmarshal(contents, config)
	if err != nil {
		return nil, err
	}
	if err = isConfigStateValid(config); err != nil {
		return nil, err
	}
	for p := range config.Pages {
		for w := range config.Pages[p].HeadWidgets {
			if err := config.Pages[p].HeadWidgets[w].initialize(); err != nil {
				return nil, formatWidgetInitError(err, config.Pages[p].HeadWidgets[w])
			}
		}
		for c := range config.Pages[p].Columns {
			for w := range config.Pages[p].Columns[c].Widgets {
				if err := config.Pages[p].Columns[c].Widgets[w].initialize(); err != nil {
					return nil, formatWidgetInitError(err, config.Pages[p].Columns[c].Widgets[w])
				}
			}
		}
	}
	return config, nil
}
var envVariableNamePattern = regexp.MustCompile(`^[A-Z0-9_]+$`)
var configVariablePattern = regexp.MustCompile(`(^|.)\$\{(?:([a-zA-Z]+):)?([a-zA-Z0-9_-]+)\}`)
// Parses variables defined in the config such as:
// ${API_KEY} 				            - gets replaced with the value of the API_KEY environment variable
// \${API_KEY} 					        - escaped, gets used as is without the \ in the config
// ${secret:api_key} 			        - value gets loaded from /run/secrets/api_key
// ${readFileFromEnv:PATH_TO_SECRET}    - value gets loaded from the file path specified in the environment variable PATH_TO_SECRET
//
// TODO: don't match against commented out sections, not sure exactly how since
// variables can be placed anywhere and used to modify the YAML structure itself
func parseConfigVariables(contents []byte) ([]byte, error) {
	var err error
	replaced := configVariablePattern.ReplaceAllFunc(contents, func(match []byte) []byte {
		if err != nil {
			return nil
		}
		groups := configVariablePattern.FindSubmatch(match)
		if len(groups) != 4 {
			// we can't handle this match, this shouldn't happen unless the number of groups
			// in the regex has been changed without updating the below code
			return match
		}
		prefix := string(groups[1])
		if prefix == `\` {
			if len(match) >= 2 {
				return match[1:]
			} else {
				return nil
			}
		}
		typeAsString, variableName := string(groups[2]), string(groups[3])
		variableType := ternary(typeAsString == "", configVarTypeEnv, typeAsString)
		parsedValue, returnOriginal, localErr := parseConfigVariableOfType(variableType, variableName)
		if localErr != nil {
			err = fmt.Errorf("parsing variable: %v", localErr)
			return nil
		}
		if returnOriginal {
			return match
		}
		return []byte(prefix + parsedValue)
	})
	if err != nil {
		return nil, err
	}
	return replaced, nil
}
// When the bool return value is true, it indicates that the caller should use the original value
func parseConfigVariableOfType(variableType, variableName string) (string, bool, error) {
	switch variableType {
	case configVarTypeEnv:
		if !envVariableNamePattern.MatchString(variableName) {
			return "", true, nil
		}
		v, found := os.LookupEnv(variableName)
		if !found {
			return "", false, fmt.Errorf("environment variable %s not found", variableName)
		}
		return v, false, nil
	case configVarTypeSecret:
		secretPath := filepath.Join("/run/secrets", variableName)
		secret, err := os.ReadFile(secretPath)
		if err != nil {
			return "", false, fmt.Errorf("reading secret file: %v", err)
		}
		return strings.TrimSpace(string(secret)), false, nil
	case configVarTypeFileFromEnv:
		if !envVariableNamePattern.MatchString(variableName) {
			return "", true, nil
		}
		filePath, found := os.LookupEnv(variableName)
		if !found {
			return "", false, fmt.Errorf("readFileFromEnv: environment variable %s not found", variableName)
		}
		if !filepath.IsAbs(filePath) {
			return "", false, fmt.Errorf("readFileFromEnv: file path %s is not absolute", filePath)
		}
		fileContents, err := os.ReadFile(filePath)
		if err != nil {
			return "", false, fmt.Errorf("readFileFromEnv: reading file from %s: %v", variableName, err)
		}
		return strings.TrimSpace(string(fileContents)), false, nil
	default:
		return "", true, nil
	}
}
func formatWidgetInitError(err error, w widget) error {
	return fmt.Errorf("%s widget: %v", w.GetType(), err)
}
var configIncludePattern = regexp.MustCompile(`(?m)^([ \t]*)(?:-[ \t]*)?(?:!|\$)include:[ \t]*(.+)$`)
func parseYAMLIncludes(mainFilePath string) ([]byte, map[string]struct{}, error) {
	return recursiveParseYAMLIncludes(mainFilePath, nil, 0)
}
func recursiveParseYAMLIncludes(mainFilePath string, includes map[string]struct{}, depth int) ([]byte, map[string]struct{}, error) {
	if depth > CONFIG_INCLUDE_RECURSION_DEPTH_LIMIT {
		return nil, nil, fmt.Errorf("recursion depth limit of %d reached", CONFIG_INCLUDE_RECURSION_DEPTH_LIMIT)
	}
	mainFileContents, err := os.ReadFile(mainFilePath)
	if err != nil {
		return nil, nil, fmt.Errorf("reading %s: %w", mainFilePath, err)
	}
	mainFileAbsPath, err := filepath.Abs(mainFilePath)
	if err != nil {
		return nil, nil, fmt.Errorf("getting absolute path of %s: %w", mainFilePath, err)
	}
	mainFileDir := filepath.Dir(mainFileAbsPath)
	if includes == nil {
		includes = make(map[string]struct{})
	}
	var includesLastErr error
	mainFileContents = configIncludePattern.ReplaceAllFunc(mainFileContents, func(match []byte) []byte {
		if includesLastErr != nil {
			return nil
		}
		matches := configIncludePattern.FindSubmatch(match)
		if len(matches) != 3 {
			includesLastErr = fmt.Errorf("invalid include match: %v", matches)
			return nil
		}
		indent := string(matches[1])
		includeFilePath := strings.TrimSpace(string(matches[2]))
		if !filepath.IsAbs(includeFilePath) {
			includeFilePath = filepath.Join(mainFileDir, includeFilePath)
		}
		var fileContents []byte
		var err error
		includes[includeFilePath] = struct{}{}
		fileContents, includes, err = recursiveParseYAMLIncludes(includeFilePath, includes, depth+1)
		if err != nil {
			includesLastErr = err
			return nil
		}
		return []byte(prefixStringLines(indent, string(fileContents)))
	})
	if includesLastErr != nil {
		return nil, nil, includesLastErr
	}
	return mainFileContents, includes, nil
}
func configFilesWatcher(
	mainFilePath string,
	lastContents []byte,
	lastIncludes map[string]struct{},
	onChange func(newContents []byte),
	onErr func(error),
) (func() error, error) {
	mainFileAbsPath, err := filepath.Abs(mainFilePath)
	if err != nil {
		return nil, fmt.Errorf("getting absolute path of main file: %w", err)
	}
	// TODO: refactor, flaky
	lastIncludes[mainFileAbsPath] = struct{}{}
	watcher, err := fsnotify.NewWatcher()
	if err != nil {
		return nil, fmt.Errorf("creating watcher: %w", err)
	}
	updateWatchedFiles := func(previousWatched map[string]struct{}, newWatched map[string]struct{}) {
		for filePath := range previousWatched {
			if _, ok := newWatched[filePath]; !ok {
				watcher.Remove(filePath)
			}
		}
		for filePath := range newWatched {
			if _, ok := previousWatched[filePath]; !ok {
				if err := watcher.Add(filePath); err != nil {
					log.Printf(
						"Could not add file to watcher, changes to this file will not trigger a reload. path: %s, error: %v",
						filePath, err,
					)
				}
			}
		}
	}
	updateWatchedFiles(nil, lastIncludes)
	// needed for lastContents and lastIncludes because they get updated in multiple goroutines
	mu := sync.Mutex{}
	parseAndCompareBeforeCallback := func() {
		currentContents, currentIncludes, err := parseYAMLIncludes(mainFilePath)
		if err != nil {
			onErr(fmt.Errorf("parsing main file contents for comparison: %w", err))
			return
		}
		// TODO: refactor, flaky
		currentIncludes[mainFileAbsPath] = struct{}{}
		mu.Lock()
		defer mu.Unlock()
		if !maps.Equal(currentIncludes, lastIncludes) {
			updateWatchedFiles(lastIncludes, currentIncludes)
			lastIncludes = currentIncludes
		}
		if !bytes.Equal(lastContents, currentContents) {
			lastContents = currentContents
			onChange(currentContents)
		}
	}
	const debounceDuration = 500 * time.Millisecond
	var debounceTimer *time.Timer
	debouncedParseAndCompareBeforeCallback := func() {
		if debounceTimer != nil {
			debounceTimer.Stop()
			debounceTimer.Reset(debounceDuration)
		} else {
			debounceTimer = time.AfterFunc(debounceDuration, parseAndCompareBeforeCallback)
		}
	}
	deleteLastInclude := func(filePath string) {
		mu.Lock()
		defer mu.Unlock()
		fileAbsPath, _ := filepath.Abs(filePath)
		delete(lastIncludes, fileAbsPath)
	}
	go func() {
		for {
			select {
			case event, isOpen := <-watcher.Events:
				if !isOpen {
					return
				}
				if event.Has(fsnotify.Write) {
					debouncedParseAndCompareBeforeCallback()
				} else if event.Has(fsnotify.Rename) {
					// on linux the file will no longer be watched after a rename, on windows
					// it will continue to be watched with the new name but we have no access to
					// the new name in this event in order to stop watching it manually and match the
					// behavior in linux, may lead to weird unintended behaviors on windows as we're
					// only handling renames from linux's perspective
					// see https://github.com/fsnotify/fsnotify/issues/255
					// remove the old file from our manually tracked includes, calling
					// debouncedParseAndCompareBeforeCallback will re-add it if it's still
					// required after it triggers
					deleteLastInclude(event.Name)
					// wait for file to maybe get created again
					// see https://github.com/glanceapp/glance/pull/358
					for range 10 {
						if _, err := os.Stat(event.Name); err == nil {
							break
						}
						time.Sleep(200 * time.Millisecond)
					}
					debouncedParseAndCompareBeforeCallback()
				} else if event.Has(fsnotify.Remove) {
					deleteLastInclude(event.Name)
					debouncedParseAndCompareBeforeCallback()
				}
			case err, isOpen := <-watcher.Errors:
				if !isOpen {
					return
				}
				onErr(fmt.Errorf("watcher error: %w", err))
			}
		}
	}()
	onChange(lastContents)
	return func() error {
		if debounceTimer != nil {
			debounceTimer.Stop()
		}
		return watcher.Close()
	}, nil
}
// TODO: Refactor, we currently validate in two different places, this being
// one of them, which doesn't modify the data and only checks for logical errors
// and then again when creating the application which does modify the data and do
// further validation. Would be better if validation was done in a single place.
func isConfigStateValid(config *config) error {
	if len(config.Pages) == 0 {
		return fmt.Errorf("no pages configured")
	}
	if len(config.Auth.Users) > 0 && config.Auth.SecretKey == "" {
		return fmt.Errorf("secret-key must be set when users are configured")
	}
	for username := range config.Auth.Users {
		if username == "" {
			return fmt.Errorf("user has no name")
		}
		if len(username) < 3 {
			return errors.New("usernames must be at least 3 characters")
		}
		user := config.Auth.Users[username]
		if user.Password == "" {
			if user.PasswordHashString == "" {
				return fmt.Errorf("user %s must have a password or a password-hash set", username)
			}
		} else if len(user.Password) < 6 {
			return fmt.Errorf("the password for %s must be at least 6 characters", username)
		}
	}
	if config.Server.AssetsPath != "" {
		if _, err := os.Stat(config.Server.AssetsPath); os.IsNotExist(err) {
			return fmt.Errorf("assets directory does not exist: %s", config.Server.AssetsPath)
		}
	}
	for i := range config.Pages {
		page := &config.Pages[i]
		if page.Title == "" {
			return fmt.Errorf("page %d has no name", i+1)
		}
		if page.Width != "" && (page.Width != "wide" && page.Width != "slim" && page.Width != "default") {
			return fmt.Errorf("page %d: width can only be either wide or slim", i+1)
		}
		if page.DesktopNavigationWidth != "" {
			if page.DesktopNavigationWidth != "wide" && page.DesktopNavigationWidth != "slim" && page.DesktopNavigationWidth != "default" {
				return fmt.Errorf("page %d: desktop-navigation-width can only be either wide or slim", i+1)
			}
		}
		if len(page.Columns) == 0 {
			return fmt.Errorf("page %d has no columns", i+1)
		}
		if page.Width == "slim" {
			if len(page.Columns) > 2 {
				return fmt.Errorf("page %d is slim and cannot have more than 2 columns", i+1)
			}
		} else {
			if len(page.Columns) > 3 {
				return fmt.Errorf("page %d has more than 3 columns", i+1)
			}
		}
		columnSizesCount := make(map[string]int)
		for j := range page.Columns {
			column := &page.Columns[j]
			if column.Size != "small" && column.Size != "full" {
				return fmt.Errorf("column %d of page %d: size can only be either small or full", j+1, i+1)
			}
			columnSizesCount[page.Columns[j].Size]++
		}
		full := columnSizesCount["full"]
		if full > 2 || full == 0 {
			return fmt.Errorf("page %d must have either 1 or 2 full width columns", i+1)
		}
	}
	return nil
}
// Read-only way to store ordered maps from a YAML structure
type orderedYAMLMap[K comparable, V any] struct {
	keys []K
	data map[K]V
}
func newOrderedYAMLMap[K comparable, V any](keys []K, values []V) (*orderedYAMLMap[K, V], error) {
	if len(keys) != len(values) {
		return nil, fmt.Errorf("keys and values must have the same length")
	}
	om := &orderedYAMLMap[K, V]{
		keys: make([]K, len(keys)),
		data: make(map[K]V, len(keys)),
	}
	copy(om.keys, keys)
	for i := range keys {
		om.data[keys[i]] = values[i]
	}
	return om, nil
}
func (om *orderedYAMLMap[K, V]) Items() iter.Seq2[K, V] {
	return func(yield func(K, V) bool) {
		for _, key := range om.keys {
			value, ok := om.data[key]
			if !ok {
				continue
			}
			if !yield(key, value) {
				return
			}
		}
	}
}
func (om *orderedYAMLMap[K, V]) Get(key K) (V, bool) {
	value, ok := om.data[key]
	return value, ok
}
func (self *orderedYAMLMap[K, V]) Merge(other *orderedYAMLMap[K, V]) *orderedYAMLMap[K, V] {
	merged := &orderedYAMLMap[K, V]{
		keys: make([]K, 0, len(self.keys)+len(other.keys)),
		data: make(map[K]V, len(self.data)+len(other.data)),
	}
	merged.keys = append(merged.keys, self.keys...)
	maps.Copy(merged.data, self.data)
	for _, key := range other.keys {
		if _, exists := self.data[key]; !exists {
			merged.keys = append(merged.keys, key)
		}
	}
	maps.Copy(merged.data, other.data)
	return merged
}
func (om *orderedYAMLMap[K, V]) UnmarshalYAML(node *yaml.Node) error {
	if node.Kind != yaml.MappingNode {
		return fmt.Errorf("orderedMap: expected mapping node, got %d", node.Kind)
	}
	if len(node.Content)%2 != 0 {
		return fmt.Errorf("orderedMap: expected even number of content items, got %d", len(node.Content))
	}
	om.keys = make([]K, len(node.Content)/2)
	om.data = make(map[K]V, len(node.Content)/2)
	for i := 0; i < len(node.Content); i += 2 {
		keyNode := node.Content[i]
		valueNode := node.Content[i+1]
		var key K
		if err := keyNode.Decode(&key); err != nil {
			return fmt.Errorf("orderedMap: decoding key: %v", err)
		}
		if _, ok := om.data[key]; ok {
			return fmt.Errorf("orderedMap: duplicate key %v", key)
		}
		var value V
		if err := valueNode.Decode(&value); err != nil {
			return fmt.Errorf("orderedMap: decoding value: %v", err)
		}
		(*om).keys[i/2] = key
		(*om).data[key] = value
	}
	return nil
}
</file>

<file path="internal/glance/static/css/site.css">
:root[data-scheme=light] {
    --scheme: 100% -;
}
.page {
    height: 100%;
    padding-block: var(--widget-gap);
}
.page-content, .page.content-ready .page-loading-container {
    display: none;
}
.page.content-ready > .page-content {
    display: block;
    animation: pageContentEntrance .3s cubic-bezier(0.25, 1, 0.5, 1) backwards;
}
.page-column-small .size-title-dynamic {
    font-size: var(--font-size-h4);
}
.page-column-full .size-title-dynamic {
    font-size: var(--font-size-h3);
}
pre {
    font: inherit;
}
input[type="text"] {
    width: 100%;
    border: 0;
    background: none;
    font: inherit;
    color: inherit;
}
button {
    font: inherit;
    border: 0;
    cursor: pointer;
    background: none;
    color: inherit;
}
::selection {
    background-color: hsl(var(--bghs), calc(var(--scheme) (var(--scheme) var(--bgl) + 20%)));
    color: var(--color-text-highlight);
}
::-webkit-scrollbar-thumb {
    background: var(--color-text-subdue);
    border-radius: var(--border-radius);
}
::-webkit-scrollbar {
    background: var(--color-background);
    height: 5px;
    width: 10px;
}
*:focus-visible {
    outline: 2px solid var(--color-primary);
    outline-offset: 0.1rem;
    border-radius: var(--border-radius);
}
*, *::before, *::after {
    box-sizing: border-box;
}
* {
    padding: 0;
    margin: 0;
}
hr {
    border: 0;
    height: 1px;
    background-color: var(--color-separator);
}
img, svg {
    display: block;
    max-width: 100%;
}
img[loading=lazy].loaded:not(.finished-transition) {
    transition: opacity .4s;
}
img[loading=lazy].cached:not(.finished-transition) {
    transition: none;
}
img[loading=lazy]:not(.loaded, .cached) {
    opacity: 0;
}
html {
    scrollbar-color: var(--color-text-subdue) transparent;
    scroll-behavior: smooth;
}
html, body, .body-content {
    height: 100%;
}
h1, h2, h3, h4, h5 {
    font: inherit;
}
a {
    text-decoration: none;
    color: inherit;
    overflow-wrap: break-word;
}
ul {
    list-style: none;
}
body {
    font-size: 1.3rem;
    font-family: 'JetBrains Mono', monospace;
    font-variant-ligatures: none;
    line-height: 1.6;
    color: var(--color-text-base);
    background-color: var(--color-background);
    overflow-y: scroll;
}
.page-column-small {
    width: 300px;
    flex-shrink: 0;
}
.page-column-full {
    width: 100%;
    min-width: 0;
}
.page-columns {
    display: flex;
    gap: var(--widget-gap);
}
@keyframes pageContentEntrance {
    from {
        opacity: 0;
        transform: translateY(10px);
    }
}
.page-loading-container {
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    animation: loadingContainerEntrance 200ms backwards;
    animation-delay: 150ms;
    font-size: 2rem;
}
.page-loading-container > .loading-icon {
    translate: 0 -250%;
}
@keyframes loadingContainerEntrance {
    from {
        /* Using 0.001 instead of 0 fixes a random 1s freeze on Chrome on page load when all */
        /* elements have opacity 0 and are animated in. I don't want to be a web dev anymore. */
        opacity: 0.001;
    }
}
.loading-icon {
    min-width: 1.5em;
    width: 1.5em;
    height: 1.5em;
    border: 0.25em solid hsl(var(--bghs), calc(var(--scheme) ((var(--scheme) var(--bgl)) + 12%)));
    border-top-color: hsl(var(--bghs), calc(var(--scheme) ((var(--scheme) var(--bgl)) + 40%)));
    border-radius: 50%;
    animation: loadingIconSpin 800ms infinite linear;
}
@keyframes loadingIconSpin {
    to {
        transform: rotate(360deg);
    }
}
.notice-icon {
    width: 0.7rem;
    height: 0.7rem;
    border-radius: 50%;
}
.notice-icon-major {
    background: var(--color-negative);
}
.notice-icon-minor {
    border: 1px solid var(--color-negative);
}
kbd {
    font: inherit;
    padding: 0.1rem 0.8rem;
    border-radius: var(--border-radius);
    border: 2px solid var(--color-widget-background-highlight);
    box-shadow: 0 2px 0 var(--color-widget-background-highlight);
    user-select: none;
    transition: transform .1s, box-shadow .1s;
    font-size: var(--font-size-h5);
    cursor: pointer;
}
kbd:active {
    transform: translateY(2px);
    box-shadow: 0 0 0 0 var(--color-widget-background-highlight);
}
.content-bounds {
    max-width: 1600px;
    width: 100%;
    margin-inline: auto;
    padding: 0 var(--content-bounds-padding);
}
.content-bounds-wide {
    max-width: 1920px;
}
.content-bounds-slim {
    max-width: 1100px;
}
.page.center-vertically {
    display: flex;
    justify-content: center;
    flex-direction: column;
}
.header-container {
    margin-top: calc(var(--widget-gap) / 2);
    --header-height: 45px;
    --header-items-gap: 2.5rem;
}
.header {
    display: flex;
    height: var(--header-height);
    gap: var(--header-items-gap);
}
.logo {
    height: 100%;
    flex-shrink: 0;
    line-height: var(--header-height);
    font-size: 2rem;
    color: var(--color-text-highlight);
    border-right: 1px solid var(--color-widget-content-border);
    padding-right: var(--widget-content-horizontal-padding);
}
.logo:has(img, svg) {
    display: flex;
    align-items: center;
}
.logo img {
    max-height: 2.7rem;
}
.nav {
    overflow-x: auto;
    min-width: 0;
    height: 100%;
    gap: var(--header-items-gap);
}
.nav .nav-item {
    line-height: var(--header-height);
}
.footer {
    padding-bottom: calc(var(--widget-gap) * 1.5);
    padding-top: calc(var(--widget-gap) / 2);
    animation: loadingContainerEntrance 200ms backwards;
    animation-delay: 150ms;
}
.mobile-navigation, .mobile-reachability-header {
    display: none;
}
.nav-item {
    display: block;
    height: 100%;
    border-bottom: 2px solid transparent;
    transition: color .3s, border-color .3s;
    font-size: var(--font-size-h3);
    flex-shrink: 0;
}
.nav-item:not(.nav-item-current):hover {
    border-bottom-color: var(--color-text-subdue);
    color: var(--color-text-highlight);
}
.nav-item.nav-item-current {
    border-bottom-color: var(--color-primary);
    color: var(--color-text-highlight);
}
.logout-button {
    width: 2rem;
    height: 2rem;
    stroke: var(--color-text-subdue);
    transition: stroke .2s;
}
.logout-button:hover, .logout-button:focus {
    stroke: var(--color-text-highlight);
}
.theme-choices {
    --presets-per-row: 2;
    display: grid;
    grid-template-columns: repeat(var(--presets-per-row), 1fr);
    align-items: center;
    gap: 1.35rem;
}
.theme-choices:has(> :nth-child(3)) {
    --presets-per-row: 3;
}
.theme-preset {
    background-color: var(--color);
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
    height: 2rem;
    padding-inline: 0.5rem;
    border-radius: 0.3rem;
    border: none;
    cursor: pointer;
    position: relative;
}
.theme-choices .theme-preset::before {
    content: '';
    position: absolute;
    inset: -.4rem;
    border-radius: .7rem;
    border: 2px solid transparent;
    transition: border-color .3s;
}
.theme-choices .theme-preset:hover::before {
    border-color: var(--color-text-subdue);
}
.theme-choices .theme-preset.current::before {
    border-color: var(--color-text-base);
}
.theme-preset-light {
    gap: 0.3rem;
    height: 1.8rem;
}
.theme-color {
    background-color: var(--color);
    width: 0.9rem;
    height: 0.9rem;
    border-radius: 0.2rem;
}
.theme-preset-light .theme-color {
    width: 1rem;
    height: 1rem;
    border-radius: 0.3rem;
}
.current-theme-preview {
    opacity: 0.4;
    transition: opacity .3s;
}
.theme-picker.popover-active .current-theme-preview, .theme-picker:hover {
    opacity: 1;
}
</file>

<file path="internal/glance/templates/document.html">
<!DOCTYPE html>
<html lang="en" id="top" data-theme="{{ .Request.Theme.Key }}"
    data-scheme="{{ if .Request.Theme.Light }}light{{ else }}dark{{ end }}">
<head>
    {{ block "document-head-before" . }}{{ end }}
    <!-- Reactivity Foundation -->
    <script src="https://unpkg.com/htmx.org@1.9.12"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
    <script>
        function setupWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const ws = new WebSocket(`${protocol}//${window.location.host}/ws`);
            ws.onmessage = function (event) {
                const html = event.data;
                // Parse the incoming HTML
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                const newElement = doc.body.firstElementChild;
                if (newElement && newElement.id) {
                    const existing = document.getElementById(newElement.id);
                    if (existing) {
                        existing.outerHTML = newElement.outerHTML;
                        // Tell HTMX to process the new element
                        if (window.htmx) {
                            htmx.process(document.getElementById(newElement.id));
                        }
                    }
                }
            };
            ws.onclose = function () {
                setTimeout(setupWebSocket, 5000); // Reconnect
            };
        }
        setupWebSocket();
    </script>
    <script>
        if (navigator.platform === 'iPhone') document.documentElement.classList.add('ios');
        const pageData = {
        /*{{ if .Page }}*/slug: "{{ .Page.Slug }}",/*{{ end }}*/
            baseURL: "{{ .App.Config.Server.BaseURL }}",
            theme: "{{ .Request.Theme.Key }}",
        };
    </script>
    <title>{{ block "document-title" . }}{{ end }}</title>
    <meta charset="UTF-8">
    <meta name="color-scheme" content="dark">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="{{ .App.Config.Branding.AppName }}">
    <meta name="theme-color" content="{{ .Request.Theme.BackgroundColorAsHex }}">
    <link rel="apple-touch-icon" sizes="512x512" href='{{ .App.Config.Branding.AppIconURL }}'>
    <link rel="manifest" href='{{ .App.VersionedAssetPath "manifest.json" }}'>
    <link rel="icon" type="{{ .App.Config.Branding.FaviconType }}" href="{{ .App.Config.Branding.FaviconURL }}" />
    <link rel="stylesheet" href='{{ .App.StaticAssetPath "css/bundle.css" }}'>
    <style id="theme-style">
        {
                {
                .Request.Theme.CSS
            }
        }
    </style>
    {{ if .App.Config.Theme.CustomCSSFile }}
    <link rel="stylesheet" href="{{ .App.Config.Theme.CustomCSSFile }}?v={{ .App.CreatedAt.Unix }}">{{ end }}
    {{ block "document-head-after" . }}{{ end }}
    {{ if .App.Config.Document.Head }}{{ .App.Config.Document.Head }}{{ end }}
</head>
<body>
    {{ template "document-body" . }}
</body>
</html>
</file>

<file path="internal/glance/templates/page.html">
{{ template "document.html" . }}
{{ define "document-title" }}{{ .Page.Title }}{{ end }}
{{ define "document-head-after" }}
<script type="module" src='{{ .App.StaticAssetPath "js/page.js" }}'></script>
{{ end }}
{{ define "navigation-links" }}
{{ range .App.Config.Pages }}
<a href="{{ $.App.Config.Server.BaseURL }}/{{ .Slug }}" class="nav-item{{ if eq .Slug $.Page.Slug }} nav-item-current{{ end }}"{{ if eq .Slug $.Page.Slug }} aria-current="page"{{ end }}>{{ .Title }}</a>
{{ end }}
{{ end }}
{{ define "document-body" }}
<div class="flex flex-column body-content">
    {{ if not .Page.HideDesktopNavigation }}
    <div class="header-container content-bounds{{ if .Page.DesktopNavigationWidth }} content-bounds-{{ .Page.DesktopNavigationWidth }} {{ end }}">
        <div class="header flex padding-inline-widget widget-content-frame">
            <div class="logo" aria-hidden="true">
                {{- if .App.Config.Branding.LogoURL }}
                <img src="{{ .App.Config.Branding.LogoURL }}" alt="">
                {{- else if .App.Config.Branding.LogoText }}
                {{- .App.Config.Branding.LogoText }}
                {{- else }}
                <svg style="max-height: 2rem;" width="100%" viewBox="0 0 108 108" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <rect fill="var(--color-text-subdue)" width="50" height="108" rx="6.875" />
                    <path fill="var(--color-primary)" fill-rule="evenodd" clip-rule="evenodd" d="M64.875 0C61.078 0 58 3.07804 58 6.875V43.125C58 46.922 61.078 50 64.875 50H101.125C104.922 50 108 46.922 108 43.125V6.875C108 3.07804 104.922 0 101.125 0H64.875ZM75.7545 11L71.3078 15.6814H85.2233C85.9209 15.6814 86.5835 15.6633 87.2113 15.627C87.839 15.5544 88.3273 15.4093 88.6761 15.1915L70 34.5706L73.4004 38L91.8149 18.7843C91.6056 19.1835 91.4487 19.7097 91.3441 20.3629C91.2743 20.9798 91.2394 21.5968 91.2394 22.2137V37.1835L96 32.2843V11H75.7545Z"/>
                    <rect fill="var(--color-text-base)" x="58" y="58" width="50" height="50" rx="6.875" />
                </svg>
                {{- end }}
            </div>
            <nav class="nav flex grow hide-scrollbars">
                {{ template "navigation-links" . }}
            </nav>
            {{ if not .App.Config.Theme.DisablePicker }}
            <div class="theme-picker self-center" data-popover-type="html" data-popover-position="below" data-popover-show-delay="0">
                <div class="current-theme-preview">
                    {{ .Request.Theme.PreviewHTML }}
                </div>
                <div data-popover-html>
                    <div class="theme-choices"></div>
                </div>
            </div>
            {{ end }}
            {{- if .App.RequiresAuth }}
            <a class="block self-center" href="{{ .App.Config.Server.BaseURL }}/logout" title="Logout">
                <svg class="logout-button" stroke="var(--color-text-subdue)" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 9V5.25A2.25 2.25 0 0 0 13.5 3h-6a2.25 2.25 0 0 0-2.25 2.25v13.5A2.25 2.25 0 0 0 7.5 21h6a2.25 2.25 0 0 0 2.25-2.25V15m3 0 3-3m0 0-3-3m3 3H9" />
                </svg>
            </a>
            {{- end }}
        </div>
    </div>
    {{ end }}
    <div class="mobile-navigation">
        <div class="mobile-navigation-icons">
            <a class="mobile-navigation-label" href="#top">↑</a>
            {{ range $i, $column := .Page.Columns }}
            <label class="mobile-navigation-label"><input type="radio" class="mobile-navigation-input" name="column" value="{{ $i }}" autocomplete="off"{{ if eq $i $.Page.PrimaryColumnIndex }} checked{{ end }}><div class="mobile-navigation-pill"></div></label>
            {{ end }}
            <label class="mobile-navigation-label"><input type="checkbox" class="mobile-navigation-page-links-input" autocomplete="on"><div class="hamburger-icon"></div></label>
        </div>
        <div class="mobile-navigation-page-links hide-scrollbars">
            {{ template "navigation-links" . }}
        </div>
        <div class="mobile-navigation-actions flex flex-column margin-block-10">
            {{ if not .App.Config.Theme.DisablePicker }}
            <div class="theme-picker flex justify-between items-center" data-popover-type="html" data-popover-position="above" data-popover-show-delay="0" data-popover-hide-delay="100" data-popover-anchor=".current-theme-preview" data-popover-trigger="click">
                <div data-popover-html>
                    <div class="theme-choices">
                        {{ .App.Config.Theme.PreviewHTML }}
                        {{ range $_, $preset := .App.Config.Theme.Presets.Items }}
                        {{ $preset.PreviewHTML }}
                        {{ end }}
                    </div>
                </div>
                <div class="size-h3 pointer-events-none select-none">Change theme</div>
                <div class="flex gap-15 items-center pointer-events-none">
                    <div class="current-theme-preview">
                        {{ .Request.Theme.PreviewHTML }}
                    </div>
                    <svg class="ui-icon" stroke="var(--color-text-subdue)" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M4.098 19.902a3.75 3.75 0 0 0 5.304 0l6.401-6.402M6.75 21A3.75 3.75 0 0 1 3 17.25V4.125C3 3.504 3.504 3 4.125 3h5.25c.621 0 1.125.504 1.125 1.125v4.072M6.75 21a3.75 3.75 0 0 0 3.75-3.75V8.197M6.75 21h13.125c.621 0 1.125-.504 1.125-1.125v-5.25c0-.621-.504-1.125-1.125-1.125h-4.072M10.5 8.197l2.88-2.88c.438-.439 1.15-.439 1.59 0l3.712 3.713c.44.44.44 1.152 0 1.59l-2.879 2.88M6.75 17.25h.008v.008H6.75v-.008Z" />
                    </svg>
                </div>
            </div>
            {{ end }}
            {{ if .App.RequiresAuth }}
            <a href="{{ .App.Config.Server.BaseURL }}/logout" class="flex justify-between items-center">
                <div class="size-h3">Logout</div>
                <svg class="ui-icon" stroke="var(--color-text-subdue)" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 9V5.25A2.25 2.25 0 0 0 13.5 3h-6a2.25 2.25 0 0 0-2.25 2.25v13.5A2.25 2.25 0 0 0 7.5 21h6a2.25 2.25 0 0 0 2.25-2.25V15m3 0 3-3m0 0-3-3m3 3H9" />
                </svg>
            </a>
            {{ end }}
        </div>
    </div>
    <div class="content-bounds grow{{ if .Page.Width }} content-bounds-{{ .Page.Width }}{{ end }}">
        <main class="page{{ if .Page.CenterVertically }} center-vertically{{ end }}" id="page" aria-live="polite" aria-busy="true">
            <h1 class="visually-hidden">{{ .Page.Title }}</h1>
            <div class="page-content" id="page-content"></div>
            <div class="page-loading-container">
                <div class="visually-hidden">Loading</div>
                <div class="loading-icon" aria-hidden="true"></div>
            </div>
        </main>
    </div>
    {{ template "footer.html" . }}
    <div class="mobile-navigation-offset"></div>
</div>
{{ end }}
</file>

<file path="internal/glance/widget-custom-api.go">
package glance
import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"html/template"
	"io"
	"log/slog"
	"math"
	"net/http"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"sync"
	"time"
	"github.com/tidwall/gjson"
)
var customAPIWidgetTemplate = mustParseTemplate("custom-api.html", "widget-base.html")
// Needs to be exported for the YAML unmarshaler to work
type CustomAPIRequest struct {
	URL                string               `yaml:"url"`
	AllowInsecure      bool                 `yaml:"allow-insecure"`
	Headers            map[string]string    `yaml:"headers"`
	Parameters         queryParametersField `yaml:"parameters"`
	Method             string               `yaml:"method"`
	BodyType           string               `yaml:"body-type"`
	Body               any                  `yaml:"body"`
	SkipJSONValidation bool                 `yaml:"skip-json-validation"`
	bodyReader         io.ReadSeeker        `yaml:"-"`
	httpRequest        *http.Request        `yaml:"-"`
}
type customAPIWidget struct {
	widgetBase        `yaml:",inline"`
	*CustomAPIRequest `yaml:",inline"`             // the primary request
	Subrequests       map[string]*CustomAPIRequest `yaml:"subrequests"`
	Options           customAPIOptions             `yaml:"options"`
	Template          string                       `yaml:"template"`
	Frameless         bool                         `yaml:"frameless"`
	compiledTemplate  *template.Template           `yaml:"-"`
	CompiledHTML      template.HTML                `yaml:"-"`
}
func (widget *customAPIWidget) initialize() error {
	widget.withTitle("Custom API").withCacheDuration(1 * time.Hour)
	if err := widget.CustomAPIRequest.initialize(); err != nil {
		return fmt.Errorf("initializing primary request: %v", err)
	}
	for key := range widget.Subrequests {
		if err := widget.Subrequests[key].initialize(); err != nil {
			return fmt.Errorf("initializing subrequest %q: %v", key, err)
		}
	}
	if widget.Template == "" {
		return errors.New("template is required")
	}
	compiledTemplate, err := template.New("").Funcs(customAPITemplateFuncs).Parse(widget.Template)
	if err != nil {
		return fmt.Errorf("parsing template: %w", err)
	}
	widget.compiledTemplate = compiledTemplate
	return nil
}
func (widget *customAPIWidget) update(ctx context.Context) {
	compiledHTML, err := fetchAndRenderCustomAPIRequest(
		widget.CustomAPIRequest, widget.Subrequests, widget.Options, widget.compiledTemplate,
	)
	if !widget.canContinueUpdateAfterHandlingErr(err) {
		return
	}
	widget.CompiledHTML = compiledHTML
}
func (widget *customAPIWidget) Render() template.HTML {
	return widget.renderTemplate(widget, customAPIWidgetTemplate)
}
type customAPIOptions map[string]any
func (o *customAPIOptions) StringOr(key, defaultValue string) string {
	return customAPIGetOptionOrDefault(*o, key, defaultValue)
}
func (o *customAPIOptions) IntOr(key string, defaultValue int) int {
	return customAPIGetOptionOrDefault(*o, key, defaultValue)
}
func (o *customAPIOptions) FloatOr(key string, defaultValue float64) float64 {
	return customAPIGetOptionOrDefault(*o, key, defaultValue)
}
func (o *customAPIOptions) BoolOr(key string, defaultValue bool) bool {
	return customAPIGetOptionOrDefault(*o, key, defaultValue)
}
func (o *customAPIOptions) JSON(key string) string {
	value, exists := (*o)[key]
	if !exists {
		panic(fmt.Sprintf("key %q does not exist in options", key))
	}
	encoded, err := json.Marshal(value)
	if err != nil {
		panic(fmt.Sprintf("marshaling %s: %v", key, err))
	}
	return string(encoded)
}
func customAPIGetOptionOrDefault[T any](o customAPIOptions, key string, defaultValue T) T {
	if value, exists := o[key]; exists {
		if typedValue, ok := value.(T); ok {
			return typedValue
		}
	}
	return defaultValue
}
func (req *CustomAPIRequest) initialize() error {
	if req == nil || req.URL == "" {
		return nil
	}
	if req.Body != nil {
		if req.Method == "" {
			req.Method = http.MethodPost
		}
		if req.BodyType == "" {
			req.BodyType = "json"
		}
		if req.BodyType != "json" && req.BodyType != "string" {
			return errors.New("invalid body type, must be either 'json' or 'string'")
		}
		switch req.BodyType {
		case "json":
			encoded, err := json.Marshal(req.Body)
			if err != nil {
				return fmt.Errorf("marshaling body: %v", err)
			}
			req.bodyReader = bytes.NewReader(encoded)
		case "string":
			bodyAsString, ok := req.Body.(string)
			if !ok {
				return errors.New("body must be a string when body-type is 'string'")
			}
			req.bodyReader = strings.NewReader(bodyAsString)
		}
	} else if req.Method == "" {
		req.Method = http.MethodGet
	}
	httpReq, err := http.NewRequest(strings.ToUpper(req.Method), req.URL, req.bodyReader)
	if err != nil {
		return err
	}
	if len(req.Parameters) > 0 {
		httpReq.URL.RawQuery = req.Parameters.toQueryString()
	}
	if req.BodyType == "json" {
		httpReq.Header.Set("Content-Type", "application/json")
	}
	for key, value := range req.Headers {
		httpReq.Header.Add(key, value)
	}
	req.httpRequest = httpReq
	return nil
}
type customAPIResponseData struct {
	JSON     decoratedGJSONResult
	Response *http.Response
}
type customAPITemplateData struct {
	*customAPIResponseData
	subrequests map[string]*customAPIResponseData
	Options     customAPIOptions
}
func (data *customAPITemplateData) JSONLines() []decoratedGJSONResult {
	result := make([]decoratedGJSONResult, 0, 5)
	gjson.ForEachLine(data.JSON.Raw, func(line gjson.Result) bool {
		result = append(result, decoratedGJSONResult{line})
		return true
	})
	return result
}
func (data *customAPITemplateData) Subrequest(key string) *customAPIResponseData {
	req, exists := data.subrequests[key]
	if !exists {
		// We have to panic here since there's nothing sensible we can return and the
		// lack of an error would cause requested data to return zero values which
		// would be confusing from the user's perspective. Go's template module
		// handles recovering from panics and will return the panic message as an
		// error during template execution.
		panic(fmt.Sprintf("subrequest with key %q has not been defined", key))
	}
	return req
}
func fetchCustomAPIResponse(ctx context.Context, req *CustomAPIRequest) (*customAPIResponseData, error) {
	if req == nil || req.URL == "" {
		return &customAPIResponseData{
			JSON:     decoratedGJSONResult{gjson.Result{}},
			Response: &http.Response{},
		}, nil
	}
	if req.bodyReader != nil {
		req.bodyReader.Seek(0, io.SeekStart)
	}
	client := ternary(req.AllowInsecure, defaultInsecureHTTPClient, defaultHTTPClient)
	resp, err := client.Do(req.httpRequest.WithContext(ctx))
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	bodyBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	body := strings.TrimSpace(string(bodyBytes))
	if !req.SkipJSONValidation && body != "" && !gjson.Valid(body) {
		if 200 <= resp.StatusCode && resp.StatusCode < 300 {
			truncatedBody, isTruncated := limitStringLength(body, 100)
			if isTruncated {
				truncatedBody += "... <truncated>"
			}
			slog.Error("Invalid response JSON in custom API widget", "url", req.httpRequest.URL.String(), "body", truncatedBody)
			return nil, errors.New("invalid response JSON")
		}
		return nil, fmt.Errorf("%d %s", resp.StatusCode, http.StatusText(resp.StatusCode))
	}
	return &customAPIResponseData{
		JSON:     decoratedGJSONResult{gjson.Parse(body)},
		Response: resp,
	}, nil
}
func fetchAndRenderCustomAPIRequest(
	primaryReq *CustomAPIRequest,
	subReqs map[string]*CustomAPIRequest,
	options customAPIOptions,
	tmpl *template.Template,
) (template.HTML, error) {
	var primaryData *customAPIResponseData
	subData := make(map[string]*customAPIResponseData, len(subReqs))
	var err error
	if len(subReqs) == 0 {
		// If there are no subrequests, we can fetch the primary request in a much simpler way
		primaryData, err = fetchCustomAPIResponse(context.Background(), primaryReq)
	} else {
		// If there are subrequests, we need to fetch them concurrently
		// and cancel all requests if any of them fail. There's probably
		// a more elegant way to do this, but this works for now.
		ctx, cancel := context.WithCancel(context.Background())
		defer cancel()
		var wg sync.WaitGroup
		var mu sync.Mutex // protects subData and err
		wg.Add(1)
		go func() {
			defer wg.Done()
			var localErr error
			primaryData, localErr = fetchCustomAPIResponse(ctx, primaryReq)
			mu.Lock()
			if localErr != nil && err == nil {
				err = localErr
				cancel()
			}
			mu.Unlock()
		}()
		for key, req := range subReqs {
			wg.Add(1)
			go func() {
				defer wg.Done()
				var localErr error
				var data *customAPIResponseData
				data, localErr = fetchCustomAPIResponse(ctx, req)
				mu.Lock()
				if localErr == nil {
					subData[key] = data
				} else if err == nil {
					err = localErr
					cancel()
				}
				mu.Unlock()
			}()
		}
		wg.Wait()
	}
	emptyBody := template.HTML("")
	if err != nil {
		return emptyBody, err
	}
	data := customAPITemplateData{
		customAPIResponseData: primaryData,
		subrequests:           subData,
		Options:               options,
	}
	var templateBuffer bytes.Buffer
	err = tmpl.Execute(&templateBuffer, &data)
	if err != nil {
		return emptyBody, err
	}
	return template.HTML(templateBuffer.String()), nil
}
type decoratedGJSONResult struct {
	gjson.Result
}
func gJsonResultArrayToDecoratedResultArray(results []gjson.Result) []decoratedGJSONResult {
	decoratedResults := make([]decoratedGJSONResult, len(results))
	for i, result := range results {
		decoratedResults[i] = decoratedGJSONResult{result}
	}
	return decoratedResults
}
func (r *decoratedGJSONResult) Exists(key string) bool {
	return r.Result.Get(key).Exists()
}
func (r *decoratedGJSONResult) Array(key string) []decoratedGJSONResult {
	if key == "" {
		return gJsonResultArrayToDecoratedResultArray(r.Result.Array())
	}
	return gJsonResultArrayToDecoratedResultArray(r.Result.Get(key).Array())
}
func (r *decoratedGJSONResult) String(key string) string {
	if key == "" {
		return r.Result.String()
	}
	return r.Result.Get(key).String()
}
func (r *decoratedGJSONResult) Int(key string) int {
	if key == "" {
		return int(r.Result.Int())
	}
	return int(r.Result.Get(key).Int())
}
func (r *decoratedGJSONResult) Float(key string) float64 {
	if key == "" {
		return r.Result.Float()
	}
	return r.Result.Get(key).Float()
}
func (r *decoratedGJSONResult) Bool(key string) bool {
	if key == "" {
		return r.Result.Bool()
	}
	return r.Result.Get(key).Bool()
}
func (r *decoratedGJSONResult) Get(key string) *decoratedGJSONResult {
	return &decoratedGJSONResult{r.Result.Get(key)}
}
func customAPIDoMathOp[T int | float64](a, b T, op string) T {
	switch op {
	case "add":
		return a + b
	case "sub":
		return a - b
	case "mul":
		return a * b
	case "div":
		if b == 0 {
			return 0
		}
		return a / b
	}
	return 0
}
var customAPITemplateFuncs = func() template.FuncMap {
	var regexpCacheMu sync.Mutex
	var regexpCache = make(map[string]*regexp.Regexp)
	getCachedRegexp := func(pattern string) *regexp.Regexp {
		regexpCacheMu.Lock()
		defer regexpCacheMu.Unlock()
		regex, exists := regexpCache[pattern]
		if !exists {
			regex = regexp.MustCompile(pattern)
			regexpCache[pattern] = regex
		}
		return regex
	}
	doMathOpWithAny := func(a, b any, op string) any {
		switch at := a.(type) {
		case int:
			switch bt := b.(type) {
			case int:
				return customAPIDoMathOp(at, bt, op)
			case float64:
				return customAPIDoMathOp(float64(at), bt, op)
			default:
				return math.NaN()
			}
		case float64:
			switch bt := b.(type) {
			case int:
				return customAPIDoMathOp(at, float64(bt), op)
			case float64:
				return customAPIDoMathOp(at, bt, op)
			default:
				return math.NaN()
			}
		default:
			return math.NaN()
		}
	}
	funcs := template.FuncMap{
		"toFloat": func(a int) float64 {
			return float64(a)
		},
		"toInt": func(a float64) int {
			return int(a)
		},
		"add": func(a, b any) any {
			return doMathOpWithAny(a, b, "add")
		},
		"sub": func(a, b any) any {
			return doMathOpWithAny(a, b, "sub")
		},
		"mul": func(a, b any) any {
			return doMathOpWithAny(a, b, "mul")
		},
		"div": func(a, b any) any {
			return doMathOpWithAny(a, b, "div")
		},
		"mod": func(a, b int) int {
			if b == 0 {
				return 0
			}
			return a % b
		},
		"now": func() time.Time {
			return time.Now()
		},
		"offsetNow": func(offset string) time.Time {
			d, err := time.ParseDuration(offset)
			if err != nil {
				return time.Now()
			}
			return time.Now().Add(d)
		},
		"duration": func(str string) time.Duration {
			d, err := time.ParseDuration(str)
			if err != nil {
				return 0
			}
			return d
		},
		"parseTime": func(layout, value string) time.Time {
			return customAPIFuncParseTimeInLocation(layout, value, time.UTC)
		},
		"formatTime": customAPIFuncFormatTime,
		"parseLocalTime": func(layout, value string) time.Time {
			return customAPIFuncParseTimeInLocation(layout, value, time.Local)
		},
		"toRelativeTime": dynamicRelativeTimeAttrs,
		"parseRelativeTime": func(layout, value string) template.HTMLAttr {
			// Shorthand to do both of the above with a single function call
			return dynamicRelativeTimeAttrs(customAPIFuncParseTimeInLocation(layout, value, time.UTC))
		},
		"startOfDay": func(t time.Time) time.Time {
			return time.Date(t.Year(), t.Month(), t.Day(), 0, 0, 0, 0, t.Location())
		},
		"endOfDay": func(t time.Time) time.Time {
			return time.Date(t.Year(), t.Month(), t.Day(), 23, 59, 59, 0, t.Location())
		},
		// The reason we flip the parameter order is so that you can chain multiple calls together like this:
		// {{ .JSON.String "foo" | trimPrefix "bar" | doSomethingElse }}
		// instead of doing this:
		// {{ trimPrefix (.JSON.String "foo") "bar" | doSomethingElse }}
		// since the piped value gets passed as the last argument to the function.
		"trimPrefix": func(prefix, s string) string {
			return strings.TrimPrefix(s, prefix)
		},
		"trimSuffix": func(suffix, s string) string {
			return strings.TrimSuffix(s, suffix)
		},
		"trimSpace": strings.TrimSpace,
		"replaceAll": func(old, new, s string) string {
			return strings.ReplaceAll(s, old, new)
		},
		"replaceMatches": func(pattern, replacement, s string) string {
			if s == "" {
				return ""
			}
			return getCachedRegexp(pattern).ReplaceAllString(s, replacement)
		},
		"findMatch": func(pattern, s string) string {
			if s == "" {
				return ""
			}
			return getCachedRegexp(pattern).FindString(s)
		},
		"findSubmatch": func(pattern, s string) string {
			if s == "" {
				return ""
			}
			regex := getCachedRegexp(pattern)
			return itemAtIndexOrDefault(regex.FindStringSubmatch(s), 1, "")
		},
		"percentChange": percentChange,
		"sortByString": func(key, order string, results []decoratedGJSONResult) []decoratedGJSONResult {
			sort.Slice(results, func(a, b int) bool {
				if order == "asc" {
					return results[a].String(key) < results[b].String(key)
				}
				return results[a].String(key) > results[b].String(key)
			})
			return results
		},
		"sortByInt": func(key, order string, results []decoratedGJSONResult) []decoratedGJSONResult {
			sort.Slice(results, func(a, b int) bool {
				if order == "asc" {
					return results[a].Int(key) < results[b].Int(key)
				}
				return results[a].Int(key) > results[b].Int(key)
			})
			return results
		},
		"sortByFloat": func(key, order string, results []decoratedGJSONResult) []decoratedGJSONResult {
			sort.Slice(results, func(a, b int) bool {
				if order == "asc" {
					return results[a].Float(key) < results[b].Float(key)
				}
				return results[a].Float(key) > results[b].Float(key)
			})
			return results
		},
		"sortByTime": func(key, layout, order string, results []decoratedGJSONResult) []decoratedGJSONResult {
			sort.Slice(results, func(a, b int) bool {
				timeA := customAPIFuncParseTimeInLocation(layout, results[a].String(key), time.UTC)
				timeB := customAPIFuncParseTimeInLocation(layout, results[b].String(key), time.UTC)
				if order == "asc" {
					return timeA.Before(timeB)
				}
				return timeA.After(timeB)
			})
			return results
		},
		"concat": func(items ...string) string {
			return strings.Join(items, "")
		},
		"unique": func(key string, results []decoratedGJSONResult) []decoratedGJSONResult {
			seen := make(map[string]struct{})
			out := make([]decoratedGJSONResult, 0, len(results))
			for _, result := range results {
				val := result.String(key)
				if _, ok := seen[val]; !ok {
					seen[val] = struct{}{}
					out = append(out, result)
				}
			}
			return out
		},
		"newRequest": func(url string) *CustomAPIRequest {
			return &CustomAPIRequest{
				URL: url,
			}
		},
		"withHeader": func(key, value string, req *CustomAPIRequest) *CustomAPIRequest {
			if req.Headers == nil {
				req.Headers = make(map[string]string)
			}
			req.Headers[key] = value
			return req
		},
		"withParameter": func(key, value string, req *CustomAPIRequest) *CustomAPIRequest {
			if req.Parameters == nil {
				req.Parameters = make(queryParametersField)
			}
			req.Parameters[key] = append(req.Parameters[key], value)
			return req
		},
		"withStringBody": func(body string, req *CustomAPIRequest) *CustomAPIRequest {
			req.Body = body
			req.BodyType = "string"
			return req
		},
		"getResponse": func(req *CustomAPIRequest) *customAPIResponseData {
			err := req.initialize()
			if err != nil {
				panic(fmt.Sprintf("initializing request: %v", err))
			}
			data, err := fetchCustomAPIResponse(context.Background(), req)
			if err != nil {
				slog.Error("Could not fetch response within custom API template", "error", err)
				return &customAPIResponseData{
					JSON: decoratedGJSONResult{gjson.Result{}},
					Response: &http.Response{
						Status: err.Error(),
					},
				}
			}
			return data
		},
	}
	for key, value := range globalTemplateFunctions {
		if _, exists := funcs[key]; !exists {
			funcs[key] = value
		}
	}
	return funcs
}()
func customAPIFuncFormatTime(layout string, t time.Time) string {
	switch strings.ToLower(layout) {
	case "unix":
		return strconv.FormatInt(t.Unix(), 10)
	case "rfc3339":
		layout = time.RFC3339
	case "rfc3339nano":
		layout = time.RFC3339Nano
	case "datetime":
		layout = time.DateTime
	case "dateonly":
		layout = time.DateOnly
	}
	return t.Format(layout)
}
func customAPIFuncParseTimeInLocation(layout, value string, loc *time.Location) time.Time {
	switch strings.ToLower(layout) {
	case "unix":
		asInt, err := strconv.ParseInt(value, 10, 64)
		if err != nil {
			return time.Unix(0, 0)
		}
		return time.Unix(asInt, 0)
	case "rfc3339":
		layout = time.RFC3339
	case "rfc3339nano":
		layout = time.RFC3339Nano
	case "datetime":
		layout = time.DateTime
	case "dateonly":
		layout = time.DateOnly
	}
	parsed, err := time.ParseInLocation(layout, value, loc)
	if err != nil {
		return time.Unix(0, 0)
	}
	return parsed
}
</file>

<file path="internal/glance/glance.go">
package glance
import (
	"bytes"
	"context"
	"encoding/base64"
	"fmt"
	"log"
	"net/http"
	"path/filepath"
	"slices"
	"strconv"
	"strings"
	"sync"
	"time"
	"golang.org/x/crypto/bcrypt"
)
var (
	pageTemplate        = mustParseTemplate("page.html", "document.html", "footer.html")
	pageContentTemplate = mustParseTemplate("page-content.html")
	manifestTemplate    = mustParseTemplate("manifest.json")
)
const STATIC_ASSETS_CACHE_DURATION = 24 * time.Hour
var reservedPageSlugs = []string{"login", "logout"}
type application struct {
	Version   string
	CreatedAt time.Time
	Config    config
	parsedManifest []byte
	slugToPage map[string]*page
	widgetByID map[uint64]widget
	RequiresAuth           bool
	authSecretKey          []byte
	usernameHashToUsername map[string]string
	authAttemptsMu         sync.Mutex
	failedAuthAttempts     map[string]*failedAuthAttempt
	hub *hub
}
func newApplication(c *config) (*application, error) {
	app := &application{
		Version:    buildVersion,
		CreatedAt:  time.Now(),
		Config:     *c,
		slugToPage: make(map[string]*page),
		widgetByID: make(map[uint64]widget),
		hub:        newHub(),
	}
	config := &app.Config
	go app.hub.run()
	//
	// Init auth
	//
	if len(config.Auth.Users) > 0 {
		secretBytes, err := base64.StdEncoding.DecodeString(config.Auth.SecretKey)
		if err != nil {
			return nil, fmt.Errorf("decoding secret-key: %v", err)
		}
		if len(secretBytes) != AUTH_SECRET_KEY_LENGTH {
			return nil, fmt.Errorf("secret-key must be exactly %d bytes", AUTH_SECRET_KEY_LENGTH)
		}
		app.usernameHashToUsername = make(map[string]string)
		app.failedAuthAttempts = make(map[string]*failedAuthAttempt)
		app.RequiresAuth = true
		for username := range config.Auth.Users {
			user := config.Auth.Users[username]
			usernameHash, err := computeUsernameHash(username, secretBytes)
			if err != nil {
				return nil, fmt.Errorf("computing username hash for user %s: %v", username, err)
			}
			app.usernameHashToUsername[string(usernameHash)] = username
			if user.PasswordHashString != "" {
				user.PasswordHash = []byte(user.PasswordHashString)
				user.PasswordHashString = ""
			} else {
				hashedPassword, err := bcrypt.GenerateFromPassword([]byte(user.Password), bcrypt.DefaultCost)
				if err != nil {
					return nil, fmt.Errorf("hashing password for user %s: %v", username, err)
				}
				user.Password = ""
				user.PasswordHash = hashedPassword
			}
		}
		app.authSecretKey = secretBytes
	}
	//
	// Init themes
	//
	if !config.Theme.DisablePicker {
		themeKeys := make([]string, 0, 2)
		themeProps := make([]*themeProperties, 0, 2)
		defaultDarkTheme, ok := config.Theme.Presets.Get("default-dark")
		if ok && !config.Theme.SameAs(defaultDarkTheme) || !config.Theme.SameAs(&themeProperties{}) {
			themeKeys = append(themeKeys, "default-dark")
			themeProps = append(themeProps, &themeProperties{})
		}
		themeKeys = append(themeKeys, "default-light")
		themeProps = append(themeProps, &themeProperties{
			Light:                    true,
			BackgroundColor:          &hslColorField{240, 13, 95},
			PrimaryColor:             &hslColorField{230, 100, 30},
			NegativeColor:            &hslColorField{0, 70, 50},
			ContrastMultiplier:       1.3,
			TextSaturationMultiplier: 0.5,
		})
		themePresets, err := newOrderedYAMLMap(themeKeys, themeProps)
		if err != nil {
			return nil, fmt.Errorf("creating theme presets: %v", err)
		}
		config.Theme.Presets = *themePresets.Merge(&config.Theme.Presets)
		for key, properties := range config.Theme.Presets.Items() {
			properties.Key = key
			if err := properties.init(); err != nil {
				return nil, fmt.Errorf("initializing preset theme %s: %v", key, err)
			}
		}
	}
	config.Theme.Key = "default"
	if err := config.Theme.init(); err != nil {
		return nil, fmt.Errorf("initializing default theme: %v", err)
	}
	//
	// Init pages
	//
	app.slugToPage[""] = &config.Pages[0]
	providers := &widgetProviders{
		assetResolver: app.StaticAssetPath,
		hub:           app.hub,
	}
	for p := range config.Pages {
		page := &config.Pages[p]
		page.PrimaryColumnIndex = -1
		if page.Slug == "" {
			page.Slug = titleToSlug(page.Title)
		}
		if slices.Contains(reservedPageSlugs, page.Slug) {
			return nil, fmt.Errorf("page slug \"%s\" is reserved", page.Slug)
		}
		app.slugToPage[page.Slug] = page
		if page.Width == "default" {
			page.Width = ""
		}
		if page.DesktopNavigationWidth == "" && page.DesktopNavigationWidth != "default" {
			page.DesktopNavigationWidth = page.Width
		}
		for i := range page.HeadWidgets {
			widget := page.HeadWidgets[i]
			app.widgetByID[widget.GetID()] = widget
			widget.setProviders(providers)
		}
		for c := range page.Columns {
			column := &page.Columns[c]
			if page.PrimaryColumnIndex == -1 && column.Size == "full" {
				page.PrimaryColumnIndex = int8(c)
			}
			for w := range column.Widgets {
				widget := column.Widgets[w]
				app.widgetByID[widget.GetID()] = widget
				widget.setProviders(providers)
			}
		}
	}
	config.Server.BaseURL = strings.TrimRight(config.Server.BaseURL, "/")
	config.Theme.CustomCSSFile = app.resolveUserDefinedAssetPath(config.Theme.CustomCSSFile)
	config.Branding.LogoURL = app.resolveUserDefinedAssetPath(config.Branding.LogoURL)
	config.Branding.FaviconURL = ternary(
		config.Branding.FaviconURL == "",
		app.StaticAssetPath("favicon.svg"),
		app.resolveUserDefinedAssetPath(config.Branding.FaviconURL),
	)
	config.Branding.FaviconType = ternary(
		strings.HasSuffix(config.Branding.FaviconURL, ".svg"),
		"image/svg+xml",
		"image/png",
	)
	if config.Branding.AppName == "" {
		config.Branding.AppName = "Glance"
	}
	if config.Branding.AppIconURL == "" {
		config.Branding.AppIconURL = app.StaticAssetPath("app-icon.png")
	}
	if config.Branding.AppBackgroundColor == "" {
		config.Branding.AppBackgroundColor = config.Theme.BackgroundColorAsHex
	}
	manifest, err := executeTemplateToString(manifestTemplate, templateData{App: app})
	if err != nil {
		return nil, fmt.Errorf("parsing manifest.json: %v", err)
	}
	app.parsedManifest = []byte(manifest)
	return app, nil
}
func (p *page) updateOutdatedWidgets() {
	now := time.Now()
	var wg sync.WaitGroup
	context := context.Background()
	for w := range p.HeadWidgets {
		widget := p.HeadWidgets[w]
		if !widget.requiresUpdate(&now) {
			continue
		}
		wg.Add(1)
		go func() {
			defer wg.Done()
			widget.update(context)
		}()
	}
	for c := range p.Columns {
		for w := range p.Columns[c].Widgets {
			widget := p.Columns[c].Widgets[w]
			if !widget.requiresUpdate(&now) {
				continue
			}
			wg.Add(1)
			go func() {
				defer wg.Done()
				widget.update(context)
			}()
		}
	}
	wg.Wait()
}
func (a *application) resolveUserDefinedAssetPath(path string) string {
	if strings.HasPrefix(path, "/assets/") {
		return a.Config.Server.BaseURL + path
	}
	return path
}
type templateRequestData struct {
	Theme *themeProperties
}
type templateData struct {
	App     *application
	Page    *page
	Request templateRequestData
}
func (a *application) populateTemplateRequestData(data *templateRequestData, r *http.Request) {
	theme := &a.Config.Theme.themeProperties
	if !a.Config.Theme.DisablePicker {
		selectedTheme, err := r.Cookie("theme")
		if err == nil {
			preset, exists := a.Config.Theme.Presets.Get(selectedTheme.Value)
			if exists {
				theme = preset
			}
		}
	}
	data.Theme = theme
}
func (a *application) handlePageRequest(w http.ResponseWriter, r *http.Request) {
	page, exists := a.slugToPage[r.PathValue("page")]
	if !exists {
		a.handleNotFound(w, r)
		return
	}
	if a.handleUnauthorizedResponse(w, r, redirectToLogin) {
		return
	}
	data := templateData{
		Page: page,
		App:  a,
	}
	a.populateTemplateRequestData(&data.Request, r)
	var responseBytes bytes.Buffer
	err := pageTemplate.Execute(&responseBytes, data)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		w.Write([]byte(err.Error()))
		return
	}
	w.Write(responseBytes.Bytes())
}
func (a *application) handlePageContentRequest(w http.ResponseWriter, r *http.Request) {
	page, exists := a.slugToPage[r.PathValue("page")]
	if !exists {
		a.handleNotFound(w, r)
		return
	}
	if a.handleUnauthorizedResponse(w, r, showUnauthorizedJSON) {
		return
	}
	pageData := templateData{
		Page: page,
	}
	var err error
	var responseBytes bytes.Buffer
	func() {
		page.mu.Lock()
		defer page.mu.Unlock()
		page.updateOutdatedWidgets()
		err = pageContentTemplate.Execute(&responseBytes, pageData)
	}()
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		w.Write([]byte(err.Error()))
		return
	}
	w.Write(responseBytes.Bytes())
}
func (a *application) addressOfRequest(r *http.Request) string {
	remoteAddrWithoutPort := func() string {
		for i := len(r.RemoteAddr) - 1; i >= 0; i-- {
			if r.RemoteAddr[i] == ':' {
				return r.RemoteAddr[:i]
			}
		}
		return r.RemoteAddr
	}
	if !a.Config.Server.Proxied {
		return remoteAddrWithoutPort()
	}
	// This should probably be configurable or look for multiple headers, not just this one
	forwardedFor := r.Header.Get("X-Forwarded-For")
	if forwardedFor == "" {
		return remoteAddrWithoutPort()
	}
	ips := strings.Split(forwardedFor, ",")
	if len(ips) == 0 || ips[0] == "" {
		return remoteAddrWithoutPort()
	}
	return ips[0]
}
func (a *application) handleNotFound(w http.ResponseWriter, _ *http.Request) {
	// TODO: add proper not found page
	w.WriteHeader(http.StatusNotFound)
	w.Write([]byte("Page not found"))
}
func (a *application) handleWidgetRequest(w http.ResponseWriter, r *http.Request) {
	widgetValue := r.PathValue("widget")
	widgetID, err := strconv.ParseUint(widgetValue, 10, 64)
	if err != nil {
		a.handleNotFound(w, r)
		return
	}
	widget, exists := a.widgetByID[widgetID]
	if !exists {
		a.handleNotFound(w, r)
		return
	}
	path := r.PathValue("path")
	if path == "render" {
		now := time.Now()
		if widget.requiresUpdate(&now) {
			widget.update(r.Context())
		}
		w.Header().Set("Content-Type", "text/html")
		w.Write([]byte(widget.Render()))
		return
	}
	widget.handleRequest(w, r)
}
func (a *application) StaticAssetPath(asset string) string {
	return a.Config.Server.BaseURL + "/static/" + staticFSHash + "/" + asset
}
func (a *application) VersionedAssetPath(asset string) string {
	return a.Config.Server.BaseURL + asset +
		"?v=" + strconv.FormatInt(a.CreatedAt.Unix(), 10)
}
func (a *application) server() (func() error, func() error) {
	mux := http.NewServeMux()
	mux.HandleFunc("GET /{$}", a.handlePageRequest)
	mux.HandleFunc("GET /{page}", a.handlePageRequest)
	mux.HandleFunc("GET /api/pages/{page}/content/{$}", a.handlePageContentRequest)
	if !a.Config.Theme.DisablePicker {
		mux.HandleFunc("POST /api/set-theme/{key}", a.handleThemeChangeRequest)
	}
	mux.HandleFunc("/api/widgets/{widget}/{path...}", a.handleWidgetRequest)
	mux.HandleFunc("/ws", a.hub.handleWebSocket)
	mux.HandleFunc("GET /api/healthz", func(w http.ResponseWriter, _ *http.Request) {
		w.WriteHeader(http.StatusOK)
	})
	if a.RequiresAuth {
		mux.HandleFunc("GET /login", a.handleLoginPageRequest)
		mux.HandleFunc("GET /logout", a.handleLogoutRequest)
		mux.HandleFunc("POST /api/authenticate", a.handleAuthenticationAttempt)
	}
	mux.Handle(
		fmt.Sprintf("GET /static/%s/{path...}", staticFSHash),
		http.StripPrefix(
			"/static/"+staticFSHash,
			fileServerWithCache(http.FS(staticFS), STATIC_ASSETS_CACHE_DURATION),
		),
	)
	assetCacheControlValue := fmt.Sprintf(
		"public, max-age=%d",
		int(STATIC_ASSETS_CACHE_DURATION.Seconds()),
	)
	mux.HandleFunc(fmt.Sprintf("GET /static/%s/css/bundle.css", staticFSHash), func(w http.ResponseWriter, r *http.Request) {
		w.Header().Add("Cache-Control", assetCacheControlValue)
		w.Header().Add("Content-Type", "text/css; charset=utf-8")
		w.Write(bundledCSSContents)
	})
	mux.HandleFunc("GET /manifest.json", func(w http.ResponseWriter, r *http.Request) {
		w.Header().Add("Cache-Control", assetCacheControlValue)
		w.Header().Add("Content-Type", "application/json")
		w.Write(a.parsedManifest)
	})
	var absAssetsPath string
	if a.Config.Server.AssetsPath != "" {
		absAssetsPath, _ = filepath.Abs(a.Config.Server.AssetsPath)
		assetsFS := fileServerWithCache(http.Dir(a.Config.Server.AssetsPath), 2*time.Hour)
		mux.Handle("/assets/{path...}", http.StripPrefix("/assets/", assetsFS))
	}
	server := http.Server{
		Addr:    fmt.Sprintf("%s:%d", a.Config.Server.Host, a.Config.Server.Port),
		Handler: mux,
	}
	start := func() error {
		log.Printf("Starting server on %s:%d (base-url: \"%s\", assets-path: \"%s\")\n",
			a.Config.Server.Host,
			a.Config.Server.Port,
			a.Config.Server.BaseURL,
			absAssetsPath,
		)
		if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			return err
		}
		return nil
	}
	stop := func() error {
		a.hub.close()
		return server.Close()
	}
	return start, stop
}
</file>

</files>
